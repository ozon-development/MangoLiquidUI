-- MangoLiquidUI — Loadstring Bundle
-- Generated by build.sh — do not edit manually
-- Usage: local MangoUI = loadstring(game:HttpGet("raw_github_url"))()

local _modules = {}
local _loaded = {}
local function _require(name)
    if _loaded[name] then return _loaded[name] end
    if not _modules[name] then error("Module not found: " .. name) end
    _loaded[name] = _modules[name]()
    return _loaded[name]
end

_modules["Types"] = function()


export type ThemePreset = {
	-- Glass surface
	BackgroundColor3: Color3,
	BackgroundTransparency: number,

	-- Lens (saturation tint via CanvasGroup)
	LensGroupColor3: Color3,
	LensGroupTransparency: number,

	-- Inner glow
	InnerGlowColor: Color3,
	InnerGlowTransparency: number,
	InnerGlowHeight: number, -- 0-1 fraction of parent height

	-- Inner edge highlight (full-perimeter inner shadow)
	InnerEdgeColor: Color3?,
	InnerEdgeTopTransparency: number?,
	InnerEdgeMidTransparency: number?,
	InnerEdgeBottomTransparency: number?,

	-- Fresnel rim (directional UIStroke)
	StrokeColor: Color3,
	StrokeThickness: number,
	FresnelStartTransparency: number, -- top edge
	FresnelEndTransparency: number, -- bottom edge
	FresnelMidTransparency: number, -- center keypoint transparency (brighter = lower)
	FresnelMidPoint: number, -- position of center keypoint (0-1, default 0.35)
	FresnelAngle: number, -- rotation in degrees (90 = top-lit)

	-- Shadow
	ShadowColor: Color3,
	ShadowTransparency: number, -- controls overall shadow intensity (higher = more subtle)
	ShadowSpread: number, -- px spread for outermost layer
	ShadowOffsetX: number, -- px horizontal offset
	ShadowOffsetY: number, -- px vertical offset

	-- Refraction proxy
	GlassColor: Color3,
	GlassTransparency: number,
	GlassReflectance: number,

	-- Noise
	NoiseOpacity: number,

	-- Text
	PrimaryTextColor: Color3,
	SecondaryTextColor: Color3,

	-- Toggle
	ToggleOnTrackColor: Color3?,
	ToggleOffTrackColor: Color3?,
	ToggleKnobColor: Color3?,

	-- Slider
	SliderTrackColor: Color3?,
	SliderFillColor: Color3?,
	SliderThumbColor: Color3?,

	-- Slider (glass track)
	SliderTrackTransparency: number?,
	SliderFillTransparency: number?,

	-- Button
	ButtonPressScale: number?,
	ButtonBackgroundTransparency: number?,

	-- Parallax
	ParallaxIntensity: number?,

	-- Notification stacking
	NotificationStackGap: number?,
	NotificationMaxVisible: number?,

	-- Segmented control
	SegmentedBackgroundTransparency: number?,
	SegmentedSelectedTransparency: number?,
	SegmentedSelectedColor: Color3?,

	-- Dropdown
	DropdownBackgroundTransparency: number?,
	DropdownItemHoverColor: Color3?,
	DropdownItemHoverTransparency: number?,

	-- Tab bar
	TabBarBackgroundTransparency: number?,
	TabBarSelectedColor: Color3?,
	TabBarIconColor: Color3?,
	TabBarIconSelectedColor: Color3?,

	-- Search bar
	SearchBarBackgroundTransparency: number?,
	SearchBarPlaceholderColor: Color3?,

	-- Text field
	TextFieldBackgroundTransparency: number?,
	TextFieldBorderColor: Color3?,
	TextFieldFocusBorderColor: Color3?,

	-- Checkbox
	CheckboxOnColor: Color3?,
	CheckboxOffColor: Color3?,
	CheckboxCheckColor: Color3?,

	-- Progress bar
	ProgressBarTrackTransparency: number?,
	ProgressBarFillColor: Color3?,
	ProgressBarFillTransparency: number?,

	-- Dialog
	DialogOverlayTransparency: number?,
	DialogBackgroundTransparency: number?,

	-- Shimmer
	ShimmerColor: Color3?,
	ShimmerTransparency: number?,

	-- Badge
	BadgeBackgroundColor: Color3?,
	BadgeBackgroundTransparency: number?,
	BadgeTextColor: Color3?,

	-- Tooltip
	TooltipBackgroundTransparency: number?,

	-- Stepper
	StepperBackgroundTransparency: number?,

	-- Skeleton
	SkeletonBackgroundColor: Color3?,
	SkeletonBackgroundTransparency: number?,

	-- Toast
	ToastBackgroundTransparency: number?,

	-- Bottom Sheet
	BottomSheetBackgroundTransparency: number?,
	BottomSheetHandleColor: Color3?,

	-- Blur Proxy
	BlurTintColor: Color3?,
	BlurTintTransparency: number?,

	-- Form
	FormErrorColor: Color3?,

	-- Focus Manager
	FocusRingColor: Color3?,

	-- Window
	WindowBackgroundTransparency: number?,
	WindowTitleColor: Color3?,

	-- Color Picker
	ColorPickerCursorColor: Color3?,

	-- Keybind
	KeybindPillTransparency: number?,
	KeybindListeningColor: Color3?,

	-- Accent color (used by many components)
	AccentColor: Color3?,
}

export type MangoGlassConfig = {
	Size: UDim2?,
	Position: UDim2?,
	AnchorPoint: Vector2?,
	CornerRadius: UDim?,
	BackgroundColor3: Color3?,
	BackgroundTransparency: number?,
	NoiseOpacity: number?,
	NoiseImageId: string?,
	FresnelStartTransparency: number?,
	FresnelEndTransparency: number?,
	FresnelMidTransparency: number?,
	FresnelMidPoint: number?,
	FresnelAngle: number?,
	StrokeThickness: number?,
	StrokeColor: Color3?,
	InnerGlowTransparency: number?,
	InnerGlowColor: Color3?,
	InnerGlowHeight: number?,
	InnerEdgeColor: Color3?,
	InnerEdgeTopTransparency: number?,
	InnerEdgeMidTransparency: number?,
	InnerEdgeBottomTransparency: number?,
	LensGroupColor3: Color3?,
	LensGroupTransparency: number?,
	ShadowColor: Color3?,
	ShadowTransparency: number?,
	ShadowSpread: number?,
	ShadowOffsetX: number?,
	ShadowOffsetY: number?,
	ShadowEnabled: boolean?,
	ShadowLayerCount: number?, -- Number of shadow layers (default 6, max 12)
	LightweightMode: boolean?, -- Skip CanvasGroups for small elements like buttons
	ParallaxEnabled: boolean?,
	ParallaxIntensity: number?,
	Theme: ThemePreset?,
	Parent: GuiObject?,
}

export type RefractionProxyConfig = {
	TargetGui: GuiObject,
	GlassTransparency: number?,
	GlassMaterial: Enum.Material?,
	GlassColor: Color3?,
	GlassReflectance: number?,
	GlassThickness: number?,
	OffsetDepth: number?,
	Enabled: boolean?,
	ViewportMode: boolean?,
	Theme: ThemePreset?,
}

export type LiquidFusionConfig = {
	Target: GuiObject,
	BulgeScale: number?,
	BulgeDuration: number?,
	RestoreDuration: number?,
	SpecularShiftOffset: UDim2?,
	UseUIScale: boolean?,
}

export type MangoToggleConfig = {
	Position: UDim2?,
	AnchorPoint: Vector2?,
	Scale: number?,
	ShadowEnabled: boolean?,
	Theme: ThemePreset?,
	InitialState: boolean?,
	OnToggled: ((state: boolean) -> ())?,
	Parent: GuiObject?,
}

export type MangoSliderConfig = {
	Position: UDim2?,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	ShadowEnabled: boolean?,
	Theme: ThemePreset?,
	InitialValue: number?,
	Min: number?,
	Max: number?,
	Step: number?,
	OnChanged: ((value: number) -> ())?,
	Parent: GuiObject?,
}

export type MangoButtonConfig = {
	Position: UDim2?,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	Text: string?,
	TextSize: number?,
	BackgroundTransparency: number?,
	ShadowEnabled: boolean?,
	Theme: ThemePreset?,
	OnActivated: (() -> ())?,
	Parent: GuiObject?,
}

export type MangoBillboardLabelConfig = {
	TargetPart: BasePart?,
	TargetCharacter: Model?,
	Text: string?,
	TextSize: number?,
	Theme: ThemePreset?,
	MaxDistance: number?,
	StudsOffset: Vector3?,
	AlwaysOnTop: boolean?,
	Parent: Instance?,
}

export type MangoGlassFrame = {
	Container: Frame,
	Frame: Frame, -- alias for Container (backward compat)
	GlassSurface: Frame,
	ShadowLayers: {Frame},
	LensGroup: CanvasGroup?, -- nil in LightweightMode
	TextureGroup: CanvasGroup?, -- nil in LightweightMode
	NoiseLabel: ImageLabel?, -- nil in LightweightMode
	InnerHighlight: Frame?, -- nil in LightweightMode
	InnerEdgeFrame: Frame,
	InnerEdgeStroke: UIStroke,
	InnerEdgeGradient: UIGradient,
	SpecularFrame: Frame,
	SpecularStroke: UIStroke,
	SpecularGradient: UIGradient,
	SetLightDirection: (self: MangoGlassFrame, angle: number) -> (),
	SetParallaxEnabled: (self: MangoGlassFrame, enabled: boolean) -> (),
	Destroy: (self: MangoGlassFrame) -> (),
}

export type RefractionProxy = {
	GlassPart: Part,
	Enabled: boolean,
	SetEnabled: (self: RefractionProxy, enabled: boolean) -> (),
	UpdateTarget: (self: RefractionProxy, newGui: GuiObject) -> (),
	Destroy: (self: RefractionProxy) -> (),
}

export type LiquidFusionController = {
	Connect: (self: LiquidFusionController) -> (),
	Disconnect: (self: LiquidFusionController) -> (),
	TweenProperty: (self: LiquidFusionController, property: string, target: any, duration: number?) -> Tween,
	Destroy: (self: LiquidFusionController) -> (),
}

export type MangoToggle = {
	Container: Frame,
	SetState: (self: MangoToggle, state: boolean) -> (),
	GetState: (self: MangoToggle) -> boolean,
	Destroy: (self: MangoToggle) -> (),
}

export type MangoSlider = {
	Container: Frame,
	SetValue: (self: MangoSlider, value: number) -> (),
	GetValue: (self: MangoSlider) -> number,
	Destroy: (self: MangoSlider) -> (),
}

export type MangoButton = {
	Container: Frame,
	GlassSurface: Frame,
	TextLabel: TextLabel,
	SetText: (self: MangoButton, text: string) -> (),
	Destroy: (self: MangoButton) -> (),
}

export type MangoBillboardLabel = {
	BillboardGui: BillboardGui,
	GlassSurface: Frame,
	TextLabel: TextLabel,
	SetText: (self: MangoBillboardLabel, text: string) -> (),
	Destroy: (self: MangoBillboardLabel) -> (),
}

export type MangoNotificationConfig = {
	Title: string?,
	Body: string?,
	Icon: string?,
	Duration: number?,
	Type: string?,
	Actions: {MangoNotificationActionConfig}?,
	Theme: ThemePreset?,
	OnDismissed: (() -> ())?,
	Parent: Instance?,
}

export type MangoNotification = {
	Container: Frame,
	Show: (self: MangoNotification) -> (),
	Dismiss: (self: MangoNotification) -> (),
	SetPosition: (self: MangoNotification, position: UDim2) -> (),
	GetHeight: (self: MangoNotification) -> number,
	Destroy: (self: MangoNotification) -> (),
}

export type MangoEnvironmentLightConfig = {
	UpdateAngleEveryFrame: boolean?, -- default true
	TintUpdateInterval: number?, -- seconds, default 0.5
	TintInfluence: number?, -- 0-1, default 0.22
	Enabled: boolean?, -- default true
}

export type MangoEnvironmentLight = {
	Enable: (self: MangoEnvironmentLight) -> (),
	Disable: (self: MangoEnvironmentLight) -> (),
	IsEnabled: (self: MangoEnvironmentLight) -> boolean,
	GetSunAngle: (self: MangoEnvironmentLight) -> number,
	GetEnvironmentTint: (self: MangoEnvironmentLight) -> Color3,
	RegisterGlassFrame: (self: MangoEnvironmentLight, frame: MangoGlassFrame) -> (),
	UnregisterGlassFrame: (self: MangoEnvironmentLight, frame: MangoGlassFrame) -> (),
	Destroy: (self: MangoEnvironmentLight) -> (),
}

-- Notification Stack
export type MangoNotificationStackConfig = {
	MaxVisible: number?,
	StackGap: number?,
	Theme: ThemePreset?,
	Parent: Instance?,
}

export type MangoNotificationStack = {
	Push: (self: MangoNotificationStack, config: MangoNotificationConfig) -> MangoNotification,
	DismissAll: (self: MangoNotificationStack) -> (),
	GetCount: (self: MangoNotificationStack) -> number,
	Destroy: (self: MangoNotificationStack) -> (),
}

-- Segmented Control
export type MangoSegmentedControlConfig = {
	Position: UDim2?,
	AnchorPoint: Vector2?,
	Segments: {string}?,
	InitialIndex: number?,
	SegmentWidth: number?,
	Height: number?,
	Theme: ThemePreset?,
	OnChanged: ((index: number) -> ())?,
	Parent: GuiObject?,
}

export type MangoSegmentedControl = {
	Container: Frame,
	SetIndex: (self: MangoSegmentedControl, index: number) -> (),
	GetIndex: (self: MangoSegmentedControl) -> number,
	Destroy: (self: MangoSegmentedControl) -> (),
}

-- Dropdown
export type MangoDropdownConfig = {
	Position: UDim2?,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	Items: {string}?,
	InitialIndex: number?,
	MultiSelect: boolean?,
	InitialItems: {string}?,
	ShadowEnabled: boolean?,
	Theme: ThemePreset?,
	OnChanged: ((index: number) -> ())?,
	OnMultiChanged: (({string}) -> ())?,
	Parent: GuiObject?,
}

export type MangoDropdown = {
	Container: Frame,
	SetSelectedIndex: (self: MangoDropdown, index: number) -> (),
	GetSelectedIndex: (self: MangoDropdown) -> number,
	GetSelectedItems: (self: MangoDropdown) -> {string},
	SetItems: (self: MangoDropdown, items: {string}) -> (),
	Open: (self: MangoDropdown) -> (),
	Close: (self: MangoDropdown) -> (),
	Destroy: (self: MangoDropdown) -> (),
}

-- Tab Bar
export type MangoTabBarConfig = {
	Tabs: {{Icon: string?, Label: string}}?,
	InitialIndex: number?,
	Theme: ThemePreset?,
	OnChanged: ((index: number) -> ())?,
	Parent: GuiObject?,
}

export type MangoTabBar = {
	Container: Frame,
	SetIndex: (self: MangoTabBar, index: number) -> (),
	GetIndex: (self: MangoTabBar) -> number,
	Destroy: (self: MangoTabBar) -> (),
}

-- Search Bar
export type MangoSearchBarConfig = {
	Position: UDim2?,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	Placeholder: string?,
	Theme: ThemePreset?,
	OnTextChanged: ((text: string) -> ())?,
	OnSubmit: ((text: string) -> ())?,
	Parent: GuiObject?,
}

export type MangoSearchBar = {
	Container: Frame,
	GetText: (self: MangoSearchBar) -> string,
	SetText: (self: MangoSearchBar, text: string) -> (),
	Focus: (self: MangoSearchBar) -> (),
	Destroy: (self: MangoSearchBar) -> (),
}

-- Text Field
export type MangoTextFieldConfig = {
	Position: UDim2?,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	Placeholder: string?,
	InitialText: string?,
	Masked: boolean?,
	ShadowEnabled: boolean?,
	Theme: ThemePreset?,
	OnTextChanged: ((text: string) -> ())?,
	OnFocusLost: ((text: string, enterPressed: boolean) -> ())?,
	Parent: GuiObject?,
}

export type MangoTextField = {
	Container: Frame,
	GetText: (self: MangoTextField) -> string,
	SetText: (self: MangoTextField, text: string) -> (),
	Focus: (self: MangoTextField) -> (),
	Destroy: (self: MangoTextField) -> (),
}

-- Checkbox
export type MangoCheckboxConfig = {
	Position: UDim2?,
	AnchorPoint: Vector2?,
	Label: string?,
	InitialState: boolean?,
	Theme: ThemePreset?,
	OnToggled: ((state: boolean) -> ())?,
	Parent: GuiObject?,
}

export type MangoCheckbox = {
	Container: Frame,
	SetState: (self: MangoCheckbox, state: boolean) -> (),
	GetState: (self: MangoCheckbox) -> boolean,
	Destroy: (self: MangoCheckbox) -> (),
}

-- Progress Bar
export type MangoProgressBarConfig = {
	Position: UDim2?,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	InitialValue: number?,
	ShadowEnabled: boolean?,
	Theme: ThemePreset?,
	Parent: GuiObject?,
}

export type MangoProgressBar = {
	Container: Frame,
	SetValue: (self: MangoProgressBar, value: number) -> (),
	GetValue: (self: MangoProgressBar) -> number,
	Destroy: (self: MangoProgressBar) -> (),
}

-- Dialog
export type MangoDialogButtonConfig = {
	Text: string,
	Style: string?, -- "default" | "cancel" | "destructive"
	OnActivated: (() -> ())?,
}

export type MangoDialogConfig = {
	Title: string?,
	Message: string?,
	Buttons: {MangoDialogButtonConfig}?,
	Theme: ThemePreset?,
	OnDismissed: (() -> ())?,
	Parent: Instance?,
}

export type MangoDialog = {
	Show: (self: MangoDialog) -> (),
	Dismiss: (self: MangoDialog) -> (),
	Destroy: (self: MangoDialog) -> (),
}

-- Action Sheet
export type MangoActionSheetActionConfig = {
	Text: string,
	Style: string?, -- "default" | "destructive"
	OnActivated: (() -> ())?,
}

export type MangoActionSheetConfig = {
	Title: string?,
	Message: string?,
	Actions: {MangoActionSheetActionConfig}?,
	CancelText: string?,
	Theme: ThemePreset?,
	OnDismissed: (() -> ())?,
	Parent: Instance?,
}

export type MangoActionSheet = {
	Show: (self: MangoActionSheet) -> (),
	Dismiss: (self: MangoActionSheet) -> (),
	Destroy: (self: MangoActionSheet) -> (),
}

-- Intro
export type MangoIntroConfig = {
	Theme: ThemePreset?,
	Title: string?,
	Subtitle: string?,
	OnComplete: (() -> ())?,
	Parent: Instance?,
}

-- Shimmer
export type MangoShimmerConfig = {
	Target: GuiObject,
	ShimmerColor: Color3?,
	ShimmerTransparency: number?,
	ShimmerWidth: number?,
	Duration: number?,
	Enabled: boolean?,
	Theme: ThemePreset?,
}

export type MangoShimmer = {
	Enable: (self: MangoShimmer) -> (),
	Disable: (self: MangoShimmer) -> (),
	IsEnabled: (self: MangoShimmer) -> boolean,
	Destroy: (self: MangoShimmer) -> (),
}

-- Layout
export type MangoLayoutConfig = {
	Mode: string, -- "vstack" | "hstack" | "grid"
	Padding: number?,
	CellSize: UDim2?,
	HorizontalAlignment: Enum.HorizontalAlignment?,
	VerticalAlignment: Enum.VerticalAlignment?,
	PaddingTop: number?,
	PaddingBottom: number?,
	PaddingLeft: number?,
	PaddingRight: number?,
	Parent: GuiObject?,
}

export type MangoLayout = {
	Container: Frame,
	AddChild: (self: MangoLayout, child: GuiObject) -> (),
	RemoveChild: (self: MangoLayout, child: GuiObject) -> (),
	Clear: (self: MangoLayout) -> (),
	Destroy: (self: MangoLayout) -> (),
}

-- Badge
export type MangoBadgeConfig = {
	Position: UDim2?,
	AnchorPoint: Vector2?,
	Text: string?,
	TextSize: number?,
	TextColor: Color3?,
	BackgroundColor: Color3?,
	BackgroundTransparency: number?,
	Theme: ThemePreset?,
	Parent: GuiObject?,
}

export type MangoBadge = {
	Container: Frame,
	SetText: (self: MangoBadge, text: string) -> (),
	Destroy: (self: MangoBadge) -> (),
}

-- Skeleton
export type MangoSkeletonConfig = {
	Size: UDim2?,
	Position: UDim2?,
	AnchorPoint: Vector2?,
	CornerRadius: UDim?,
	Theme: ThemePreset?,
	Parent: GuiObject?,
}

export type MangoSkeleton = {
	Container: Frame,
	Destroy: (self: MangoSkeleton) -> (),
}

-- Stepper
export type MangoStepperConfig = {
	Position: UDim2?,
	AnchorPoint: Vector2?,
	InitialValue: number?,
	Min: number?,
	Max: number?,
	Step: number?,
	ShadowEnabled: boolean?,
	Theme: ThemePreset?,
	OnChanged: ((value: number) -> ())?,
	Parent: GuiObject?,
}

export type MangoStepper = {
	Container: Frame,
	SetValue: (self: MangoStepper, value: number) -> (),
	GetValue: (self: MangoStepper) -> number,
	Destroy: (self: MangoStepper) -> (),
}

-- Tooltip
export type MangoTooltipConfig = {
	Target: GuiObject?,
	Text: string?,
	TextSize: number?,
	MaxWidth: number?,
	Delay: number?,
	Placement: string?,
	ArrowSize: number?,
	Theme: ThemePreset?,
	Parent: GuiObject?,
}

export type MangoTooltip = {
	Show: (self: MangoTooltip) -> (),
	Hide: (self: MangoTooltip) -> (),
	SetText: (self: MangoTooltip, text: string) -> (),
	Destroy: (self: MangoTooltip) -> (),
}

-- Toast
export type MangoToastConfig = {
	Text: string?,
	Icon: string?,
	Duration: number?,
	Theme: ThemePreset?,
	OnDismissed: (() -> ())?,
	Parent: Instance?,
}

export type MangoToast = {
	Container: Frame,
	Show: (self: MangoToast) -> (),
	Dismiss: (self: MangoToast) -> (),
	SetPosition: (self: MangoToast, position: UDim2) -> (),
	GetHeight: (self: MangoToast) -> number,
	Destroy: (self: MangoToast) -> (),
}

-- Toast Stack
export type MangoToastStackConfig = {
	MaxVisible: number?,
	StackGap: number?,
	Theme: ThemePreset?,
	Parent: Instance?,
}

export type MangoToastStack = {
	Push: (self: MangoToastStack, config: MangoToastConfig) -> MangoToast,
	DismissAll: (self: MangoToastStack) -> (),
	GetCount: (self: MangoToastStack) -> number,
	Destroy: (self: MangoToastStack) -> (),
}

-- Context Menu
export type MangoContextMenuItemConfig = {
	Text: string,
	Icon: string?,
	Style: string?,
	Disabled: boolean?,
	OnActivated: (() -> ())?,
}

export type MangoContextMenuConfig = {
	Target: GuiObject?,
	Items: {MangoContextMenuItemConfig}?,
	Theme: ThemePreset?,
	Parent: GuiObject?,
}

export type MangoContextMenu = {
	Open: (self: MangoContextMenu, position: Vector2?) -> (),
	Close: (self: MangoContextMenu) -> (),
	SetItems: (self: MangoContextMenu, items: {MangoContextMenuItemConfig}) -> (),
	Destroy: (self: MangoContextMenu) -> (),
}

-- Bottom Sheet
export type MangoBottomSheetConfig = {
	Title: string?,
	ContentSize: UDim2?,
	SnapPositions: {number}?,
	InitialSnap: number?,
	DismissThreshold: number?,
	Theme: ThemePreset?,
	OnDismissed: (() -> ())?,
	OnSnapChanged: ((snapIndex: number) -> ())?,
	Parent: Instance?,
}

export type MangoBottomSheet = {
	Container: Frame,
	ContentFrame: Frame,
	Show: (self: MangoBottomSheet) -> (),
	Dismiss: (self: MangoBottomSheet) -> (),
	SnapTo: (self: MangoBottomSheet, snapIndex: number) -> (),
	Destroy: (self: MangoBottomSheet) -> (),
}

-- Blur Proxy
export type MangoBlurProxyConfig = {
	TargetGui: GuiObject,
	BlurRadius: number?,
	DownscaleFactor: number?,
	UpdateInterval: number?,
	Enabled: boolean?,
	Theme: ThemePreset?,
	Parent: GuiObject?,
}

export type MangoBlurProxy = {
	Container: Frame,
	SetEnabled: (self: MangoBlurProxy, enabled: boolean) -> (),
	IsEnabled: (self: MangoBlurProxy) -> boolean,
	Destroy: (self: MangoBlurProxy) -> (),
}

-- Form
export type MangoFormFieldConfig = {
	Name: string,
	Type: string, -- "text" | "checkbox" | "dropdown" | "slider"
	Label: string?,
	Required: boolean?,
	Placeholder: string?,
	Items: {string}?,
	Min: number?,
	Max: number?,
	InitialValue: any?,
	Validate: ((value: any) -> (boolean, string?))?,
}

export type MangoFormConfig = {
	Position: UDim2,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	Fields: {MangoFormFieldConfig},
	SubmitText: string?,
	Theme: ThemePreset?,
	OnSubmit: ((values: {[string]: any}) -> ())?,
	Parent: GuiObject?,
}

export type MangoForm = {
	Container: Frame,
	GetValues: (self: MangoForm) -> {[string]: any},
	Validate: (self: MangoForm) -> boolean,
	SetFieldValue: (self: MangoForm, name: string, value: any) -> (),
	Destroy: (self: MangoForm) -> (),
}

-- Focus Manager
export type MangoFocusManagerConfig = {
	Inputs: {GuiObject},
	SubmitCallback: (() -> ())?,
	DismissCallback: (() -> ())?,
	Enabled: boolean?,
}

export type MangoFocusManager = {
	Register: (self: MangoFocusManager, input: GuiObject) -> (),
	Unregister: (self: MangoFocusManager, input: GuiObject) -> (),
	FocusNext: (self: MangoFocusManager) -> (),
	FocusPrevious: (self: MangoFocusManager) -> (),
	FocusIndex: (self: MangoFocusManager, index: number) -> (),
	SetEnabled: (self: MangoFocusManager, enabled: boolean) -> (),
	Destroy: (self: MangoFocusManager) -> (),
}

-- Color Picker
export type MangoColorPickerConfig = {
	Position: UDim2?,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	InitialColor: Color3?,
	Theme: ThemePreset?,
	OnChanged: ((color: Color3) -> ())?,
	Parent: GuiObject?,
}

export type MangoColorPicker = {
	Container: Frame,
	GetColor: (self: MangoColorPicker) -> Color3,
	SetColor: (self: MangoColorPicker, color: Color3) -> (),
	Destroy: (self: MangoColorPicker) -> (),
}

-- Keybind
export type MangoKeybindConfig = {
	Position: UDim2?,
	AnchorPoint: Vector2?,
	Label: string?,
	DefaultKey: string?,
	ShadowEnabled: boolean?,
	Theme: ThemePreset?,
	OnKeyChanged: ((keyName: string) -> ())?,
	Parent: GuiObject?,
}

export type MangoKeybind = {
	Container: Frame,
	GetKey: (self: MangoKeybind) -> string,
	SetKey: (self: MangoKeybind, keyName: string) -> (),
	Destroy: (self: MangoKeybind) -> (),
}

-- Carousel
export type MangoCarouselTabConfig = {
	Icon: string?,
	Label: string?,
	Color: Color3?,
}

export type MangoCarouselConfig = {
	Tabs: {MangoCarouselTabConfig},
	Position: UDim2?,
	Size: UDim2?,
	AnchorPoint: Vector2?,
	InitialIndex: number?,
	IconSize: number?,
	Orientation: string?,
	Theme: ThemePreset?,
	OnChanged: ((index: number) -> ())?,
	Parent: GuiObject?,
}

export type MangoCarousel = {
	Container: Frame,
	SetIndex: (self: MangoCarousel, index: number) -> (),
	GetIndex: (self: MangoCarousel) -> number,
	Destroy: (self: MangoCarousel) -> (),
}

-- Save Manager
export type MangoSaveManagerConfig = {
	FolderName: string,
	FileName: string?,
}

export type MangoSaveManager = {
	Save: (self: MangoSaveManager, data: {[string]: any}) -> boolean,
	Load: (self: MangoSaveManager) -> {[string]: any}?,
	Delete: (self: MangoSaveManager) -> boolean,
}

-- Notification Action Button
export type MangoNotificationActionConfig = {
	Text: string,
	Style: string?,
	Callback: (() -> ())?,
}

-- Window Element (unified wrapper for all interactive elements)
export type MangoWindowElement = {
	CurrentValue: any,
	Set: (self: MangoWindowElement, value: any) -> (),
	Visible: (self: MangoWindowElement, visible: boolean) -> (),
	Lock: (self: MangoWindowElement, reason: string?) -> (),
	Unlock: (self: MangoWindowElement) -> (),
	Destroy: (self: MangoWindowElement) -> (),
}

-- Window Tab
export type MangoWindowTab = {
	Button: (self: MangoWindowTab, config: MangoWindowButtonConfig) -> MangoWindowElement,
	Toggle: (self: MangoWindowTab, config: MangoWindowToggleConfig) -> MangoWindowElement,
	Slider: (self: MangoWindowTab, config: MangoWindowSliderConfig) -> MangoWindowElement,
	Dropdown: (self: MangoWindowTab, config: MangoWindowDropdownConfig) -> MangoWindowElement,
	Input: (self: MangoWindowTab, config: MangoWindowInputConfig) -> MangoWindowElement,
	Checkbox: (self: MangoWindowTab, config: MangoWindowCheckboxConfig) -> MangoWindowElement,
	Stepper: (self: MangoWindowTab, config: MangoWindowStepperConfig) -> MangoWindowElement,
	Progress: (self: MangoWindowTab, config: MangoWindowProgressConfig) -> MangoWindowElement,
	ColorPicker: (self: MangoWindowTab, config: MangoWindowColorPickerConfig) -> MangoWindowElement,
	Keybind: (self: MangoWindowTab, config: MangoWindowKeybindConfig) -> MangoWindowElement,
	Label: (self: MangoWindowTab, text: string) -> MangoWindowElement,
	Paragraph: (self: MangoWindowTab, config: MangoWindowParagraphConfig) -> MangoWindowElement,
	Section: (self: MangoWindowTab, title: string) -> MangoWindowElement,
	Separator: (self: MangoWindowTab) -> MangoWindowElement,
}

-- Window element config types
export type MangoWindowButtonConfig = {
	Name: string,
	Callback: (() -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowToggleConfig = {
	Name: string,
	Default: boolean?,
	Callback: ((value: boolean) -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowSliderConfig = {
	Name: string,
	Range: {number},
	Increment: number?,
	Suffix: string?,
	Default: number?,
	Callback: ((value: number) -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowDropdownConfig = {
	Name: string,
	Options: {string},
	Default: (string | {string})?,
	MultiSelect: boolean?,
	Callback: ((value: any) -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowInputConfig = {
	Name: string,
	Default: string?,
	Placeholder: string?,
	Masked: boolean?,
	Callback: ((text: string) -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowCheckboxConfig = {
	Name: string,
	Default: boolean?,
	Callback: ((value: boolean) -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowStepperConfig = {
	Name: string,
	Range: {number}?,
	Default: number?,
	Callback: ((value: number) -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowProgressConfig = {
	Name: string,
	Default: number?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowColorPickerConfig = {
	Name: string,
	Default: Color3?,
	Callback: ((color: Color3) -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowKeybindConfig = {
	Name: string,
	Default: string?,
	Callback: ((keyName: string) -> ())?,
	Flag: string?,
	Visible: (boolean | string)?,
}

export type MangoWindowParagraphConfig = {
	Title: string,
	Content: string,
	Visible: (boolean | string)?,
}

-- Window Configuration Saving
export type MangoWindowConfigSaving = {
	Enabled: boolean,
	FolderName: string?,
	FileName: string?,
}

-- Window
export type MangoWindowConfig = {
	Name: string,
	Theme: ThemePreset?,
	Size: UDim2?,
	Position: UDim2?,
	ToggleKey: string?,
	ShowButton: string?,
	ConfigurationSaving: MangoWindowConfigSaving?,
	LoadingTitle: string?,
	LoadingSubtitle: string?,
	LoadingEnabled: boolean?,
}

export type MangoWindow = {
	Flags: {[string]: any},
	Tab: (self: MangoWindow, name: string, icon: string?) -> MangoWindowTab,
	Notify: (self: MangoWindow, config: MangoNotificationConfig) -> (),
	Dialog: (self: MangoWindow, config: MangoDialogConfig) -> (),
	Show: (self: MangoWindow) -> (),
	Hide: (self: MangoWindow) -> (),
	IsVisible: (self: MangoWindow) -> boolean,
	SaveConfig: (self: MangoWindow) -> (),
	LoadConfig: (self: MangoWindow) -> (),
	Destroy: (self: MangoWindow) -> (),
}

-- Builder
export type MangoBuilder = {
	text: (self: MangoBuilder, text: string) -> MangoBuilder,
	theme: (self: MangoBuilder, theme: ThemePreset) -> MangoBuilder,
	pos: (self: MangoBuilder, xScale: number, xOffset: number, yScale: number, yOffset: number) -> MangoBuilder,
	anchor: (self: MangoBuilder, x: number, y: number) -> MangoBuilder,
	size: (self: MangoBuilder, xScale: number, xOffset: number, yScale: number, yOffset: number) -> MangoBuilder,
	parent: (self: MangoBuilder, parent: GuiObject) -> MangoBuilder,
	onClick: (self: MangoBuilder, callback: () -> ()) -> MangoBuilder,
	onChange: (self: MangoBuilder, callback: (value: any) -> ()) -> MangoBuilder,
	prop: (self: MangoBuilder, key: string, value: any) -> MangoBuilder,
	create: (self: MangoBuilder) -> any,
}

-- Protection
export type MangoProtectionConfig = {
	Enabled: boolean?,
}

export type MangoScreenGuiConfig = {
	DisplayOrder: number?,
	IgnoreGuiInset: boolean?,
}

return nil

end

_modules["MangoProtection"] = function()


--[[
	MangoProtection — Anti-detection security module for MangoLiquidUI

	Provides 5 layers of defense:
	1. Hidden parenting (gethui -> CoreGui -> PlayerGui fallback)
	2. Metamethod hooking (filters protected instances from game script calls)
	3. Instance identity obfuscation (randomized names)
	4. Connection protection (newcclosure wrapping)
	5. Property spoofing (protected instances return nil parent to game scripts)

	All executor-specific globals are accessed via pcall for --!strict safety.
	Gracefully falls back to standard Roblox Studio behavior when no executor features are available.
]]

local HttpService = game:GetService("HttpService")

local module = {}

-- Capability detection (runs once on require, all via pcall)
local _gethui: (() -> Instance)? = nil
local _cloneref: ((Instance) -> Instance)? = nil
local _hookmetamethod: ((Instance, string, any) -> any)? = nil
local _newcclosure: ((any) -> any)? = nil
local _checkcaller: (() -> boolean)? = nil
local _getnamecallmethod: (() -> string)? = nil
local _protectgui: ((Instance) -> ())? = nil

-- Detect executor capabilities safely
pcall(function()
	_gethui = (gethui :: any) :: (() -> Instance)
end)
pcall(function()
	_cloneref = (cloneref :: any) :: ((Instance) -> Instance)
end)
pcall(function()
	_hookmetamethod = (hookmetamethod :: any) :: ((Instance, string, any) -> any)
end)
pcall(function()
	_newcclosure = (newcclosure :: any) :: ((any) -> any)
end)
pcall(function()
	_checkcaller = (checkcaller :: any) :: (() -> boolean)
end)
pcall(function()
	_getnamecallmethod = (getnamecallmethod :: any) :: (() -> string)
end)
pcall(function()
	local syn_val = (syn :: any)
	if syn_val and syn_val.protect_gui then
		_protectgui = syn_val.protect_gui :: ((Instance) -> ())
	end
end)

-- Protected instance registry (weak-keyed table)
local protectedInstances: {[Instance]: boolean} = setmetatable({}, {__mode = "k"}) :: any

-- Global state
local protectionEnabled = true
local hooksInstalled = false

-- Determine protection level based on available capabilities
local protectionLevel: string = "none"
if _gethui then
	protectionLevel = "gethui"
elseif _protectgui then
	protectionLevel = "synprotect"
else
	local coreGuiOk = pcall(function()
		local _ = game:GetService("CoreGui")
	end)
	if coreGuiOk then
		protectionLevel = "coregui"
	end
end

-- Cached service references (cloneref'd when available)
local serviceCache: {[string]: Instance} = {}

--[[
	Configure protection globally.
	config.Enabled: boolean? — enable/disable all protection features
]]
function module.configure(config: {Enabled: boolean?})
	if config.Enabled ~= nil then
		protectionEnabled = config.Enabled
	end
end

--[[
	Returns the safest parent container for ScreenGui instances.
	Fallback chain: gethui() -> CoreGui -> PlayerGui
]]
function module.getParent(): Instance
	if protectionEnabled then
		-- Try gethui first (completely hidden from game scripts)
		if _gethui then
			local ok, result = pcall(_gethui :: () -> Instance)
			if ok and result then
				return result
			end
		end

		-- Try CoreGui (less detectable than PlayerGui)
		if protectionLevel == "coregui" or protectionLevel == "synprotect" then
			local ok, coreGui = pcall(function()
				return game:GetService("CoreGui")
			end)
			if ok and coreGui then
				return coreGui
			end
		end
	end

	-- Fallback to PlayerGui (standard Roblox Studio)
	local Players = game:GetService("Players")
	local player = Players.LocalPlayer
	return player:WaitForChild("PlayerGui")
end

--[[
	Apply syn.protect_gui() and register instance in protected set.
]]
function module.protectGui(gui: Instance)
	if not protectionEnabled then return end

	-- Apply syn.protect_gui if available
	if _protectgui then
		pcall(_protectgui :: (Instance) -> (), gui)
	end

	-- Register in protected set
	module.registerInstance(gui)
end

--[[
	Central ScreenGui creation helper. Replaces all duplicated ScreenGui creation blocks.
	Handles hidden parenting, name randomization, protection registration.
]]
function module.createScreenGui(config: {DisplayOrder: number?, IgnoreGuiInset: boolean?}): ScreenGui
	-- Install hooks on first ScreenGui creation
	if not hooksInstalled then
		module.installHooks()
	end

	local gui = Instance.new("ScreenGui")
	gui.Name = module.randomName()
	gui.DisplayOrder = config.DisplayOrder or 100
	gui.IgnoreGuiInset = if config.IgnoreGuiInset ~= nil then config.IgnoreGuiInset else true
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	-- Register for hook protection
	module.registerInstance(gui)

	-- Apply syn.protect_gui if available
	if _protectgui and protectionEnabled then
		pcall(_protectgui :: (Instance) -> (), gui)
	end

	-- Parent to safest container
	gui.Parent = module.getParent()
	return gui
end

--[[
	Register an instance and all its descendants for hook protection.
	Also listens for future descendants.
]]
function module.registerInstance(instance: Instance)
	if not instance then return end
	if not protectionEnabled then return end

	protectedInstances[instance] = true

	-- Protect all existing descendants
	for _, desc in instance:GetDescendants() do
		protectedInstances[desc] = true
	end

	-- Protect future descendants
	instance.DescendantAdded:Connect(function(desc)
		protectedInstances[desc] = true
	end)
end

--[[
	Generate a random non-identifiable name.
	When protection is disabled, returns the prefix or "Instance".
]]
function module.randomName(prefix: string?): string
	if not protectionEnabled then
		return prefix or "Instance"
	end
	local guid = HttpService:GenerateGUID(false)
	return string.sub(guid, 1, 8)
end

--[[
	Generate a random RenderStep binding name.
	When protection is disabled, returns a "Mango"-prefixed name.
]]
function module.randomBindingName(prefix: string?): string
	if not protectionEnabled then
		return (prefix or "MangoBinding") .. "_" .. tostring(math.random(100000, 999999))
	end
	local guid = HttpService:GenerateGUID(false)
	return string.sub(guid, 1, 12)
end

--[[
	Returns a (possibly cloneref'd) service reference.
	Prevents detection via hooked GetService.
]]
function module.safeService(name: string): Instance
	local cached = serviceCache[name]
	if cached then return cached end

	local service = game:GetService(name)
	if _cloneref and protectionEnabled then
		local ok, cloned = pcall(_cloneref :: (Instance) -> Instance, service)
		if ok and cloned then
			serviceCache[name] = cloned
			return cloned
		end
	end

	serviceCache[name] = service
	return service
end

--[[
	Wrap a callback function in newcclosure if available.
	Prevents detection of hooked closures via getconnections().
]]
function module.wrapConnection(fn: any): any
	if _newcclosure and protectionEnabled then
		local ok, wrapped = pcall(_newcclosure :: (any) -> any, fn)
		if ok and wrapped then
			return wrapped
		end
	end
	return fn
end

--[[
	Returns whether protection is currently active.
]]
function module.isProtected(): boolean
	return protectionEnabled and protectionLevel ~= "none"
end

--[[
	Returns the current protection level string.
	"gethui" | "synprotect" | "coregui" | "none"
]]
function module.getProtectionLevel(): string
	if not protectionEnabled then return "none" end
	return protectionLevel
end

--[[
	Install metamethod hooks for active defense.
	Called once automatically on first createScreenGui(), or manually.
	Idempotent — safe to call multiple times.
]]
function module.installHooks()
	if hooksInstalled then return end
	if not _hookmetamethod then return end
	if not _getnamecallmethod then return end
	if not protectionEnabled then return end

	hooksInstalled = true

	local wrap: (any) -> any = (_newcclosure :: any) or function(f: any): any return f end

	-- __namecall hook: intercept GetChildren, GetDescendants, FindFirstChild, etc.
	local oldNamecall: any
	local ok1: boolean
	ok1, oldNamecall = pcall(_hookmetamethod :: (Instance, string, any) -> any, game, "__namecall", wrap(function(self: any, ...: any)
		local method = (_getnamecallmethod :: () -> string)()

		-- Executor code sees everything normally
		if _checkcaller and (_checkcaller :: () -> boolean)() then
			return oldNamecall(self, ...)
		end

		-- Filter results for game scripts
		if method == "GetChildren" or method == "GetDescendants" then
			local results = oldNamecall(self, ...)
			local filtered = {}
			for _, child in results do
				if not protectedInstances[child] then
					table.insert(filtered, child)
				end
			end
			return filtered
		elseif method == "FindFirstChild" or method == "FindFirstChildOfClass"
			or method == "FindFirstChildWhichIsA" then
			local result = oldNamecall(self, ...)
			if result and protectedInstances[result] then
				return nil
			end
			return result
		end

		return oldNamecall(self, ...)
	end))

	if not ok1 then
		hooksInstalled = false
		return
	end

	-- __index hook: intercept .Parent reads on protected instances
	local oldIndex: any
	local ok2: boolean
	ok2, oldIndex = pcall(_hookmetamethod :: (Instance, string, any) -> any, game, "__index", wrap(function(self: any, key: any)
		if _checkcaller and not (_checkcaller :: () -> boolean)() then
			if key == "Parent" and protectedInstances[self] then
				return nil -- game scripts see nil parent
			end
		end
		return oldIndex(self, key)
	end))

	if not ok2 then
		-- Namecall hook succeeded but index hook failed — still partially protected
		return
	end
end

return module

end

_modules["Themes"] = function()


local Types = _require("Types")

local module = {}

--[[
	Resolves a config value with theme fallback and default.
	Needed because Luau's `or` operator treats `0` and `false` as falsy,
	so `config.X or theme.X or default` would skip valid zero/false values.
]]
function module.resolve(configVal: any?, themeVal: any?, default: any): any
	if configVal ~= nil then
		return configVal
	end
	if themeVal ~= nil then
		return themeVal
	end
	return default
end

module.Light = {
	-- Glass surface (Apple-level subtle transparency)
	BackgroundColor3 = Color3.fromRGB(255, 255, 255),
	BackgroundTransparency = 0.85,

	-- Lens (saturation tint via CanvasGroup — lighter for subtlety)
	LensGroupColor3 = Color3.fromRGB(252, 252, 255),
	LensGroupTransparency = 0.62,

	-- Inner glow (thin highlight strip — Apple's 1px inset at 80%)
	InnerGlowColor = Color3.fromRGB(255, 255, 255),
	InnerGlowTransparency = 0.82,
	InnerGlowHeight = 0.12,

	-- Inner edge highlight (barely perceptible boundary)
	InnerEdgeColor = Color3.fromRGB(255, 255, 255),
	InnerEdgeTopTransparency = 0.45,
	InnerEdgeMidTransparency = 0.78,
	InnerEdgeBottomTransparency = 0.94,

	-- Fresnel rim (directional UIStroke) — paper-thin specular
	StrokeColor = Color3.fromRGB(255, 255, 255),
	StrokeThickness = 1.5,
	FresnelStartTransparency = 0.35,
	FresnelEndTransparency = 0.95,
	FresnelMidTransparency = 0.65,
	FresnelMidPoint = 0.40,
	FresnelAngle = 90,

	-- Shadow (Apple-spec: 8px offset, 24px spread)
	ShadowColor = Color3.fromRGB(0, 0, 0),
	ShadowTransparency = 0.80,
	ShadowSpread = 20,
	ShadowOffsetX = 0,
	ShadowOffsetY = 5,

	-- Refraction proxy (per-panel glass distortion — visible refraction, slightly inset)
	GlassColor = Color3.fromRGB(235, 240, 250),
	GlassTransparency = 0.88,
	GlassReflectance = 0.08,

	-- Noise
	NoiseOpacity = 0.03,

	-- Text
	PrimaryTextColor = Color3.fromRGB(0, 0, 0),
	SecondaryTextColor = Color3.fromRGB(60, 60, 70),

	-- Toggle
	ToggleOnTrackColor = Color3.fromRGB(52, 199, 89),
	ToggleOffTrackColor = Color3.fromRGB(200, 200, 200),
	ToggleKnobColor = Color3.fromRGB(255, 255, 255),

	-- Slider
	SliderTrackColor = Color3.fromRGB(210, 212, 218),
	SliderFillColor = Color3.fromRGB(0, 122, 255),
	SliderThumbColor = Color3.fromRGB(255, 255, 255),
	SliderTrackTransparency = 0.40,
	SliderFillTransparency = 0.40,

	-- Button (matches panel subtlety)
	ButtonPressScale = 0.97,
	ButtonBackgroundTransparency = 0.78,

	-- Parallax
	ParallaxIntensity = 0.15,

	-- Notification stacking
	NotificationStackGap = 14,
	NotificationMaxVisible = 3,

	-- Segmented control
	SegmentedBackgroundTransparency = 0.88,
	SegmentedSelectedTransparency = 0.72,
	SegmentedSelectedColor = Color3.fromRGB(255, 255, 255),

	-- Dropdown
	DropdownBackgroundTransparency = 0.82,
	DropdownItemHoverColor = Color3.fromRGB(0, 122, 255),
	DropdownItemHoverTransparency = 0.85,

	-- Tab bar
	TabBarBackgroundTransparency = 0.82,
	TabBarSelectedColor = Color3.fromRGB(0, 122, 255),
	TabBarIconColor = Color3.fromRGB(140, 140, 150),
	TabBarIconSelectedColor = Color3.fromRGB(0, 122, 255),

	-- Search bar
	SearchBarBackgroundTransparency = 0.88,
	SearchBarPlaceholderColor = Color3.fromRGB(142, 142, 147),

	-- Text field
	TextFieldBackgroundTransparency = 0.92,
	TextFieldBorderColor = Color3.fromRGB(200, 200, 205),
	TextFieldFocusBorderColor = Color3.fromRGB(0, 122, 255),

	-- Checkbox
	CheckboxOnColor = Color3.fromRGB(0, 122, 255),
	CheckboxOffColor = Color3.fromRGB(200, 200, 205),
	CheckboxCheckColor = Color3.fromRGB(255, 255, 255),

	-- Progress bar
	ProgressBarTrackTransparency = 0.85,
	ProgressBarFillColor = Color3.fromRGB(0, 122, 255),
	ProgressBarFillTransparency = 0.30,

	-- Dialog
	DialogOverlayTransparency = 0.40,
	DialogBackgroundTransparency = 0.78,

	-- Shimmer
	ShimmerColor = Color3.fromRGB(255, 255, 255),
	ShimmerTransparency = 0.85,

	-- Badge
	BadgeBackgroundColor = Color3.fromRGB(0, 122, 255),
	BadgeBackgroundTransparency = 0.15,
	BadgeTextColor = Color3.fromRGB(255, 255, 255),

	-- Tooltip
	TooltipBackgroundTransparency = 0.15,

	-- Stepper
	StepperBackgroundTransparency = 0.80,

	-- Skeleton
	SkeletonBackgroundColor = Color3.fromRGB(230, 230, 235),
	SkeletonBackgroundTransparency = 0.50,

	-- Toast
	ToastBackgroundTransparency = 0.20,

	-- Bottom Sheet
	BottomSheetBackgroundTransparency = 0.15,
	BottomSheetHandleColor = Color3.fromRGB(200, 200, 205),

	-- Blur Proxy
	BlurTintColor = Color3.fromRGB(255, 255, 255),
	BlurTintTransparency = 0.70,

	-- Form
	FormErrorColor = Color3.fromRGB(255, 59, 48),

	-- Focus Manager
	FocusRingColor = Color3.fromRGB(0, 122, 255),

	-- Window
	WindowBackgroundTransparency = 0.12,
	WindowTitleColor = Color3.fromRGB(0, 0, 0),

	-- Color Picker
	ColorPickerCursorColor = Color3.fromRGB(255, 255, 255),

	-- Keybind
	KeybindPillTransparency = 0.70,
	KeybindListeningColor = Color3.fromRGB(0, 122, 255),

	-- Accent
	AccentColor = Color3.fromRGB(0, 122, 255),
} :: Types.ThemePreset

module.Mango = {
	-- Glass surface (warm amber-tinted glass, Apple-level subtle)
	BackgroundColor3 = Color3.fromRGB(255, 235, 200),
	BackgroundTransparency = 0.84,

	-- Lens (warm saturation tint — lighter)
	LensGroupColor3 = Color3.fromRGB(255, 240, 210),
	LensGroupTransparency = 0.60,

	-- Inner glow (thin highlight strip — Apple's 1px inset at 80%)
	InnerGlowColor = Color3.fromRGB(255, 245, 220),
	InnerGlowTransparency = 0.82,
	InnerGlowHeight = 0.12,

	-- Inner edge highlight (barely perceptible)
	InnerEdgeColor = Color3.fromRGB(255, 250, 235),
	InnerEdgeTopTransparency = 0.42,
	InnerEdgeMidTransparency = 0.76,
	InnerEdgeBottomTransparency = 0.94,

	-- Fresnel rim — paper-thin
	StrokeColor = Color3.fromRGB(255, 245, 220),
	StrokeThickness = 1.5,
	FresnelStartTransparency = 0.32,
	FresnelEndTransparency = 0.94,
	FresnelMidTransparency = 0.62,
	FresnelMidPoint = 0.40,
	FresnelAngle = 90,

	-- Shadow (Apple-spec: deeper, wider)
	ShadowColor = Color3.fromRGB(80, 50, 20),
	ShadowTransparency = 0.80,
	ShadowSpread = 20,
	ShadowOffsetX = 0,
	ShadowOffsetY = 5,

	-- Refraction proxy (per-panel glass distortion — visible refraction, slightly inset)
	GlassColor = Color3.fromRGB(250, 240, 220),
	GlassTransparency = 0.875,
	GlassReflectance = 0.085,

	-- Noise
	NoiseOpacity = 0.03,

	-- Text
	PrimaryTextColor = Color3.fromRGB(60, 35, 10),
	SecondaryTextColor = Color3.fromRGB(120, 80, 40),

	-- Toggle
	ToggleOnTrackColor = Color3.fromRGB(255, 149, 0),
	ToggleOffTrackColor = Color3.fromRGB(210, 195, 175),
	ToggleKnobColor = Color3.fromRGB(255, 255, 255),

	-- Slider
	SliderTrackColor = Color3.fromRGB(230, 210, 185),
	SliderFillColor = Color3.fromRGB(255, 149, 0),
	SliderThumbColor = Color3.fromRGB(255, 255, 255),
	SliderTrackTransparency = 0.45,
	SliderFillTransparency = 0.38,

	-- Button
	ButtonPressScale = 0.97,
	ButtonBackgroundTransparency = 0.76,

	-- Parallax
	ParallaxIntensity = 0.15,

	-- Notification stacking
	NotificationStackGap = 14,
	NotificationMaxVisible = 3,

	-- Segmented control (orange accent)
	SegmentedBackgroundTransparency = 0.87,
	SegmentedSelectedTransparency = 0.70,
	SegmentedSelectedColor = Color3.fromRGB(255, 245, 220),

	-- Dropdown
	DropdownBackgroundTransparency = 0.80,
	DropdownItemHoverColor = Color3.fromRGB(255, 149, 0),
	DropdownItemHoverTransparency = 0.84,

	-- Tab bar
	TabBarBackgroundTransparency = 0.80,
	TabBarSelectedColor = Color3.fromRGB(255, 149, 0),
	TabBarIconColor = Color3.fromRGB(160, 130, 90),
	TabBarIconSelectedColor = Color3.fromRGB(255, 149, 0),

	-- Search bar
	SearchBarBackgroundTransparency = 0.87,
	SearchBarPlaceholderColor = Color3.fromRGB(160, 130, 90),

	-- Text field
	TextFieldBackgroundTransparency = 0.90,
	TextFieldBorderColor = Color3.fromRGB(210, 190, 165),
	TextFieldFocusBorderColor = Color3.fromRGB(255, 149, 0),

	-- Checkbox (orange accent)
	CheckboxOnColor = Color3.fromRGB(255, 149, 0),
	CheckboxOffColor = Color3.fromRGB(210, 195, 175),
	CheckboxCheckColor = Color3.fromRGB(255, 255, 255),

	-- Progress bar
	ProgressBarTrackTransparency = 0.84,
	ProgressBarFillColor = Color3.fromRGB(255, 149, 0),
	ProgressBarFillTransparency = 0.28,

	-- Dialog
	DialogOverlayTransparency = 0.42,
	DialogBackgroundTransparency = 0.76,

	-- Shimmer
	ShimmerColor = Color3.fromRGB(255, 240, 200),
	ShimmerTransparency = 0.85,

	-- Badge
	BadgeBackgroundColor = Color3.fromRGB(255, 149, 0),
	BadgeBackgroundTransparency = 0.15,
	BadgeTextColor = Color3.fromRGB(255, 255, 255),

	-- Tooltip
	TooltipBackgroundTransparency = 0.12,

	-- Stepper
	StepperBackgroundTransparency = 0.78,

	-- Skeleton
	SkeletonBackgroundColor = Color3.fromRGB(235, 220, 195),
	SkeletonBackgroundTransparency = 0.50,

	-- Toast
	ToastBackgroundTransparency = 0.18,

	-- Bottom Sheet
	BottomSheetBackgroundTransparency = 0.14,
	BottomSheetHandleColor = Color3.fromRGB(200, 180, 150),

	-- Blur Proxy
	BlurTintColor = Color3.fromRGB(255, 235, 200),
	BlurTintTransparency = 0.70,

	-- Form
	FormErrorColor = Color3.fromRGB(255, 59, 48),

	-- Focus Manager
	FocusRingColor = Color3.fromRGB(255, 149, 0),

	-- Window
	WindowBackgroundTransparency = 0.14,
	WindowTitleColor = Color3.fromRGB(60, 35, 10),

	-- Color Picker
	ColorPickerCursorColor = Color3.fromRGB(255, 255, 255),

	-- Keybind
	KeybindPillTransparency = 0.68,
	KeybindListeningColor = Color3.fromRGB(255, 149, 0),

	-- Accent
	AccentColor = Color3.fromRGB(255, 149, 0),
} :: Types.ThemePreset

module.Dark = {
	-- Glass surface (rich dark glass — Apple-level subtle)
	BackgroundColor3 = Color3.fromRGB(28, 30, 38),
	BackgroundTransparency = 0.82,

	-- Lens (saturation tint via CanvasGroup — lighter)
	LensGroupColor3 = Color3.fromRGB(190, 200, 220),
	LensGroupTransparency = 0.64,

	-- Inner glow (thin highlight strip — Apple's 1px inset at 80%)
	InnerGlowColor = Color3.fromRGB(255, 255, 255),
	InnerGlowTransparency = 0.82,
	InnerGlowHeight = 0.12,

	-- Inner edge highlight (barely perceptible)
	InnerEdgeColor = Color3.fromRGB(255, 255, 255),
	InnerEdgeTopTransparency = 0.40,
	InnerEdgeMidTransparency = 0.74,
	InnerEdgeBottomTransparency = 0.93,

	-- Fresnel rim (directional UIStroke) — paper-thin specular
	StrokeColor = Color3.fromRGB(255, 255, 255),
	StrokeThickness = 1.5,
	FresnelStartTransparency = 0.30,
	FresnelEndTransparency = 0.93,
	FresnelMidTransparency = 0.58,
	FresnelMidPoint = 0.40,
	FresnelAngle = 90,

	-- Shadow (Apple-spec: deeper, wider)
	ShadowColor = Color3.fromRGB(0, 0, 0),
	ShadowTransparency = 0.75,
	ShadowSpread = 22,
	ShadowOffsetX = 0,
	ShadowOffsetY = 5,

	-- Refraction proxy (per-panel glass distortion — visible refraction, slightly inset)
	GlassColor = Color3.fromRGB(50, 55, 70),
	GlassTransparency = 0.87,
	GlassReflectance = 0.09,

	-- Noise
	NoiseOpacity = 0.03,

	-- Text
	PrimaryTextColor = Color3.fromRGB(255, 255, 255),
	SecondaryTextColor = Color3.fromRGB(170, 170, 185),

	-- Toggle
	ToggleOnTrackColor = Color3.fromRGB(48, 209, 88),
	ToggleOffTrackColor = Color3.fromRGB(80, 80, 85),
	ToggleKnobColor = Color3.fromRGB(255, 255, 255),

	-- Slider
	SliderTrackColor = Color3.fromRGB(55, 55, 65),
	SliderFillColor = Color3.fromRGB(10, 132, 255),
	SliderThumbColor = Color3.fromRGB(255, 255, 255),
	SliderTrackTransparency = 0.38,
	SliderFillTransparency = 0.35,

	-- Button (matches panel subtlety)
	ButtonPressScale = 0.97,
	ButtonBackgroundTransparency = 0.75,

	-- Parallax
	ParallaxIntensity = 0.15,

	-- Notification stacking
	NotificationStackGap = 14,
	NotificationMaxVisible = 3,

	-- Segmented control (blue accent)
	SegmentedBackgroundTransparency = 0.85,
	SegmentedSelectedTransparency = 0.68,
	SegmentedSelectedColor = Color3.fromRGB(50, 55, 70),

	-- Dropdown
	DropdownBackgroundTransparency = 0.78,
	DropdownItemHoverColor = Color3.fromRGB(10, 132, 255),
	DropdownItemHoverTransparency = 0.82,

	-- Tab bar
	TabBarBackgroundTransparency = 0.78,
	TabBarSelectedColor = Color3.fromRGB(10, 132, 255),
	TabBarIconColor = Color3.fromRGB(120, 120, 135),
	TabBarIconSelectedColor = Color3.fromRGB(10, 132, 255),

	-- Search bar
	SearchBarBackgroundTransparency = 0.85,
	SearchBarPlaceholderColor = Color3.fromRGB(120, 120, 135),

	-- Text field
	TextFieldBackgroundTransparency = 0.88,
	TextFieldBorderColor = Color3.fromRGB(70, 70, 80),
	TextFieldFocusBorderColor = Color3.fromRGB(10, 132, 255),

	-- Checkbox (blue accent)
	CheckboxOnColor = Color3.fromRGB(10, 132, 255),
	CheckboxOffColor = Color3.fromRGB(80, 80, 85),
	CheckboxCheckColor = Color3.fromRGB(255, 255, 255),

	-- Progress bar
	ProgressBarTrackTransparency = 0.82,
	ProgressBarFillColor = Color3.fromRGB(10, 132, 255),
	ProgressBarFillTransparency = 0.25,

	-- Dialog
	DialogOverlayTransparency = 0.35,
	DialogBackgroundTransparency = 0.74,

	-- Shimmer
	ShimmerColor = Color3.fromRGB(255, 255, 255),
	ShimmerTransparency = 0.85,

	-- Badge
	BadgeBackgroundColor = Color3.fromRGB(10, 132, 255),
	BadgeBackgroundTransparency = 0.15,
	BadgeTextColor = Color3.fromRGB(255, 255, 255),

	-- Tooltip
	TooltipBackgroundTransparency = 0.15,

	-- Stepper
	StepperBackgroundTransparency = 0.76,

	-- Skeleton
	SkeletonBackgroundColor = Color3.fromRGB(45, 45, 55),
	SkeletonBackgroundTransparency = 0.50,

	-- Toast
	ToastBackgroundTransparency = 0.18,

	-- Bottom Sheet
	BottomSheetBackgroundTransparency = 0.12,
	BottomSheetHandleColor = Color3.fromRGB(80, 80, 90),

	-- Blur Proxy
	BlurTintColor = Color3.fromRGB(28, 30, 38),
	BlurTintTransparency = 0.70,

	-- Form
	FormErrorColor = Color3.fromRGB(255, 59, 48),

	-- Focus Manager
	FocusRingColor = Color3.fromRGB(10, 132, 255),

	-- Window
	WindowBackgroundTransparency = 0.15,
	WindowTitleColor = Color3.fromRGB(255, 255, 255),

	-- Color Picker
	ColorPickerCursorColor = Color3.fromRGB(255, 255, 255),

	-- Keybind
	KeybindPillTransparency = 0.72,
	KeybindListeningColor = Color3.fromRGB(10, 132, 255),

	-- Accent
	AccentColor = Color3.fromRGB(10, 132, 255),
} :: Types.ThemePreset

module.Mint = {
	-- Glass surface (cool mint-tinted glass)
	BackgroundColor3 = Color3.fromRGB(235, 252, 245),
	BackgroundTransparency = 0.86,

	-- Lens (mint saturation tint)
	LensGroupColor3 = Color3.fromRGB(220, 250, 240),
	LensGroupTransparency = 0.62,

	-- Inner glow (thin highlight strip — Apple's 1px inset at 80%)
	InnerGlowColor = Color3.fromRGB(240, 255, 248),
	InnerGlowTransparency = 0.82,
	InnerGlowHeight = 0.12,

	-- Inner edge highlight
	InnerEdgeColor = Color3.fromRGB(240, 255, 248),
	InnerEdgeTopTransparency = 0.44,
	InnerEdgeMidTransparency = 0.77,
	InnerEdgeBottomTransparency = 0.94,

	-- Fresnel rim
	StrokeColor = Color3.fromRGB(240, 255, 248),
	StrokeThickness = 1.5,
	FresnelStartTransparency = 0.34,
	FresnelEndTransparency = 0.95,
	FresnelMidTransparency = 0.64,
	FresnelMidPoint = 0.40,
	FresnelAngle = 90,

	-- Shadow (Apple-spec: deeper, wider)
	ShadowColor = Color3.fromRGB(20, 80, 60),
	ShadowTransparency = 0.82,
	ShadowSpread = 20,
	ShadowOffsetX = 0,
	ShadowOffsetY = 5,

	-- Refraction proxy
	GlassColor = Color3.fromRGB(230, 248, 240),
	GlassTransparency = 0.88,
	GlassReflectance = 0.08,

	-- Noise
	NoiseOpacity = 0.03,

	-- Text
	PrimaryTextColor = Color3.fromRGB(15, 55, 45),
	SecondaryTextColor = Color3.fromRGB(50, 100, 85),

	-- Toggle
	ToggleOnTrackColor = Color3.fromRGB(0, 199, 140),
	ToggleOffTrackColor = Color3.fromRGB(190, 210, 200),
	ToggleKnobColor = Color3.fromRGB(255, 255, 255),

	-- Slider
	SliderTrackColor = Color3.fromRGB(200, 225, 215),
	SliderFillColor = Color3.fromRGB(0, 199, 140),
	SliderThumbColor = Color3.fromRGB(255, 255, 255),
	SliderTrackTransparency = 0.42,
	SliderFillTransparency = 0.38,

	-- Button
	ButtonPressScale = 0.97,
	ButtonBackgroundTransparency = 0.78,

	-- Parallax
	ParallaxIntensity = 0.15,

	-- Notification stacking
	NotificationStackGap = 14,
	NotificationMaxVisible = 3,

	-- Segmented control (mint accent)
	SegmentedBackgroundTransparency = 0.88,
	SegmentedSelectedTransparency = 0.72,
	SegmentedSelectedColor = Color3.fromRGB(240, 255, 248),

	-- Dropdown
	DropdownBackgroundTransparency = 0.82,
	DropdownItemHoverColor = Color3.fromRGB(0, 199, 140),
	DropdownItemHoverTransparency = 0.85,

	-- Tab bar
	TabBarBackgroundTransparency = 0.82,
	TabBarSelectedColor = Color3.fromRGB(0, 199, 140),
	TabBarIconColor = Color3.fromRGB(100, 150, 130),
	TabBarIconSelectedColor = Color3.fromRGB(0, 199, 140),

	-- Search bar
	SearchBarBackgroundTransparency = 0.88,
	SearchBarPlaceholderColor = Color3.fromRGB(100, 150, 130),

	-- Text field
	TextFieldBackgroundTransparency = 0.92,
	TextFieldBorderColor = Color3.fromRGB(190, 215, 205),
	TextFieldFocusBorderColor = Color3.fromRGB(0, 199, 140),

	-- Checkbox (mint accent)
	CheckboxOnColor = Color3.fromRGB(0, 199, 140),
	CheckboxOffColor = Color3.fromRGB(190, 210, 200),
	CheckboxCheckColor = Color3.fromRGB(255, 255, 255),

	-- Progress bar
	ProgressBarTrackTransparency = 0.85,
	ProgressBarFillColor = Color3.fromRGB(0, 199, 140),
	ProgressBarFillTransparency = 0.30,

	-- Dialog
	DialogOverlayTransparency = 0.40,
	DialogBackgroundTransparency = 0.78,

	-- Shimmer
	ShimmerColor = Color3.fromRGB(240, 255, 248),
	ShimmerTransparency = 0.85,

	-- Badge
	BadgeBackgroundColor = Color3.fromRGB(0, 199, 140),
	BadgeBackgroundTransparency = 0.15,
	BadgeTextColor = Color3.fromRGB(255, 255, 255),

	-- Tooltip
	TooltipBackgroundTransparency = 0.15,

	-- Stepper
	StepperBackgroundTransparency = 0.80,

	-- Skeleton
	SkeletonBackgroundColor = Color3.fromRGB(220, 240, 232),
	SkeletonBackgroundTransparency = 0.50,

	-- Toast
	ToastBackgroundTransparency = 0.20,

	-- Bottom Sheet
	BottomSheetBackgroundTransparency = 0.15,
	BottomSheetHandleColor = Color3.fromRGB(180, 210, 200),

	-- Blur Proxy
	BlurTintColor = Color3.fromRGB(235, 252, 245),
	BlurTintTransparency = 0.70,

	-- Form
	FormErrorColor = Color3.fromRGB(255, 59, 48),

	-- Focus Manager
	FocusRingColor = Color3.fromRGB(0, 199, 140),

	-- Window
	WindowBackgroundTransparency = 0.13,
	WindowTitleColor = Color3.fromRGB(15, 55, 45),

	-- Color Picker
	ColorPickerCursorColor = Color3.fromRGB(255, 255, 255),

	-- Keybind
	KeybindPillTransparency = 0.70,
	KeybindListeningColor = Color3.fromRGB(0, 199, 140),

	-- Accent
	AccentColor = Color3.fromRGB(0, 199, 140),
} :: Types.ThemePreset

function module.custom(base: Types.ThemePreset, overrides: {[string]: any}): Types.ThemePreset
	local theme = table.clone(base)
	for key, value in overrides do
		(theme :: any)[key] = value
	end
	return theme
end

return module

end

_modules["LiquidFusion"] = function()


local TweenService = game:GetService("TweenService")

local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local UserInputService = game:GetService("UserInputService")

local module = {}

local function makeSmoothTweenInfo(duration: number): TweenInfo
	return TweenInfo.new(
		duration,
		Enum.EasingStyle.Back,
		Enum.EasingDirection.Out,
		0,
		false,
		0
	)
end

function module.new(config: Types.LiquidFusionConfig): Types.LiquidFusionController
	local target: GuiObject = config.Target
	local bulgeScale: number = resolve(config.BulgeScale, nil, 1.025) :: number
	local bulgeDuration: number = resolve(config.BulgeDuration, nil, 0.25) :: number
	local restoreDuration: number = resolve(config.RestoreDuration, nil, 0.3) :: number
	local specularShiftOffset: UDim2 = resolve(config.SpecularShiftOffset, nil, UDim2.new(0.04, 0, 0.04, 0)) :: UDim2

	local useUIScale: boolean = if config.UseUIScale then true else false

	local connections: { RBXScriptConnection } = {}
	local activeTweens: { Tween } = {}
	local originalSize: UDim2? = nil
	local specularGradient: UIGradient? = nil
	local uiScaleInstance: UIScale? = nil
	local touchHitArea: TextButton? = nil

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	local controller = {} :: Types.LiquidFusionController

	function controller.TweenProperty(self: Types.LiquidFusionController, property: string, targetValue: any, duration: number?): Tween
		local tweenDuration: number = duration or bulgeDuration
		local tweenInfo = makeSmoothTweenInfo(tweenDuration)
		local tween = TweenService:Create(target, tweenInfo, { [property] = targetValue })
		trackTween(tween)
		tween:Play()
		return tween
	end

	function controller.Connect(self: Types.LiquidFusionController)
		-- Disconnect any existing connections first
		controller:Disconnect()

		-- Capture original size at connect time
		originalSize = target.Size

		-- Search for the SpecularStroke's UIGradient for specular rim animation
		-- (Must use named search to avoid picking up InnerHighlight's gradient)
		local specularStroke = target:FindFirstChild("SpecularStroke", true)
		if specularStroke then
			specularGradient = specularStroke:FindFirstChild("SpecularGradient") :: UIGradient?
		end

		-- UIScale mode: create UIScale child and tween Scale instead of Size
		if useUIScale then
			local scale = Instance.new("UIScale")
			scale.Scale = 1
			scale.Parent = target
			uiScaleInstance = scale

			local enterConnection = target.MouseEnter:Connect(function()
				cancelAllTweens()
				local tweenInfo = makeSmoothTweenInfo(bulgeDuration)
				local scaleTween = TweenService:Create(scale, tweenInfo, { Scale = bulgeScale })
				trackTween(scaleTween)
				scaleTween:Play()
				local gradient = specularGradient
				if gradient then
					local gradientTween = TweenService:Create(gradient, tweenInfo, {
						Offset = Vector2.new(specularShiftOffset.X.Scale, specularShiftOffset.Y.Scale),
					})
					trackTween(gradientTween)
					gradientTween:Play()
				end
			end)

			local leaveConnection = target.MouseLeave:Connect(function()
				cancelAllTweens()
				local tweenInfo = makeSmoothTweenInfo(restoreDuration)
				local scaleTween = TweenService:Create(scale, tweenInfo, { Scale = 1 })
				trackTween(scaleTween)
				scaleTween:Play()
				local gradient = specularGradient
				if gradient then
					local gradientTween = TweenService:Create(gradient, tweenInfo, {
						Offset = Vector2.new(0, 0),
					})
					trackTween(gradientTween)
					gradientTween:Play()
				end
			end)

			table.insert(connections, enterConnection)
			table.insert(connections, leaveConnection)

			if UserInputService.TouchEnabled then
				-- Create transparent TextButton for reliable touch input on transparent targets
				local hitBtn = Instance.new("TextButton")
				hitBtn.Name = "FusionTouchHitArea"
				hitBtn.Size = UDim2.new(1, 0, 1, 0)
				hitBtn.BackgroundTransparency = 1
				hitBtn.BorderSizePixel = 0
				hitBtn.Text = ""
				hitBtn.AutoButtonColor = false
				hitBtn.ZIndex = 99
				hitBtn.Parent = target
				touchHitArea = hitBtn

				local touchBeginConn = hitBtn.InputBegan:Connect(function(input: InputObject)
					if input.UserInputType == Enum.UserInputType.Touch then
						cancelAllTweens()
						local tweenInfo = makeSmoothTweenInfo(bulgeDuration)
						local scaleTween = TweenService:Create(scale, tweenInfo, { Scale = bulgeScale })
						trackTween(scaleTween)
						scaleTween:Play()
						local gradient = specularGradient
						if gradient then
							local gradTween = TweenService:Create(gradient, tweenInfo, {
								Offset = Vector2.new(specularShiftOffset.X.Scale, specularShiftOffset.Y.Scale),
							})
							trackTween(gradTween)
							gradTween:Play()
						end
					end
				end)
				local touchEndConn = hitBtn.InputEnded:Connect(function(input: InputObject)
					if input.UserInputType == Enum.UserInputType.Touch then
						cancelAllTweens()
						local tweenInfo = makeSmoothTweenInfo(restoreDuration)
						local scaleTween = TweenService:Create(scale, tweenInfo, { Scale = 1 })
						trackTween(scaleTween)
						scaleTween:Play()
						local gradient = specularGradient
						if gradient then
							local gradTween = TweenService:Create(gradient, tweenInfo, {
								Offset = Vector2.new(0, 0),
							})
							trackTween(gradTween)
							gradTween:Play()
						end
					end
				end)
				table.insert(connections, touchBeginConn)
				table.insert(connections, touchEndConn)
			end
		else
			-- Default Size-based mode
			local origSize: UDim2 = originalSize :: UDim2
			local bulgeSize = UDim2.new(
				origSize.X.Scale * bulgeScale,
				math.floor(origSize.X.Offset * bulgeScale),
				origSize.Y.Scale * bulgeScale,
				math.floor(origSize.Y.Offset * bulgeScale)
			)

			local enterConnection = target.MouseEnter:Connect(function()
				cancelAllTweens()
				local tweenInfo = makeSmoothTweenInfo(bulgeDuration)
				local sizeTween = TweenService:Create(target, tweenInfo, { Size = bulgeSize })
				trackTween(sizeTween)
				sizeTween:Play()
				local gradient = specularGradient
				if gradient then
					local gradientTween = TweenService:Create(gradient, tweenInfo, {
						Offset = Vector2.new(specularShiftOffset.X.Scale, specularShiftOffset.Y.Scale),
					})
					trackTween(gradientTween)
					gradientTween:Play()
				end
			end)

			local leaveConnection = target.MouseLeave:Connect(function()
				cancelAllTweens()
				local tweenInfo = makeSmoothTweenInfo(restoreDuration)
				local sizeTween = TweenService:Create(target, tweenInfo, { Size = origSize })
				trackTween(sizeTween)
				sizeTween:Play()
				local gradient = specularGradient
				if gradient then
					local gradientTween = TweenService:Create(gradient, tweenInfo, {
						Offset = Vector2.new(0, 0),
					})
					trackTween(gradientTween)
					gradientTween:Play()
				end
			end)

			table.insert(connections, enterConnection)
			table.insert(connections, leaveConnection)

			if UserInputService.TouchEnabled then
				-- Create transparent TextButton for reliable touch input on transparent targets
				local hitBtn = Instance.new("TextButton")
				hitBtn.Name = "FusionTouchHitArea"
				hitBtn.Size = UDim2.new(1, 0, 1, 0)
				hitBtn.BackgroundTransparency = 1
				hitBtn.BorderSizePixel = 0
				hitBtn.Text = ""
				hitBtn.AutoButtonColor = false
				hitBtn.ZIndex = 99
				hitBtn.Parent = target
				touchHitArea = hitBtn

				local touchBeginConn = hitBtn.InputBegan:Connect(function(input: InputObject)
					if input.UserInputType == Enum.UserInputType.Touch then
						cancelAllTweens()
						local tweenInfo = makeSmoothTweenInfo(bulgeDuration)
						local sizeTween = TweenService:Create(target, tweenInfo, { Size = bulgeSize })
						trackTween(sizeTween)
						sizeTween:Play()
						local gradient = specularGradient
						if gradient then
							local gradTween = TweenService:Create(gradient, tweenInfo, {
								Offset = Vector2.new(specularShiftOffset.X.Scale, specularShiftOffset.Y.Scale),
							})
							trackTween(gradTween)
							gradTween:Play()
						end
					end
				end)
				local touchEndConn = hitBtn.InputEnded:Connect(function(input: InputObject)
					if input.UserInputType == Enum.UserInputType.Touch then
						cancelAllTweens()
						local tweenInfo = makeSmoothTweenInfo(restoreDuration)
						local sizeTween = TweenService:Create(target, tweenInfo, { Size = origSize })
						trackTween(sizeTween)
						sizeTween:Play()
						local gradient = specularGradient
						if gradient then
							local gradTween = TweenService:Create(gradient, tweenInfo, {
								Offset = Vector2.new(0, 0),
							})
							trackTween(gradTween)
							gradTween:Play()
						end
					end
				end)
				table.insert(connections, touchBeginConn)
				table.insert(connections, touchEndConn)
			end
		end
	end

	function controller.Disconnect(self: Types.LiquidFusionController)
		for _, connection in connections do
			connection:Disconnect()
		end
		table.clear(connections)
		cancelAllTweens()
	end

	function controller.Destroy(self: Types.LiquidFusionController)
		controller:Disconnect()
		originalSize = nil
		specularGradient = nil
		if uiScaleInstance then
			uiScaleInstance:Destroy()
			uiScaleInstance = nil
		end
		if touchHitArea then
			touchHitArea:Destroy()
			touchHitArea = nil
		end
	end

	return controller
end

return module

end

_modules["RefractionProxy"] = function()


local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")

local module = {}
local proxyDepthCounter = 0
local DEPTH_STEP = 0.003

function module.resetDepthCounter()
	proxyDepthCounter = 0
end

function module.new(config: Types.RefractionProxyConfig): Types.RefractionProxy
	local theme = config.Theme

	local targetGui: GuiObject = config.TargetGui
	local glassTransparency: number = resolve(config.GlassTransparency, theme and theme.GlassTransparency, 0.91)
	local glassMaterial: Enum.Material = resolve(config.GlassMaterial, nil, Enum.Material.Glass)
	local glassColor: Color3 = resolve(config.GlassColor, theme and theme.GlassColor, Color3.fromRGB(235, 240, 250))
	local glassReflectance: number = resolve(config.GlassReflectance, theme and theme.GlassReflectance, 0.04)
	local offsetDepth: number = resolve(config.OffsetDepth, nil, 1.5)
	local glassThickness: number = resolve(config.GlassThickness, nil, 0.05)
	local enabled: boolean = resolve(config.Enabled, nil, true)
	local viewportMode: boolean = resolve(config.ViewportMode, nil, false)

	proxyDepthCounter += 1
	local adjustedDepth: number = offsetDepth + (proxyDepthCounter * DEPTH_STEP)

	local bindingName: string = MangoProtection.randomBindingName("MangoRefraction")

	-- Create the Glass Part
	local glassPart = Instance.new("Part")
	glassPart.Name = MangoProtection.randomName("RefractionProxy")
	glassPart.Material = glassMaterial
	glassPart.Transparency = glassTransparency
	glassPart.Color = glassColor
	glassPart.Reflectance = glassReflectance
	glassPart.CanCollide = false
	glassPart.CanQuery = false
	glassPart.CanTouch = false
	glassPart.Anchored = true
	glassPart.CastShadow = false
	glassPart.TopSurface = Enum.SurfaceType.Smooth
	glassPart.BottomSurface = Enum.SurfaceType.Smooth
	local Workspace = game:GetService("Workspace")
	local camera = Workspace.CurrentCamera or Workspace:WaitForChild("CurrentCamera")
	glassPart.Parent = camera
	MangoProtection.registerInstance(glassPart)

	local function updatePartTransform()
		local camera = game:GetService("Workspace").CurrentCamera
		if not camera then
			return
		end

		local viewportSize: Vector2 = camera.ViewportSize
		if viewportSize.X == 0 or viewportSize.Y == 0 then
			return
		end

		local cameraCF: CFrame = camera.CFrame

		if viewportMode then
			-- Full viewport coverage — single Glass Part covers entire screen
			local fov: number = math.rad(camera.FieldOfView)
			local worldHeight: number = 2 * adjustedDepth * math.tan(fov * 0.5)
			local aspectRatio: number = viewportSize.X / viewportSize.Y
			local worldWidth: number = worldHeight * aspectRatio
			glassPart.Size = Vector3.new(worldWidth, worldHeight, glassThickness)
			glassPart.CFrame = cameraCF * CFrame.new(0, 0, -adjustedDepth)
		else
			-- Per-GUI tracking mode using ScreenPointToRay for robust coordinate mapping.
			-- This avoids all GUI inset ambiguity: AbsolutePosition with IgnoreGuiInset=true
			-- is in full-screen coords, matching ScreenPointToRay's coordinate system.
			local absSize: Vector2 = targetGui.AbsoluteSize
			local absPos: Vector2 = targetGui.AbsolutePosition

			local centerVpX: number = absPos.X + absSize.X * 0.5
			local centerVpY: number = absPos.Y + absSize.Y * 0.5

			local centerRay: Ray = camera:ScreenPointToRay(centerVpX, centerVpY, 0)
			local camForward: Vector3 = cameraCF.LookVector
			local t: number = adjustedDepth / camForward:Dot(centerRay.Direction)
			local worldCenter: Vector3 = cameraCF.Position + centerRay.Direction * t

			local topLeftRay: Ray = camera:ScreenPointToRay(absPos.X, absPos.Y, 0)
			local bottomRightRay: Ray = camera:ScreenPointToRay(absPos.X + absSize.X, absPos.Y + absSize.Y, 0)
			local tTL: number = adjustedDepth / camForward:Dot(topLeftRay.Direction)
			local tBR: number = adjustedDepth / camForward:Dot(bottomRightRay.Direction)
			local worldTL: Vector3 = cameraCF.Position + topLeftRay.Direction * tTL
			local worldBR: Vector3 = cameraCF.Position + bottomRightRay.Direction * tBR

			local localTL: Vector3 = cameraCF:PointToObjectSpace(worldTL)
			local localBR: Vector3 = cameraCF:PointToObjectSpace(worldBR)
			local partWidth: number = math.abs(localBR.X - localTL.X)
			local partHeight: number = math.abs(localBR.Y - localTL.Y)

			-- Inset glass Part slightly so rectangular edges hide behind rounded UI corners
			glassPart.Size = Vector3.new(partWidth * 0.97, partHeight * 0.95, glassThickness)
			glassPart.CFrame = CFrame.new(worldCenter, worldCenter + cameraCF.LookVector)
		end
	end

	local function bindRenderStep()
		RunService:BindToRenderStep(
			bindingName,
			Enum.RenderPriority.Camera.Value + 1,
			updatePartTransform
		)
	end

	local function unbindRenderStep()
		RunService:UnbindFromRenderStep(bindingName)
	end

	-- Start tracking if enabled
	if enabled then
		bindRenderStep()
	else
		glassPart.Transparency = 1
	end

	local proxy = {} :: Types.RefractionProxy
	proxy.GlassPart = glassPart
	proxy.Enabled = enabled

	function proxy.SetEnabled(self: Types.RefractionProxy, newEnabled: boolean)
		if self.Enabled == newEnabled then
			return
		end
		self.Enabled = newEnabled
		if newEnabled then
			glassPart.Transparency = glassTransparency
			bindRenderStep()
		else
			unbindRenderStep()
			glassPart.Transparency = 1
		end
	end

	function proxy.UpdateTarget(self: Types.RefractionProxy, newGui: GuiObject)
		targetGui = newGui
	end

	function proxy.Destroy(self: Types.RefractionProxy)
		self.Enabled = false
		pcall(unbindRenderStep)
		glassPart:Destroy()
		self.GlassPart = nil :: any
	end

	return proxy
end

return module

end

_modules["MangoGlassFrame"] = function()


local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")

local module = {}

function module.new(config: Types.MangoGlassConfig): Types.MangoGlassFrame
	local theme = config.Theme

	-- Resolve all config values with nil-safe helper
	local size = resolve(config.Size, nil, UDim2.new(0, 200, 0, 100)) :: UDim2
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local cornerRadius = resolve(config.CornerRadius, nil, UDim.new(0, 16)) :: UDim
	local backgroundColor = resolve(config.BackgroundColor3, theme and theme.BackgroundColor3, Color3.fromRGB(255, 255, 255)) :: Color3
	local backgroundTransparency = resolve(config.BackgroundTransparency, theme and theme.BackgroundTransparency, 0.72) :: number
	local noiseImageId = resolve(config.NoiseImageId, nil, "rbxassetid://4531766211") :: string
	local noiseOpacity = resolve(config.NoiseOpacity, theme and theme.NoiseOpacity, 0.03) :: number
	local lensGroupColor3 = resolve(config.LensGroupColor3, theme and theme.LensGroupColor3, Color3.fromRGB(255, 254, 252)) :: Color3
	local lensGroupTransparency = resolve(config.LensGroupTransparency, theme and theme.LensGroupTransparency, 0.65) :: number
	local innerGlowColor = resolve(config.InnerGlowColor, theme and theme.InnerGlowColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local innerGlowTransparency = resolve(config.InnerGlowTransparency, theme and theme.InnerGlowTransparency, 0.55) :: number
	local innerGlowHeight = resolve(config.InnerGlowHeight, theme and theme.InnerGlowHeight, 0.30) :: number
	local strokeColor = resolve(config.StrokeColor, theme and theme.StrokeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local strokeThickness = resolve(config.StrokeThickness, theme and theme.StrokeThickness, 1) :: number
	local fresnelStart = resolve(config.FresnelStartTransparency, theme and theme.FresnelStartTransparency, 0.25) :: number
	local fresnelEnd = resolve(config.FresnelEndTransparency, theme and theme.FresnelEndTransparency, 0.95) :: number
	local fresnelMid = resolve(config.FresnelMidTransparency, theme and theme.FresnelMidTransparency, 0.50) :: number
	local fresnelMidPoint = resolve(config.FresnelMidPoint, theme and theme.FresnelMidPoint, 0.35) :: number
	local fresnelAngle = resolve(config.FresnelAngle, theme and theme.FresnelAngle, 90) :: number
	local shadowColor = resolve(config.ShadowColor, theme and theme.ShadowColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local shadowTransparency = resolve(config.ShadowTransparency, theme and theme.ShadowTransparency, 0.68) :: number
	local shadowSpread = resolve(config.ShadowSpread, theme and theme.ShadowSpread, 8) :: number
	local shadowOffsetY = resolve(config.ShadowOffsetY, theme and theme.ShadowOffsetY, 2) :: number
	local shadowOffsetX = resolve(config.ShadowOffsetX, theme and theme.ShadowOffsetX, 0) :: number
	local shadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean
	local shadowLayerCount = resolve(config.ShadowLayerCount, nil, 5) :: number
	local lightweightMode = resolve(config.LightweightMode, nil, false) :: boolean
	local parallaxEnabled = resolve(config.ParallaxEnabled, nil, false) :: boolean
	local parallaxIntensity = resolve(config.ParallaxIntensity, theme and theme.ParallaxIntensity, 0.15) :: number

	-- Container (transparent wrapper, NO ClipsDescendants, NO UICorner)
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("GlassFrame")
	container.Size = size
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	-- N-layer graduated shadow (quadratic falloff eliminates banding)
	local layerCount = math.clamp(shadowLayerCount, 1, 12)
	local shadowLayers: {Frame} = {}

	-- Loop REVERSED: outermost added first (bottom), innermost added last (top, darkest)
	for i = layerCount, 1, -1 do
		local t = i / layerCount
		local spread = math.ceil(shadowSpread * t)
		local layerAlpha = (1 - shadowTransparency)
			* ((layerCount - i + 1) / layerCount) ^ 2
			/ (layerCount / 3)
		local layerTransparency = math.clamp(1 - layerAlpha, 0, 1)
		local cornerRadiusOffset = math.ceil(8 * t)

		local shadowLayer = Instance.new("Frame")
		shadowLayer.Name = "ShadowLayer" .. i
		shadowLayer.AnchorPoint = Vector2.new(0.5, 0.5)
		shadowLayer.Position = UDim2.new(0.5, shadowOffsetX, 0.5, shadowOffsetY)
		shadowLayer.Size = UDim2.new(1, spread * 2, 1, spread * 2)
		shadowLayer.BackgroundColor3 = shadowColor
		shadowLayer.BackgroundTransparency = layerTransparency
		shadowLayer.BorderSizePixel = 0
		shadowLayer.ZIndex = 0
		shadowLayer.Visible = shadowEnabled
		shadowLayer.Parent = container

		local layerCorner = Instance.new("UICorner")
		layerCorner.CornerRadius = UDim.new(0, cornerRadius.Offset + cornerRadiusOffset)
		layerCorner.Parent = shadowLayer

		table.insert(shadowLayers, shadowLayer)
	end

	-- GlassSurface (clipping inner frame)
	local glassSurface = Instance.new("Frame")
	glassSurface.Name = "GlassSurface"
	glassSurface.Size = UDim2.new(1, 0, 1, 0)
	glassSurface.BackgroundColor3 = backgroundColor
	glassSurface.BackgroundTransparency = backgroundTransparency
	glassSurface.ClipsDescendants = true
	glassSurface.BorderSizePixel = 0
	glassSurface.ZIndex = 1
	glassSurface.Parent = container

	local glassSurfaceCorner = Instance.new("UICorner")
	glassSurfaceCorner.CornerRadius = cornerRadius
	glassSurfaceCorner.Parent = glassSurface

	local surfaceGradient = Instance.new("UIGradient")
	surfaceGradient.Name = "SurfaceGradient"
	surfaceGradient.Rotation = 135 -- Apple's diagonal gradient (top-left to bottom-right)
	surfaceGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(230, 230, 235)),
	})
	surfaceGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.92),
		NumberSequenceKeypoint.new(1, 0.96),
	})
	surfaceGradient.Parent = glassSurface

	local lensGroup: CanvasGroup? = nil
	local textureGroup: CanvasGroup? = nil
	local noiseTile: ImageLabel? = nil
	local innerHighlight: Frame? = nil

	if not lightweightMode then
		-- LensGroup (saturation tint via CanvasGroup)
		local lg = Instance.new("CanvasGroup")
		lg.Name = "LensGroup"
		lg.Size = UDim2.new(1, 0, 1, 0)
		lg.GroupColor3 = lensGroupColor3
		lg.GroupTransparency = lensGroupTransparency
		lg.BackgroundTransparency = 1
		lg.BorderSizePixel = 0
		lg.Parent = glassSurface

		local lensCorner = Instance.new("UICorner")
		lensCorner.CornerRadius = cornerRadius
		lensCorner.Parent = lg

		-- TextureGroup (noise dithering layer)
		local tg = Instance.new("CanvasGroup")
		tg.Name = "TextureGroup"
		tg.Size = UDim2.new(1, 0, 1, 0)
		tg.BackgroundTransparency = 1
		tg.BorderSizePixel = 0
		tg.Parent = lg

		local textureCorner = Instance.new("UICorner")
		textureCorner.CornerRadius = cornerRadius
		textureCorner.Parent = tg

		-- NoiseTile (Perlin noise overlay)
		local nt = Instance.new("ImageLabel")
		nt.Name = "NoiseTile"
		nt.Image = noiseImageId
		nt.ImageTransparency = 1 - noiseOpacity
		nt.ScaleType = Enum.ScaleType.Tile
		nt.TileSize = UDim2.new(0.125, 0, 0.125, 0)
		nt.Size = UDim2.new(1, 0, 1, 0)
		nt.BackgroundTransparency = 1
		nt.BorderSizePixel = 0
		nt.Parent = tg

		local noiseCorner = Instance.new("UICorner")
		noiseCorner.CornerRadius = cornerRadius
		noiseCorner.Parent = nt

		-- InnerHighlight (subtle top-edge glow)
		local ih = Instance.new("Frame")
		ih.Name = "InnerHighlight"
		ih.Size = UDim2.new(1, 0, innerGlowHeight, 0)
		ih.Position = UDim2.new(0, 0, 0, 0)
		ih.BackgroundColor3 = innerGlowColor
		ih.BackgroundTransparency = innerGlowTransparency
		ih.BorderSizePixel = 0
		ih.ZIndex = 2
		ih.Parent = tg

		local highlightCorner = Instance.new("UICorner")
		highlightCorner.CornerRadius = cornerRadius
		highlightCorner.Parent = ih

		local highlightGradient = Instance.new("UIGradient")
		highlightGradient.Name = "HighlightGradient"
		highlightGradient.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0),
			NumberSequenceKeypoint.new(1, 1),
		})
		highlightGradient.Rotation = 90
		highlightGradient.Parent = ih

		lensGroup = lg
		textureGroup = tg
		noiseTile = nt
		innerHighlight = ih
	end

	-- Inner edge highlight (full-perimeter inner shadow inside GlassSurface)
	local innerEdgeColor = resolve(config.InnerEdgeColor, theme and theme.InnerEdgeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local innerEdgeTop = resolve(config.InnerEdgeTopTransparency, theme and theme.InnerEdgeTopTransparency, 0.30) :: number
	local innerEdgeMid = resolve(config.InnerEdgeMidTransparency, theme and theme.InnerEdgeMidTransparency, 0.68) :: number
	local innerEdgeBottom = resolve(config.InnerEdgeBottomTransparency, theme and theme.InnerEdgeBottomTransparency, 0.90) :: number

	local innerEdgeFrame = Instance.new("Frame")
	innerEdgeFrame.Name = "InnerEdgeFrame"
	innerEdgeFrame.Size = UDim2.new(1, 0, 1, 0)
	innerEdgeFrame.BackgroundTransparency = 1
	innerEdgeFrame.BorderSizePixel = 0
	innerEdgeFrame.ZIndex = 3
	innerEdgeFrame.Parent = glassSurface

	local innerEdgeCorner = Instance.new("UICorner")
	innerEdgeCorner.CornerRadius = cornerRadius
	innerEdgeCorner.Parent = innerEdgeFrame

	local innerEdgeStroke = Instance.new("UIStroke")
	innerEdgeStroke.Name = "InnerEdgeStroke"
	innerEdgeStroke.Color = innerEdgeColor
	innerEdgeStroke.Thickness = 1
	innerEdgeStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	innerEdgeStroke.Parent = innerEdgeFrame

	local innerEdgeGradient = Instance.new("UIGradient")
	innerEdgeGradient.Name = "InnerEdgeGradient"
	innerEdgeGradient.Rotation = 90
	innerEdgeGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, innerEdgeTop),
		NumberSequenceKeypoint.new(0.5, innerEdgeMid),
		NumberSequenceKeypoint.new(1, innerEdgeBottom),
	})
	innerEdgeGradient.Parent = innerEdgeStroke

	-- SpecularFrame (CHILD OF CONTAINER, outside clip boundary)
	local specularFrame = Instance.new("Frame")
	specularFrame.Name = "SpecularFrame"
	specularFrame.Size = UDim2.new(1, 0, 1, 0)
	specularFrame.BackgroundTransparency = 1
	specularFrame.BorderSizePixel = 0
	specularFrame.ZIndex = 2
	specularFrame.Parent = container

	local specularCorner = Instance.new("UICorner")
	specularCorner.CornerRadius = cornerRadius
	specularCorner.Parent = specularFrame

	-- UIStroke (directional Fresnel rim)
	local specularStroke = Instance.new("UIStroke")
	specularStroke.Name = "SpecularStroke"
	specularStroke.Color = strokeColor
	specularStroke.Thickness = strokeThickness
	specularStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	specularStroke.Parent = specularFrame

	-- UIGradient (directional top-lit transparency)
	local specularGradient = Instance.new("UIGradient")
	specularGradient.Name = "SpecularGradient"
	specularGradient.Rotation = fresnelAngle
	specularGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, fresnelStart),
		NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})
	specularGradient.Parent = specularStroke

	-- Parent assignment
	if config.Parent then
		container.Parent = config.Parent
	end
	MangoProtection.registerInstance(container)

	-- Parallax system
	local Workspace = game:GetService("Workspace")
	local parallaxBindingName = MangoProtection.randomBindingName("MangoParallax")
	local parallaxBound = false

	local function startParallax()
		if parallaxBound then
			return
		end
		parallaxBound = true
		RunService:BindToRenderStep(parallaxBindingName, Enum.RenderPriority.Camera.Value + 1, function()
			local camera = Workspace.CurrentCamera
			if not camera then
				return
			end
			local mousePos = UserInputService:GetMouseLocation()
			local viewportSize = camera.ViewportSize
			if viewportSize.X == 0 or viewportSize.Y == 0 then
				return
			end
			local nx = (mousePos.X / viewportSize.X - 0.5) * 2
			local ny = (mousePos.Y / viewportSize.Y - 0.5) * 2
			local intensity = parallaxIntensity

			specularGradient.Offset = Vector2.new(nx * 0.03 * intensity, ny * 0.03 * intensity)
			innerEdgeGradient.Offset = Vector2.new(nx * 0.02 * intensity, ny * 0.02 * intensity)

			if not lightweightMode and innerHighlight then
				local highlightGrad = (innerHighlight :: Frame):FindFirstChild("HighlightGradient")
				if highlightGrad and highlightGrad:IsA("UIGradient") then
					(highlightGrad :: UIGradient).Offset = Vector2.new(nx * 0.01 * intensity, ny * 0.005 * intensity)
				end
			end
		end)
	end

	local function stopParallax()
		if not parallaxBound then
			return
		end
		parallaxBound = false
		pcall(function()
			RunService:UnbindFromRenderStep(parallaxBindingName)
		end)
	end

	if parallaxEnabled then
		startParallax()
	end

	local self: Types.MangoGlassFrame = {
		Container = container,
		Frame = container,
		GlassSurface = glassSurface,
		ShadowLayers = shadowLayers,
		LensGroup = lensGroup,
		TextureGroup = textureGroup,
		NoiseLabel = noiseTile,
		InnerHighlight = innerHighlight,
		InnerEdgeFrame = innerEdgeFrame,
		InnerEdgeStroke = innerEdgeStroke,
		InnerEdgeGradient = innerEdgeGradient,
		SpecularFrame = specularFrame,
		SpecularStroke = specularStroke,
		SpecularGradient = specularGradient,
		SetLightDirection = function(self: Types.MangoGlassFrame, angle: number)
			self.SpecularGradient.Rotation = angle
			self.InnerEdgeGradient.Rotation = angle
			local highlight = self.InnerHighlight
			if highlight then
				local highlightGrad = highlight:FindFirstChild("HighlightGradient")
				if highlightGrad and highlightGrad:IsA("UIGradient") then
					(highlightGrad :: UIGradient).Rotation = angle
				end
			end
		end,
		SetParallaxEnabled = function(self: Types.MangoGlassFrame, newEnabled: boolean)
			parallaxEnabled = newEnabled
			if newEnabled then
				startParallax()
			else
				stopParallax()
			end
		end,
		Destroy = function(self: Types.MangoGlassFrame)
			stopParallax()
			self.Container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoShimmer"] = function()


local TweenService = game:GetService("TweenService")

local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")

local module = {}

function module.new(config: Types.MangoShimmerConfig): Types.MangoShimmer
	local theme = config.Theme or Themes.Light

	local shimmerColor: Color3 = resolve(config.ShimmerColor, theme.ShimmerColor, Color3.fromRGB(255, 255, 255))
	local shimmerTransparency: number = resolve(config.ShimmerTransparency, theme.ShimmerTransparency, 0.85)
	local shimmerWidth: number = resolve(config.ShimmerWidth, nil, 0.08)
	local duration: number = resolve(config.Duration, nil, 1.2)

	local enabled = false
	local isDestroyed = false
	local activeTween: Tween? = nil

	-- Create overlay Frame
	local overlay = Instance.new("Frame")
	overlay.Name = "ShimmerOverlay"
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.BackgroundColor3 = shimmerColor
	overlay.BackgroundTransparency = shimmerTransparency
	overlay.BorderSizePixel = 0
	overlay.ZIndex = 50
	overlay.Visible = false

	-- Match Target's UICorner if present
	local targetCorner = config.Target:FindFirstChildWhichIsA("UICorner")
	if targetCorner then
		local corner = Instance.new("UICorner")
		corner.CornerRadius = targetCorner.CornerRadius
		corner.Parent = overlay
	end

	-- Create narrow-band shimmer gradient
	local gradient = Instance.new("UIGradient")
	gradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 1),
		NumberSequenceKeypoint.new(0.5 - shimmerWidth / 2, 1),
		NumberSequenceKeypoint.new(0.5, 0),
		NumberSequenceKeypoint.new(0.5 + shimmerWidth / 2, 1),
		NumberSequenceKeypoint.new(1, 1),
	})
	gradient.Offset = Vector2.new(-0.5, 0)
	gradient.Parent = overlay

	overlay.Parent = config.Target

	-- Shimmer controller
	local self = {} :: Types.MangoShimmer

	function self:Enable()
		if isDestroyed or enabled then
			return
		end
		enabled = true
		overlay.Visible = true
		gradient.Offset = Vector2.new(-0.5, 0)

		local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, false, 0)
		activeTween = TweenService:Create(gradient, tweenInfo, { Offset = Vector2.new(0.5, 0) })
		activeTween:Play()
	end

	function self:Disable()
		if isDestroyed or not enabled then
			return
		end
		enabled = false
		if activeTween then
			activeTween:Cancel()
			activeTween = nil
		end
		overlay.Visible = false
		gradient.Offset = Vector2.new(-0.5, 0)
	end

	function self:IsEnabled(): boolean
		return enabled
	end

	function self:Destroy()
		if isDestroyed then
			return
		end
		isDestroyed = true
		if activeTween then
			activeTween:Cancel()
			activeTween = nil
		end
		overlay:Destroy()
	end

	-- Auto-enable unless explicitly disabled
	if config.Enabled ~= false then
		self:Enable()
	end

	return self
end

return module

end

_modules["MangoHaptics"] = function()


local HapticService = game:GetService("HapticService")

local module = {}

local enabled: boolean = false

function module.setEnabled(value: boolean)
	enabled = value
end

function module.isEnabled(): boolean
	return enabled
end

function module.trigger(intensity: number?)
	if not enabled then return end
	local motor = Enum.VibrationMotor.Large
	local power = intensity or 0.5
	pcall(function()
		HapticService:SetMotor(Enum.UserInputType.Gamepad1, motor, power)
	end)
	task.delay(0.05, function()
		pcall(function()
			HapticService:SetMotor(Enum.UserInputType.Gamepad1, motor, 0)
		end)
	end)
end

function module.light()
	module.trigger(0.2)
end

function module.medium()
	module.trigger(0.5)
end

function module.heavy()
	module.trigger(0.8)
end

return module

end

_modules["MangoLayout"] = function()


local Types = _require("Types")
local MangoProtection = _require("MangoProtection")

local module = {}

function module.new(config: Types.MangoLayoutConfig): Types.MangoLayout
	local padding = config.Padding or 8

	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Layout")
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.AutomaticSize = Enum.AutomaticSize.XY
	container.Size = UDim2.new(0, 0, 0, 0)

	-- UIPadding
	local uiPadding = Instance.new("UIPadding")
	uiPadding.PaddingTop = UDim.new(0, config.PaddingTop or 0)
	uiPadding.PaddingBottom = UDim.new(0, config.PaddingBottom or 0)
	uiPadding.PaddingLeft = UDim.new(0, config.PaddingLeft or 0)
	uiPadding.PaddingRight = UDim.new(0, config.PaddingRight or 0)
	uiPadding.Parent = container

	if config.Mode == "grid" then
		local grid = Instance.new("UIGridLayout")
		grid.CellSize = config.CellSize or UDim2.new(0, 100, 0, 100)
		grid.CellPadding = UDim2.new(0, padding, 0, padding)
		grid.SortOrder = Enum.SortOrder.LayoutOrder
		if config.HorizontalAlignment then
			grid.HorizontalAlignment = config.HorizontalAlignment
		end
		grid.Parent = container
	else
		local list = Instance.new("UIListLayout")
		list.FillDirection = if config.Mode == "hstack" then Enum.FillDirection.Horizontal else Enum.FillDirection.Vertical
		list.Padding = UDim.new(0, padding)
		list.SortOrder = Enum.SortOrder.LayoutOrder
		if config.HorizontalAlignment then
			list.HorizontalAlignment = config.HorizontalAlignment
		end
		if config.VerticalAlignment then
			list.VerticalAlignment = config.VerticalAlignment
		end
		list.Parent = container
	end

	if config.Parent then
		container.Parent = config.Parent
	end

	local layoutOrder = 0

	local self: Types.MangoLayout = {
		Container = container,
		AddChild = function(self: Types.MangoLayout, child: GuiObject)
			layoutOrder += 1
			child.LayoutOrder = layoutOrder
			child.Parent = container
		end,
		RemoveChild = function(self: Types.MangoLayout, child: GuiObject)
			if child.Parent == container then
				child.Parent = nil
			end
		end,
		Clear = function(self: Types.MangoLayout)
			for _, child in container:GetChildren() do
				if child:IsA("GuiObject") and not child:IsA("UIListLayout") and not child:IsA("UIGridLayout") and not child:IsA("UIPadding") then
					child:Destroy()
				end
			end
			layoutOrder = 0
		end,
		Destroy = function(self: Types.MangoLayout)
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoToggle"] = function()


local TweenService = game:GetService("TweenService")

local Types = _require("Types")
local Themes = _require("Themes")
local MangoHaptics = _require("MangoHaptics")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")

local module = {}

function module.new(config: Types.MangoToggleConfig): Types.MangoToggle
	local scale = resolve(config.Scale, nil, 1) :: number
	local theme = config.Theme
	local initialState = resolve(config.InitialState, nil, false) :: boolean

	-- Track colors
	local onTrackColor = resolve(nil, theme and theme.ToggleOnTrackColor, Color3.fromRGB(52, 199, 89)) :: Color3
	local offTrackColor = resolve(nil, theme and theme.ToggleOffTrackColor, Color3.fromRGB(200, 200, 200)) :: Color3
	local knobColor = resolve(nil, theme and theme.ToggleKnobColor, Color3.fromRGB(255, 255, 255)) :: Color3

	-- Stroke/fresnel from theme (matching glass)
	local strokeColor = resolve(nil, theme and theme.StrokeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local fresnelStart = resolve(nil, theme and theme.FresnelStartTransparency, 0.30) :: number
	local fresnelEnd = resolve(nil, theme and theme.FresnelEndTransparency, 0.95) :: number
	local fresnelMid = resolve(nil, theme and theme.FresnelMidTransparency, 0.55) :: number
	local fresnelMidPoint = resolve(nil, theme and theme.FresnelMidPoint, 0.35) :: number

	-- Dimensions (all scaled)
	local containerWidth = math.floor(51 * scale)
	local containerHeight = math.floor(31 * scale)
	local knobSize = math.floor(27 * scale)
	local knobShadowSize = math.floor(29 * scale)

	-- State
	local isOn: boolean = initialState
	local isDestroyed = false
	local activeTweens: { Tween } = {}
	local inputConnection: RBXScriptConnection? = nil

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- ============================================================
	-- Container
	-- ============================================================
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Toggle")
	container.Size = UDim2.new(0, containerWidth, 0, containerHeight)
	container.Position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	container.AnchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	-- Shadow visibility
	local shadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean

	-- ============================================================
	-- TrackShadow1 (outer, subtle)
	-- ============================================================
	local trackShadow1 = Instance.new("Frame")
	trackShadow1.Name = "TrackShadow1"
	trackShadow1.AnchorPoint = Vector2.new(0.5, 0.5)
	trackShadow1.Position = UDim2.new(0.5, 0, 0.5, math.floor(1 * scale))
	trackShadow1.Size = UDim2.new(1, math.floor(4 * scale), 1, math.floor(4 * scale))
	trackShadow1.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	trackShadow1.BackgroundTransparency = 0.92
	trackShadow1.BorderSizePixel = 0
	trackShadow1.ZIndex = 0
	trackShadow1.Visible = shadowEnabled
	trackShadow1.Parent = container

	local trackShadow1Corner = Instance.new("UICorner")
	trackShadow1Corner.CornerRadius = UDim.new(0, 999)
	trackShadow1Corner.Parent = trackShadow1

	-- ============================================================
	-- TrackShadow2 (tighter)
	-- ============================================================
	local trackShadow2 = Instance.new("Frame")
	trackShadow2.Name = "TrackShadow2"
	trackShadow2.AnchorPoint = Vector2.new(0.5, 0.5)
	trackShadow2.Position = UDim2.new(0.5, 0, 0.5, math.floor(1 * scale))
	trackShadow2.Size = UDim2.new(1, math.floor(2 * scale), 1, math.floor(2 * scale))
	trackShadow2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	trackShadow2.BackgroundTransparency = 0.84
	trackShadow2.BorderSizePixel = 0
	trackShadow2.ZIndex = 0
	trackShadow2.Visible = shadowEnabled
	trackShadow2.Parent = container

	local trackShadow2Corner = Instance.new("UICorner")
	trackShadow2Corner.CornerRadius = UDim.new(0, 999)
	trackShadow2Corner.Parent = trackShadow2

	-- ============================================================
	-- TrackSurface (pill shape)
	-- ============================================================
	local trackSurface = Instance.new("Frame")
	trackSurface.Name = "TrackSurface"
	trackSurface.Size = UDim2.new(1, 0, 1, 0)
	trackSurface.BackgroundColor3 = if isOn then onTrackColor else offTrackColor
	trackSurface.BackgroundTransparency = 0
	trackSurface.BorderSizePixel = 0
	trackSurface.ZIndex = 1
	trackSurface.Parent = container

	local trackSurfaceCorner = Instance.new("UICorner")
	trackSurfaceCorner.CornerRadius = UDim.new(0, 999)
	trackSurfaceCorner.Parent = trackSurface

	-- TrackSpecularFrame (specular rim on track)
	local trackSpecularFrame = Instance.new("Frame")
	trackSpecularFrame.Name = "TrackSpecularFrame"
	trackSpecularFrame.Size = UDim2.new(1, 0, 1, 0)
	trackSpecularFrame.BackgroundTransparency = 1
	trackSpecularFrame.BorderSizePixel = 0
	trackSpecularFrame.ZIndex = 2
	trackSpecularFrame.Parent = trackSurface

	local trackSpecularCorner = Instance.new("UICorner")
	trackSpecularCorner.CornerRadius = UDim.new(0, 999)
	trackSpecularCorner.Parent = trackSpecularFrame

	local trackSpecularStroke = Instance.new("UIStroke")
	trackSpecularStroke.Name = "TrackSpecularStroke"
	trackSpecularStroke.Color = strokeColor
	trackSpecularStroke.Thickness = math.floor(1 * scale)
	trackSpecularStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	trackSpecularStroke.Parent = trackSpecularFrame

	local trackSpecularGradient = Instance.new("UIGradient")
	trackSpecularGradient.Rotation = 90
	trackSpecularGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, fresnelStart),
		NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})
	trackSpecularGradient.Parent = trackSpecularStroke

	-- ============================================================
	-- KnobContainer
	-- ============================================================
	local knobContainer = Instance.new("Frame")
	knobContainer.Name = "KnobContainer"
	knobContainer.Size = UDim2.new(0, knobSize, 0, knobSize)
	knobContainer.BackgroundTransparency = 1
	knobContainer.BorderSizePixel = 0
	knobContainer.ZIndex = 3
	knobContainer.Parent = container

	-- Set initial knob position (no animation)
	if isOn then
		knobContainer.AnchorPoint = Vector2.new(1, 0.5)
		knobContainer.Position = UDim2.new(1, -math.floor(2 * scale), 0.5, 0)
	else
		knobContainer.AnchorPoint = Vector2.new(0, 0.5)
		knobContainer.Position = UDim2.new(0, math.floor(2 * scale), 0.5, 0)
	end

	-- KnobShadow
	local knobShadow = Instance.new("Frame")
	knobShadow.Name = "KnobShadow"
	knobShadow.AnchorPoint = Vector2.new(0.5, 0.5)
	knobShadow.Position = UDim2.new(0.5, 0, 0.5, 0)
	knobShadow.Size = UDim2.new(0, knobShadowSize, 0, knobShadowSize)
	knobShadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	knobShadow.BackgroundTransparency = 0.85
	knobShadow.BorderSizePixel = 0
	knobShadow.ZIndex = 0
	knobShadow.Parent = knobContainer

	local knobShadowCorner = Instance.new("UICorner")
	knobShadowCorner.CornerRadius = UDim.new(0, 999)
	knobShadowCorner.Parent = knobShadow

	-- KnobSurface
	local knobSurface = Instance.new("Frame")
	knobSurface.Name = "KnobSurface"
	knobSurface.AnchorPoint = Vector2.new(0.5, 0.5)
	knobSurface.Position = UDim2.new(0.5, 0, 0.5, 0)
	knobSurface.Size = UDim2.new(0, knobSize, 0, knobSize)
	knobSurface.BackgroundColor3 = knobColor
	knobSurface.BackgroundTransparency = 0
	knobSurface.BorderSizePixel = 0
	knobSurface.ZIndex = 1
	knobSurface.Parent = knobContainer

	local knobSurfaceCorner = Instance.new("UICorner")
	knobSurfaceCorner.CornerRadius = UDim.new(0, 999)
	knobSurfaceCorner.Parent = knobSurface

	-- KnobHighlight (top inner glow)
	local knobHighlight = Instance.new("Frame")
	knobHighlight.Name = "KnobHighlight"
	knobHighlight.Size = UDim2.new(1, 0, 0.4, 0)
	knobHighlight.Position = UDim2.new(0, 0, 0, 0)
	knobHighlight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	knobHighlight.BackgroundTransparency = 0.7
	knobHighlight.BorderSizePixel = 0
	knobHighlight.ZIndex = 2
	knobHighlight.Parent = knobSurface

	local knobHighlightCorner = Instance.new("UICorner")
	knobHighlightCorner.CornerRadius = UDim.new(0, 999)
	knobHighlightCorner.Parent = knobHighlight

	local knobHighlightGradient = Instance.new("UIGradient")
	knobHighlightGradient.Rotation = 90
	knobHighlightGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(1, 1),
	})
	knobHighlightGradient.Parent = knobHighlight

	-- KnobSpecularFrame
	local knobSpecularFrame = Instance.new("Frame")
	knobSpecularFrame.Name = "KnobSpecularFrame"
	knobSpecularFrame.Size = UDim2.new(1, 0, 1, 0)
	knobSpecularFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	knobSpecularFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	knobSpecularFrame.BackgroundTransparency = 1
	knobSpecularFrame.BorderSizePixel = 0
	knobSpecularFrame.ZIndex = 2
	knobSpecularFrame.Parent = knobSurface

	local knobSpecularCorner = Instance.new("UICorner")
	knobSpecularCorner.CornerRadius = UDim.new(0, 999)
	knobSpecularCorner.Parent = knobSpecularFrame

	local knobSpecularStroke = Instance.new("UIStroke")
	knobSpecularStroke.Color = strokeColor
	knobSpecularStroke.Thickness = math.floor(1 * scale)
	knobSpecularStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	knobSpecularStroke.Parent = knobSpecularFrame

	local knobSpecularGradient = Instance.new("UIGradient")
	knobSpecularGradient.Rotation = 90
	knobSpecularGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, fresnelStart + 0.1),
		NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid + 0.05),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})
	knobSpecularGradient.Parent = knobSpecularStroke

	-- ============================================================
	-- Animation
	-- ============================================================
	local function animateToState(state: boolean)
		if isDestroyed then return end
		cancelAllTweens()

		-- Knob position: 0.25s, Back, Out
		local knobTweenInfo = TweenInfo.new(
			0.25,
			Enum.EasingStyle.Back,
			Enum.EasingDirection.Out,
			0,
			false,
			0
		)

		-- Track color: 0.2s, Quad, Out
		local trackTweenInfo = TweenInfo.new(
			0.2,
			Enum.EasingStyle.Quad,
			Enum.EasingDirection.Out,
			0,
			false,
			0
		)

		if state then
			-- Animate knob to ON position
			local anchorTween = TweenService:Create(knobContainer, knobTweenInfo, {
				AnchorPoint = Vector2.new(1, 0.5),
				Position = UDim2.new(1, -math.floor(2 * scale), 0.5, 0),
			})
			trackTween(anchorTween)
			anchorTween:Play()

			-- Animate track to ON color
			local colorTween = TweenService:Create(trackSurface, trackTweenInfo, {
				BackgroundColor3 = onTrackColor,
			})
			trackTween(colorTween)
			colorTween:Play()
		else
			-- Animate knob to OFF position
			local anchorTween = TweenService:Create(knobContainer, knobTweenInfo, {
				AnchorPoint = Vector2.new(0, 0.5),
				Position = UDim2.new(0, math.floor(2 * scale), 0.5, 0),
			})
			trackTween(anchorTween)
			anchorTween:Play()

			-- Animate track to OFF color
			local colorTween = TweenService:Create(trackSurface, trackTweenInfo, {
				BackgroundColor3 = offTrackColor,
			})
			trackTween(colorTween)
			colorTween:Play()
		end
	end

	-- ============================================================
	-- Hit Area (transparent TextButton for reliable input on transparent container)
	-- ============================================================
	local hitArea = Instance.new("TextButton")
	hitArea.Name = "HitArea"
	hitArea.Size = UDim2.new(1, 0, 1, 0)
	hitArea.BackgroundTransparency = 1
	hitArea.BorderSizePixel = 0
	hitArea.Text = ""
	hitArea.AutoButtonColor = false
	hitArea.ZIndex = 100
	hitArea.Parent = container

	-- ============================================================
	-- Input Handling
	-- ============================================================
	inputConnection = hitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			isOn = not isOn
			MangoHaptics.light()
			animateToState(isOn)
			if config.OnToggled then
				config.OnToggled(isOn)
			end
		end
	end)

	-- ============================================================
	-- Parent assignment
	-- ============================================================
	if config.Parent then
		container.Parent = config.Parent
	end

	-- ============================================================
	-- Return table
	-- ============================================================
	local self: Types.MangoToggle = {
		Container = container,
		SetState = function(self: Types.MangoToggle, state: boolean)
			isOn = state
			animateToState(isOn)
		end,
		GetState = function(self: Types.MangoToggle): boolean
			return isOn
		end,
		Destroy = function(self: Types.MangoToggle)
			if isDestroyed then return end
			isDestroyed = true
			cancelAllTweens()
			if inputConnection then
				(inputConnection :: RBXScriptConnection):Disconnect()
				inputConnection = nil
			end
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoSlider"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoHaptics = _require("MangoHaptics")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local module = {}

local function makeSmoothTweenInfo(duration: number): TweenInfo
	return TweenInfo.new(
		duration,
		Enum.EasingStyle.Back,
		Enum.EasingDirection.Out,
		0,
		false,
		0
	)
end

function module.new(config: Types.MangoSliderConfig): Types.MangoSlider
	local theme = config.Theme

	-- Resolve all config values with nil-safe helper
	local size = resolve(config.Size, nil, UDim2.new(0, 200, 0, 36)) :: UDim2
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local minVal = resolve(config.Min, nil, 0) :: number
	local maxVal = resolve(config.Max, nil, 1) :: number
	local step = resolve(config.Step, nil, 0) :: number
	local initialValue = resolve(config.InitialValue, nil, minVal) :: number

	local trackColor = resolve(nil, theme and theme.SliderTrackColor, Color3.fromRGB(220, 220, 225)) :: Color3
	local trackTransparency = resolve(nil, theme and theme.SliderTrackTransparency, 0.50) :: number
	local fillColor = resolve(nil, theme and theme.SliderFillColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local thumbColor = resolve(nil, theme and theme.SliderThumbColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local strokeColor = resolve(nil, theme and theme.StrokeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local fresnelStart = resolve(nil, theme and theme.FresnelStartTransparency, 0.30) :: number
	local fresnelMid = resolve(nil, theme and theme.FresnelMidTransparency, 0.55) :: number
	local fresnelMidPoint = resolve(nil, theme and theme.FresnelMidPoint, 0.35) :: number
	local fresnelEnd = resolve(nil, theme and theme.FresnelEndTransparency, 0.95) :: number

	-- State
	local currentValue: number = math.clamp(initialValue, minVal, maxVal)
	local isDragging = false
	local isDestroyed = false
	local connections: {RBXScriptConnection} = {}
	local activeTweens: {Tween} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- ============================================================
	-- Instance Hierarchy
	-- ============================================================

	-- Container (transparent wrapper)
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Slider")
	container.Size = size
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	-- Shadow visibility
	local shadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean

	-- TrackShadow1 (outer, subtle shadow — fixed transparency)
	local trackShadow1 = Instance.new("Frame")
	trackShadow1.Name = "TrackShadow1"
	trackShadow1.AnchorPoint = Vector2.new(0.5, 0.5)
	trackShadow1.Position = UDim2.new(0.5, 0, 0.5, 1)
	trackShadow1.Size = UDim2.new(1, 6, 0, 14)
	trackShadow1.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	trackShadow1.BackgroundTransparency = 0.86
	trackShadow1.BorderSizePixel = 0
	trackShadow1.ZIndex = 0
	trackShadow1.Visible = shadowEnabled
	trackShadow1.Parent = container

	local trackShadow1Corner = Instance.new("UICorner")
	trackShadow1Corner.CornerRadius = UDim.new(0, 999)
	trackShadow1Corner.Parent = trackShadow1

	-- TrackShadow2 (inner, tighter shadow — fixed transparency)
	local trackShadow2 = Instance.new("Frame")
	trackShadow2.Name = "TrackShadow2"
	trackShadow2.AnchorPoint = Vector2.new(0, 0.5)
	trackShadow2.Position = UDim2.new(0, -1.5, 0.5, 0.5)
	trackShadow2.Size = UDim2.new(1, 3, 0, 11)
	trackShadow2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	trackShadow2.BackgroundTransparency = 0.82
	trackShadow2.BorderSizePixel = 0
	trackShadow2.ZIndex = 0
	trackShadow2.Visible = shadowEnabled
	trackShadow2.Parent = container

	local trackShadow2Corner = Instance.new("UICorner")
	trackShadow2Corner.CornerRadius = UDim.new(0, 999)
	trackShadow2Corner.Parent = trackShadow2

	-- TrackSurface (6px tall glass-like pill, centered vertically)
	local trackSurface = Instance.new("Frame")
	trackSurface.Name = "TrackSurface"
	trackSurface.Size = UDim2.new(1, 0, 0, 6)
	trackSurface.Position = UDim2.new(0, 0, 0.5, 0)
	trackSurface.AnchorPoint = Vector2.new(0, 0.5)
	trackSurface.BackgroundColor3 = trackColor
	trackSurface.BackgroundTransparency = trackTransparency
	trackSurface.ClipsDescendants = true
	trackSurface.BorderSizePixel = 0
	trackSurface.ZIndex = 1
	trackSurface.Parent = container

	local trackSurfaceCorner = Instance.new("UICorner")
	trackSurfaceCorner.CornerRadius = UDim.new(0, 999)
	trackSurfaceCorner.Parent = trackSurface

	-- FillFrame (colored fill, anchored left, width = value fraction)
	local valueFraction = if (maxVal - minVal) > 0 then (currentValue - minVal) / (maxVal - minVal) else 0
	local fillFrame = Instance.new("Frame")
	fillFrame.Name = "FillFrame"
	fillFrame.Size = UDim2.new(valueFraction, 0, 1, 0)
	fillFrame.Position = UDim2.new(0, 0, 0, 0)
	fillFrame.AnchorPoint = Vector2.new(0, 0)
	fillFrame.BackgroundColor3 = fillColor
	local fillTransparency = resolve(nil, theme and theme.SliderFillTransparency, 0.40) :: number
	fillFrame.BackgroundTransparency = fillTransparency
	fillFrame.BorderSizePixel = 0
	fillFrame.ZIndex = 1
	fillFrame.ClipsDescendants = true
	fillFrame.Parent = trackSurface

	local fillFrameCorner = Instance.new("UICorner")
	fillFrameCorner.CornerRadius = UDim.new(0, 999)
	fillFrameCorner.Parent = fillFrame

	-- FillHighlight (glass capsule appearance for accent fill)
	local fillHighlight = Instance.new("Frame")
	fillHighlight.Name = "FillHighlight"
	fillHighlight.Size = UDim2.new(1, 0, 0.5, 0)
	fillHighlight.Position = UDim2.new(0, 0, 0, 0)
	fillHighlight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	fillHighlight.BackgroundTransparency = 0.88
	fillHighlight.BorderSizePixel = 0
	fillHighlight.ZIndex = 2
	fillHighlight.Parent = fillFrame

	local fillHighlightGradient = Instance.new("UIGradient")
	fillHighlightGradient.Name = "FillHighlightGradient"
	fillHighlightGradient.Rotation = 90
	fillHighlightGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(1, 1),
	})
	fillHighlightGradient.Parent = fillHighlight

	-- TrackSpecularFrame (outside trackSurface to avoid ClipsDescendants clipping the Border-mode stroke)
	local trackSpecularFrame = Instance.new("Frame")
	trackSpecularFrame.Name = "TrackSpecularFrame"
	trackSpecularFrame.Size = UDim2.new(1, 0, 0, 6)
	trackSpecularFrame.Position = UDim2.new(0, 0, 0.5, 0)
	trackSpecularFrame.AnchorPoint = Vector2.new(0, 0.5)
	trackSpecularFrame.BackgroundTransparency = 1
	trackSpecularFrame.BorderSizePixel = 0
	trackSpecularFrame.ZIndex = 2
	trackSpecularFrame.Parent = container

	local trackSpecularCorner = Instance.new("UICorner")
	trackSpecularCorner.CornerRadius = UDim.new(0, 999)
	trackSpecularCorner.Parent = trackSpecularFrame

	local trackSpecularStroke = Instance.new("UIStroke")
	trackSpecularStroke.Name = "TrackSpecularStroke"
	trackSpecularStroke.Color = strokeColor
	trackSpecularStroke.Thickness = 1
	trackSpecularStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	trackSpecularStroke.Parent = trackSpecularFrame

	local trackSpecularGradient = Instance.new("UIGradient")
	trackSpecularGradient.Name = "TrackSpecularGradient"
	trackSpecularGradient.Rotation = 90
	trackSpecularGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, fresnelStart),
		NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})
	trackSpecularGradient.Parent = trackSpecularStroke

	-- Track inner edge (recessed look via Border stroke inside ClipsDescendants)
	local innerEdgeColor = resolve(nil, theme and theme.InnerEdgeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local innerEdgeTop = resolve(nil, theme and theme.InnerEdgeTopTransparency, 0.35) :: number
	local innerEdgeMid = resolve(nil, theme and theme.InnerEdgeMidTransparency, 0.72) :: number
	local innerEdgeBottom = resolve(nil, theme and theme.InnerEdgeBottomTransparency, 0.92) :: number

	local trackInnerEdgeFrame = Instance.new("Frame")
	trackInnerEdgeFrame.Name = "TrackInnerEdgeFrame"
	trackInnerEdgeFrame.Size = UDim2.new(1, 0, 1, 0)
	trackInnerEdgeFrame.BackgroundTransparency = 1
	trackInnerEdgeFrame.BorderSizePixel = 0
	trackInnerEdgeFrame.ZIndex = 3
	trackInnerEdgeFrame.Parent = trackSurface

	local trackInnerEdgeCorner = Instance.new("UICorner")
	trackInnerEdgeCorner.CornerRadius = UDim.new(0, 999)
	trackInnerEdgeCorner.Parent = trackInnerEdgeFrame

	local trackInnerEdgeStroke = Instance.new("UIStroke")
	trackInnerEdgeStroke.Name = "TrackInnerEdgeStroke"
	trackInnerEdgeStroke.Color = innerEdgeColor
	trackInnerEdgeStroke.Thickness = 1
	trackInnerEdgeStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	trackInnerEdgeStroke.Parent = trackInnerEdgeFrame

	local trackInnerEdgeGradient = Instance.new("UIGradient")
	trackInnerEdgeGradient.Name = "TrackInnerEdgeGradient"
	trackInnerEdgeGradient.Rotation = 90
	trackInnerEdgeGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, innerEdgeTop + 0.20),
		NumberSequenceKeypoint.new(0.5, innerEdgeMid + 0.10),
		NumberSequenceKeypoint.new(1, innerEdgeBottom),
	})
	trackInnerEdgeGradient.Parent = trackInnerEdgeStroke

	-- ThumbContainer (positioned by value)
	local thumbContainer = Instance.new("Frame")
	thumbContainer.Name = "ThumbContainer"
	thumbContainer.Size = UDim2.new(0, 28, 0, 28)
	thumbContainer.AnchorPoint = Vector2.new(0.5, 0.5)
	thumbContainer.Position = UDim2.new(valueFraction, 0, 0.5, 0)
	thumbContainer.BackgroundTransparency = 1
	thumbContainer.BorderSizePixel = 0
	thumbContainer.ZIndex = 3
	thumbContainer.Parent = container

	-- ThumbShadow (outer, behind thumb — grows on drag)
	local thumbShadow = Instance.new("Frame")
	thumbShadow.Name = "ThumbShadow"
	thumbShadow.Size = UDim2.new(0, 30, 0, 30)
	thumbShadow.AnchorPoint = Vector2.new(0.5, 0.5)
	thumbShadow.Position = UDim2.new(0.5, 0, 0.5, 1)
	thumbShadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	thumbShadow.BackgroundTransparency = 0.85
	thumbShadow.BorderSizePixel = 0
	thumbShadow.ZIndex = 0
	thumbShadow.Parent = thumbContainer

	local thumbShadowCorner = Instance.new("UICorner")
	thumbShadowCorner.CornerRadius = UDim.new(0, 999)
	thumbShadowCorner.Parent = thumbShadow

	-- ThumbSurface (28x28 circle, white — grows on drag)
	local thumbSurface = Instance.new("Frame")
	thumbSurface.Name = "ThumbSurface"
	thumbSurface.Size = UDim2.new(0, 28, 0, 28)
	thumbSurface.AnchorPoint = Vector2.new(0.5, 0.5)
	thumbSurface.Position = UDim2.new(0.5, 0, 0.5, 0)
	thumbSurface.BackgroundColor3 = thumbColor
	thumbSurface.BackgroundTransparency = 0
	thumbSurface.BorderSizePixel = 0
	thumbSurface.ZIndex = 1
	thumbSurface.Parent = thumbContainer

	local thumbSurfaceCorner = Instance.new("UICorner")
	thumbSurfaceCorner.CornerRadius = UDim.new(0, 999)
	thumbSurfaceCorner.Parent = thumbSurface

	local thumbStroke = Instance.new("UIStroke")
	thumbStroke.Color = Color3.fromRGB(200, 200, 205)
	thumbStroke.Thickness = 0.5
	thumbStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	thumbStroke.Transparency = 0.4
	thumbStroke.Parent = thumbSurface

	-- ============================================================
	-- Drag Logic
	-- ============================================================

	-- Helper: compute value from absolute X position
	local function valueFromX(absX: number): number
		local trackLeft = container.AbsolutePosition.X
		local trackWidth = container.AbsoluteSize.X
		local fraction = math.clamp((absX - trackLeft) / trackWidth, 0, 1)
		local rawValue = minVal + fraction * (maxVal - minVal)
		if step > 0 then
			rawValue = math.round(rawValue / step) * step
		end
		return math.clamp(rawValue, minVal, maxVal)
	end

	-- Helper: update visual position from current value
	local function updateVisual()
		local fraction = if (maxVal - minVal) > 0 then (currentValue - minVal) / (maxVal - minVal) else 0
		-- Edge-snap: prevent sub-pixel rounding artifacts at 0% and 100%
		if fraction >= 0.995 then fraction = 1 end
		if fraction <= 0.005 then fraction = 0 end
		fillFrame.Size = UDim2.new(fraction, 0, 1, 0)
		thumbContainer.Position = UDim2.new(fraction, 0, 0.5, 0)
	end

	-- Helper: apply value and fire callback
	local function applyValue(newValue: number)
		local oldValue = currentValue
		currentValue = newValue
		updateVisual()
		if oldValue ~= newValue and config.OnChanged then
			config.OnChanged(newValue)
		end
	end

	-- Thumb grow on drag start
	local function growThumb()
		local growInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		trackTween(TweenService:Create(thumbSurface, growInfo, {
			Size = UDim2.new(0, 34, 0, 34),
		})):Play()
		trackTween(TweenService:Create(thumbShadow, growInfo, {
			Size = UDim2.new(0, 38, 0, 38),
			BackgroundTransparency = 0.72,
		})):Play()
	end

	-- Thumb shrink on drag end
	local function shrinkThumb()
		local shrinkInfo = makeSmoothTweenInfo(0.3)
		trackTween(TweenService:Create(thumbSurface, shrinkInfo, {
			Size = UDim2.new(0, 28, 0, 28),
		})):Play()
		trackTween(TweenService:Create(thumbShadow, shrinkInfo, {
			Size = UDim2.new(0, 30, 0, 30),
			BackgroundTransparency = 0.85,
		})):Play()
	end

	-- Transparent hit areas for reliable input (child elements block parent InputBegan)
	local thumbHitArea = Instance.new("TextButton")
	thumbHitArea.Name = "ThumbHitArea"
	thumbHitArea.Size = UDim2.new(1, 0, 1, 0)
	thumbHitArea.BackgroundTransparency = 1
	thumbHitArea.Text = ""
	thumbHitArea.BorderSizePixel = 0
	thumbHitArea.ZIndex = 100
	thumbHitArea.AutoButtonColor = false
	thumbHitArea.Parent = thumbContainer

	local trackHitArea = Instance.new("TextButton")
	trackHitArea.Name = "TrackHitArea"
	trackHitArea.Size = UDim2.new(1, 0, 0, 16)
	trackHitArea.AnchorPoint = Vector2.new(0, 0.5)
	trackHitArea.Position = UDim2.new(0, 0, 0.5, 0)
	trackHitArea.BackgroundTransparency = 1
	trackHitArea.Text = ""
	trackHitArea.BorderSizePixel = 0
	trackHitArea.ZIndex = 50
	trackHitArea.AutoButtonColor = false
	trackHitArea.Parent = container

	-- Start drag from thumb
	local thumbInputBeganConn = thumbHitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			isDragging = true
			MangoHaptics.light()
			growThumb()
		end
	end)
	table.insert(connections, thumbInputBeganConn)

	-- Start drag from track (tap-to-seek)
	local trackInputBeganConn = trackHitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			isDragging = true
			local newValue = valueFromX(input.Position.X)
			applyValue(newValue)
			growThumb()
		end
	end)
	table.insert(connections, trackInputBeganConn)

	-- Track drag globally via UserInputService.InputChanged
	local inputChangedConn = UserInputService.InputChanged:Connect(function(input: InputObject)
		if isDestroyed or not isDragging then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch then
			local newValue = valueFromX(input.Position.X)
			applyValue(newValue)
		end
	end)
	table.insert(connections, inputChangedConn)

	-- End drag on UserInputService.InputEnded
	local inputEndedConn = UserInputService.InputEnded:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			if isDragging then
				isDragging = false

				-- Shrink thumb back and elastic settle
				shrinkThumb()
				local fraction = if (maxVal - minVal) > 0 then (currentValue - minVal) / (maxVal - minVal) else 0
				local settleInfo = makeSmoothTweenInfo(0.25)
				local settleTween = TweenService:Create(thumbContainer, settleInfo, {
					Position = UDim2.new(fraction, 0, 0.5, 0),
				})
				trackTween(settleTween)
				settleTween:Play()
			end
		end
	end)
	table.insert(connections, inputEndedConn)

	-- ============================================================
	-- Parent Assignment
	-- ============================================================

	if config.Parent then
		container.Parent = config.Parent
	end

	-- Set initial value and visual at construction time (no animation)
	updateVisual()

	-- ============================================================
	-- Return Table
	-- ============================================================

	local self: Types.MangoSlider = {
		Container = container,
		SetValue = function(self: Types.MangoSlider, value: number)
			currentValue = math.clamp(value, minVal, maxVal)
			updateVisual()
		end,
		GetValue = function(self: Types.MangoSlider): number
			return currentValue
		end,
		Destroy = function(self: Types.MangoSlider)
			if isDestroyed then return end
			isDestroyed = true
			isDragging = false
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			cancelAllTweens()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoCheckbox"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoHaptics = _require("MangoHaptics")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")

local module = {}

function module.new(config: Types.MangoCheckboxConfig): Types.MangoCheckbox
	local theme = config.Theme

	-- Resolve config values
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local initialState = resolve(config.InitialState, nil, false) :: boolean
	local labelText = config.Label

	-- Theme values
	local onColor = resolve(nil, theme and theme.CheckboxOnColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local offColor = resolve(nil, theme and theme.CheckboxOffColor, Color3.fromRGB(200, 200, 205)) :: Color3
	local checkColor = resolve(nil, theme and theme.CheckboxCheckColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local primaryText = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3

	-- State
	local isChecked: boolean = initialState
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Container (horizontal layout)
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Checkbox")
	container.Size = UDim2.new(0, 0, 0, 24)
	container.AutomaticSize = Enum.AutomaticSize.X
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	local layout = Instance.new("UIListLayout")
	layout.FillDirection = Enum.FillDirection.Horizontal
	layout.VerticalAlignment = Enum.VerticalAlignment.Center
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 8)
	layout.Parent = container

	-- CheckboxFrame (24x24)
	local checkboxFrame = Instance.new("Frame")
	checkboxFrame.Name = "CheckboxFrame"
	checkboxFrame.Size = UDim2.new(0, 24, 0, 24)
	checkboxFrame.BackgroundTransparency = 1
	checkboxFrame.BorderSizePixel = 0
	checkboxFrame.LayoutOrder = 1
	checkboxFrame.Parent = container

	-- UIStroke (border that changes color)
	local checkboxStroke = Instance.new("UIStroke")
	checkboxStroke.Name = "CheckboxStroke"
	checkboxStroke.Color = if isChecked then onColor else offColor
	checkboxStroke.Thickness = 1.5
	checkboxStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	checkboxStroke.Parent = checkboxFrame

	local checkboxCorner = Instance.new("UICorner")
	checkboxCorner.CornerRadius = UDim.new(0, 6)
	checkboxCorner.Parent = checkboxFrame

	-- CheckFill (colored fill, uses UIScale for animation)
	local checkFill = Instance.new("Frame")
	checkFill.Name = "CheckFill"
	checkFill.Size = UDim2.new(1, 0, 1, 0)
	checkFill.BackgroundColor3 = onColor
	checkFill.BackgroundTransparency = 0
	checkFill.BorderSizePixel = 0
	checkFill.ZIndex = 1
	checkFill.Parent = checkboxFrame

	local checkFillCorner = Instance.new("UICorner")
	checkFillCorner.CornerRadius = UDim.new(0, 6)
	checkFillCorner.Parent = checkFill

	local checkFillScale = Instance.new("UIScale")
	checkFillScale.Scale = if isChecked then 1 else 0
	checkFillScale.Parent = checkFill

	-- Checkmark label
	local checkmarkLabel = Instance.new("TextLabel")
	checkmarkLabel.Name = "CheckmarkLabel"
	checkmarkLabel.Size = UDim2.new(1, 0, 1, 0)
	checkmarkLabel.BackgroundTransparency = 1
	checkmarkLabel.BorderSizePixel = 0
	checkmarkLabel.Font = Enum.Font.SourceSansBold
	checkmarkLabel.TextSize = 16
	checkmarkLabel.Text = "\226\156\147" -- checkmark ✓
	checkmarkLabel.TextColor3 = checkColor
	checkmarkLabel.TextTransparency = if isChecked then 0 else 1
	checkmarkLabel.TextXAlignment = Enum.TextXAlignment.Center
	checkmarkLabel.TextYAlignment = Enum.TextYAlignment.Center
	checkmarkLabel.ZIndex = 10
	checkmarkLabel.Parent = checkboxFrame

	-- HitArea
	local hitArea = Instance.new("TextButton")
	hitArea.Name = "HitArea"
	hitArea.Size = UDim2.new(1, 0, 1, 0)
	hitArea.BackgroundTransparency = 1
	hitArea.Text = ""
	hitArea.BorderSizePixel = 0
	hitArea.ZIndex = 100
	hitArea.AutoButtonColor = false
	hitArea.Parent = checkboxFrame

	-- Label text (optional)
	if labelText and labelText ~= "" then
		local label = Instance.new("TextLabel")
		label.Name = "LabelText"
		label.Size = UDim2.new(0, 0, 1, 0)
		label.AutomaticSize = Enum.AutomaticSize.X
		label.BackgroundTransparency = 1
		label.BorderSizePixel = 0
		label.Font = Enum.Font.GothamMedium
		label.TextSize = 14
		label.Text = labelText
		label.TextColor3 = primaryText
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.LayoutOrder = 2
		label.Parent = container
	end

	-- Animation
	local function animateToState(state: boolean)
		cancelAllTweens()

		local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local colorInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

		-- Scale fill in/out
		local scaleTween = TweenService:Create(checkFillScale, tweenInfo, {
			Scale = if state then 1 else 0,
		})
		trackTween(scaleTween)
		scaleTween:Play()

		-- Stroke color
		local strokeTween = TweenService:Create(checkboxStroke, colorInfo, {
			Color = if state then onColor else offColor,
		})
		trackTween(strokeTween)
		strokeTween:Play()

		-- Checkmark transparency
		local checkTween = TweenService:Create(checkmarkLabel, colorInfo, {
			TextTransparency = if state then 0 else 1,
		})
		trackTween(checkTween)
		checkTween:Play()
	end

	-- Click handler
	local clickConn = hitArea.MouseButton1Click:Connect(function()
		isChecked = not isChecked
		MangoHaptics.light()
		animateToState(isChecked)
		if config.OnToggled then
			config.OnToggled(isChecked)
		end
	end)
	table.insert(connections, clickConn)

	-- Parent assignment
	if config.Parent then
		container.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoCheckbox = {
		Container = container,
		SetState = function(self: Types.MangoCheckbox, state: boolean)
			isChecked = state
			animateToState(isChecked)
		end,
		GetState = function(self: Types.MangoCheckbox): boolean
			return isChecked
		end,
		Destroy = function(self: Types.MangoCheckbox)
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoProgressBar"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")

local module = {}

function module.new(config: Types.MangoProgressBarConfig): Types.MangoProgressBar
	local theme = config.Theme

	-- Resolve config values
	local size = resolve(config.Size, nil, UDim2.new(0, 200, 0, 20)) :: UDim2
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local initialValue = resolve(config.InitialValue, nil, 0) :: number

	-- Theme values
	local trackColor = resolve(nil, theme and theme.SliderTrackColor, Color3.fromRGB(220, 220, 225)) :: Color3
	local trackTransparency = resolve(nil, theme and theme.ProgressBarTrackTransparency, 0.85) :: number
	local fillColor = resolve(nil, theme and theme.ProgressBarFillColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local fillTransparency = resolve(nil, theme and theme.ProgressBarFillTransparency, 0.30) :: number
	local strokeColor = resolve(nil, theme and theme.StrokeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local fresnelStart = resolve(nil, theme and theme.FresnelStartTransparency, 0.25) :: number
	local fresnelMid = resolve(nil, theme and theme.FresnelMidTransparency, 0.50) :: number
	local fresnelMidPoint = resolve(nil, theme and theme.FresnelMidPoint, 0.35) :: number
	local fresnelEnd = resolve(nil, theme and theme.FresnelEndTransparency, 0.95) :: number
	local innerEdgeColor = resolve(nil, theme and theme.InnerEdgeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local innerEdgeTop = resolve(nil, theme and theme.InnerEdgeTopTransparency, 0.35) :: number
	local innerEdgeMid = resolve(nil, theme and theme.InnerEdgeMidTransparency, 0.72) :: number
	local innerEdgeBottom = resolve(nil, theme and theme.InnerEdgeBottomTransparency, 0.92) :: number
	local shadowColor = resolve(nil, theme and theme.ShadowColor, Color3.fromRGB(0, 0, 0)) :: Color3

	-- State
	local currentValue: number = math.clamp(initialValue, 0, 1)
	local activeTweens: {Tween} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Container
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("ProgressBar")
	container.Size = size
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	-- Shadow visibility
	local shadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean

	-- Shadow layer 1 (outer)
	local shadow1 = Instance.new("Frame")
	shadow1.Name = "ShadowLayer1"
	shadow1.AnchorPoint = Vector2.new(0.5, 0.5)
	shadow1.Position = UDim2.new(0.5, 0, 0.5, 1)
	shadow1.Size = UDim2.new(1, 8, 0, 12)
	shadow1.BackgroundColor3 = shadowColor
	shadow1.BackgroundTransparency = 0.88
	shadow1.BorderSizePixel = 0
	shadow1.ZIndex = 0
	shadow1.Visible = shadowEnabled
	shadow1.Parent = container

	local shadow1Corner = Instance.new("UICorner")
	shadow1Corner.CornerRadius = UDim.new(0, 999)
	shadow1Corner.Parent = shadow1

	-- Shadow layer 2 (inner)
	local shadow2 = Instance.new("Frame")
	shadow2.Name = "ShadowLayer2"
	shadow2.AnchorPoint = Vector2.new(0.5, 0.5)
	shadow2.Position = UDim2.new(0.5, 0, 0.5, 0.5)
	shadow2.Size = UDim2.new(1, 4, 0, 10)
	shadow2.BackgroundColor3 = shadowColor
	shadow2.BackgroundTransparency = 0.84
	shadow2.BorderSizePixel = 0
	shadow2.ZIndex = 0
	shadow2.Visible = shadowEnabled
	shadow2.Parent = container

	local shadow2Corner = Instance.new("UICorner")
	shadow2Corner.CornerRadius = UDim.new(0, 999)
	shadow2Corner.Parent = shadow2

	-- TrackSurface (6px tall pill, centered vertically)
	local trackSurface = Instance.new("Frame")
	trackSurface.Name = "TrackSurface"
	trackSurface.Size = UDim2.new(1, 0, 0, 6)
	trackSurface.Position = UDim2.new(0, 0, 0.5, 0)
	trackSurface.AnchorPoint = Vector2.new(0, 0.5)
	trackSurface.BackgroundColor3 = trackColor
	trackSurface.BackgroundTransparency = trackTransparency
	trackSurface.ClipsDescendants = true
	trackSurface.BorderSizePixel = 0
	trackSurface.ZIndex = 1
	trackSurface.Parent = container

	local trackCorner = Instance.new("UICorner")
	trackCorner.CornerRadius = UDim.new(0, 999)
	trackCorner.Parent = trackSurface

	-- FillFrame (width = value fraction)
	local fillFrame = Instance.new("Frame")
	fillFrame.Name = "FillFrame"
	fillFrame.Size = UDim2.new(currentValue, 0, 1, 0)
	fillFrame.Position = UDim2.new(0, 0, 0, 0)
	fillFrame.AnchorPoint = Vector2.new(0, 0)
	fillFrame.BackgroundColor3 = fillColor
	fillFrame.BackgroundTransparency = fillTransparency
	fillFrame.BorderSizePixel = 0
	fillFrame.ZIndex = 1
	fillFrame.Parent = trackSurface

	-- FillHighlight (glass capsule appearance)
	local fillHighlight = Instance.new("Frame")
	fillHighlight.Name = "FillHighlight"
	fillHighlight.Size = UDim2.new(1, 0, 0.5, 0)
	fillHighlight.Position = UDim2.new(0, 0, 0, 0)
	fillHighlight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	fillHighlight.BackgroundTransparency = 0.88
	fillHighlight.BorderSizePixel = 0
	fillHighlight.ZIndex = 2
	fillHighlight.Parent = fillFrame

	local fillHighlightCorner = Instance.new("UICorner")
	fillHighlightCorner.CornerRadius = UDim.new(1, 0)
	fillHighlightCorner.Parent = fillHighlight

	local fillHighlightGradient = Instance.new("UIGradient")
	fillHighlightGradient.Name = "FillHighlightGradient"
	fillHighlightGradient.Rotation = 90
	fillHighlightGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(1, 1),
	})
	fillHighlightGradient.Parent = fillHighlight

	-- TrackSpecularFrame (outside trackSurface to avoid ClipsDescendants clipping the Border-mode stroke)
	local trackSpecularFrame = Instance.new("Frame")
	trackSpecularFrame.Name = "TrackSpecularFrame"
	trackSpecularFrame.Size = UDim2.new(1, 0, 0, 6)
	trackSpecularFrame.Position = UDim2.new(0, 0, 0.5, 0)
	trackSpecularFrame.AnchorPoint = Vector2.new(0, 0.5)
	trackSpecularFrame.BackgroundTransparency = 1
	trackSpecularFrame.BorderSizePixel = 0
	trackSpecularFrame.ZIndex = 2
	trackSpecularFrame.Parent = container

	local trackSpecularCorner = Instance.new("UICorner")
	trackSpecularCorner.CornerRadius = UDim.new(0, 999)
	trackSpecularCorner.Parent = trackSpecularFrame

	local trackSpecularStroke = Instance.new("UIStroke")
	trackSpecularStroke.Name = "TrackSpecularStroke"
	trackSpecularStroke.Color = strokeColor
	trackSpecularStroke.Thickness = 1
	trackSpecularStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	trackSpecularStroke.Parent = trackSpecularFrame

	local trackSpecularGradient = Instance.new("UIGradient")
	trackSpecularGradient.Name = "TrackSpecularGradient"
	trackSpecularGradient.Rotation = 90
	trackSpecularGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, fresnelStart),
		NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})
	trackSpecularGradient.Parent = trackSpecularStroke

	-- Track inner edge (recessed look via Border stroke inside ClipsDescendants)
	local trackInnerEdgeFrame = Instance.new("Frame")
	trackInnerEdgeFrame.Name = "TrackInnerEdgeFrame"
	trackInnerEdgeFrame.Size = UDim2.new(1, 0, 1, 0)
	trackInnerEdgeFrame.BackgroundTransparency = 1
	trackInnerEdgeFrame.BorderSizePixel = 0
	trackInnerEdgeFrame.ZIndex = 3
	trackInnerEdgeFrame.Parent = trackSurface

	local trackInnerEdgeCorner = Instance.new("UICorner")
	trackInnerEdgeCorner.CornerRadius = UDim.new(0, 999)
	trackInnerEdgeCorner.Parent = trackInnerEdgeFrame

	local trackInnerEdgeStroke = Instance.new("UIStroke")
	trackInnerEdgeStroke.Name = "TrackInnerEdgeStroke"
	trackInnerEdgeStroke.Color = innerEdgeColor
	trackInnerEdgeStroke.Thickness = 1
	trackInnerEdgeStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	trackInnerEdgeStroke.Parent = trackInnerEdgeFrame

	local trackInnerEdgeGradient = Instance.new("UIGradient")
	trackInnerEdgeGradient.Name = "TrackInnerEdgeGradient"
	trackInnerEdgeGradient.Rotation = 90
	trackInnerEdgeGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, innerEdgeTop + 0.20),
		NumberSequenceKeypoint.new(0.5, innerEdgeMid + 0.10),
		NumberSequenceKeypoint.new(1, innerEdgeBottom),
	})
	trackInnerEdgeGradient.Parent = trackInnerEdgeStroke

	-- Parent assignment
	if config.Parent then
		container.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoProgressBar = {
		Container = container,
		SetValue = function(self: Types.MangoProgressBar, value: number)
			local clamped = math.clamp(value, 0, 1)
			currentValue = clamped
			cancelAllTweens()
			local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local tween = TweenService:Create(fillFrame, tweenInfo, {
				Size = UDim2.new(clamped, 0, 1, 0),
			})
			trackTween(tween)
			tween:Play()
		end,
		GetValue = function(self: Types.MangoProgressBar): number
			return currentValue
		end,
		Destroy = function(self: Types.MangoProgressBar)
			cancelAllTweens()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoSegmentedControl"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")

local module = {}

function module.new(config: Types.MangoSegmentedControlConfig): Types.MangoSegmentedControl
	local theme = config.Theme
	local segments = resolve(config.Segments, nil, {"Tab 1", "Tab 2"}) :: {string}
	local segmentCount = #segments

	-- Resolve config values
	local segmentWidth = resolve(config.SegmentWidth, nil, 90) :: number
	local height = resolve(config.Height, nil, 36) :: number
	local initialIndex = resolve(config.InitialIndex, nil, 1) :: number
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2

	-- Theme values
	local bgTransparency = resolve(nil, theme and theme.SegmentedBackgroundTransparency, 0.88) :: number
	local selectedTransparency = resolve(nil, theme and theme.SegmentedSelectedTransparency, 0.72) :: number
	local selectedColor = resolve(nil, theme and theme.SegmentedSelectedColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local bgColor = resolve(nil, theme and theme.BackgroundColor3, Color3.fromRGB(255, 255, 255)) :: Color3
	local primaryText = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local secondaryText = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3
	local strokeColor = resolve(nil, theme and theme.StrokeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local fresnelStart = resolve(nil, theme and theme.FresnelStartTransparency, 0.25) :: number
	local fresnelMid = resolve(nil, theme and theme.FresnelMidTransparency, 0.50) :: number
	local fresnelMidPoint = resolve(nil, theme and theme.FresnelMidPoint, 0.35) :: number
	local fresnelEnd = resolve(nil, theme and theme.FresnelEndTransparency, 0.95) :: number

	-- State
	local currentIndex: number = math.clamp(initialIndex, 1, segmentCount)
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- OuterWrapper (no ClipsDescendants, holds size/position, receives OuterSpecularFrame)
	local totalWidth = segmentWidth * segmentCount
	local outerWrapper = Instance.new("Frame")
	outerWrapper.Name = MangoProtection.randomName("SegControl")
	outerWrapper.Size = UDim2.new(0, totalWidth, 0, height)
	outerWrapper.Position = position
	outerWrapper.AnchorPoint = anchorPoint
	outerWrapper.BackgroundTransparency = 1
	outerWrapper.BorderSizePixel = 0

	-- Container (pill shape, clips descendants for sliding indicator)
	local container = Instance.new("Frame")
	container.Name = "InnerContainer"
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.ClipsDescendants = true
	container.Parent = outerWrapper

	-- BackgroundGlass (glass tint background)
	local backgroundGlass = Instance.new("Frame")
	backgroundGlass.Name = "BackgroundGlass"
	backgroundGlass.Size = UDim2.new(1, 0, 1, 0)
	backgroundGlass.BackgroundColor3 = bgColor
	backgroundGlass.BackgroundTransparency = bgTransparency
	backgroundGlass.BorderSizePixel = 0
	backgroundGlass.ZIndex = 0
	backgroundGlass.Parent = container

	local bgCorner = Instance.new("UICorner")
	bgCorner.CornerRadius = UDim.new(0, 999)
	bgCorner.Parent = backgroundGlass

	-- SelectedIndicator (sliding glass pill)
	local selectedIndicator = Instance.new("Frame")
	selectedIndicator.Name = "SelectedIndicator"
	selectedIndicator.Size = UDim2.new(0, segmentWidth, 1, -4)
	selectedIndicator.Position = UDim2.new(0, (currentIndex - 1) * segmentWidth + 2, 0.5, 0)
	selectedIndicator.AnchorPoint = Vector2.new(0, 0.5)
	selectedIndicator.BackgroundColor3 = selectedColor
	selectedIndicator.BackgroundTransparency = selectedTransparency
	selectedIndicator.BorderSizePixel = 0
	selectedIndicator.ZIndex = 1
	selectedIndicator.Parent = container

	local indicatorCorner = Instance.new("UICorner")
	indicatorCorner.CornerRadius = UDim.new(0, 999)
	indicatorCorner.Parent = selectedIndicator

	-- Indicator specular frame
	local indicatorSpecFrame = Instance.new("Frame")
	indicatorSpecFrame.Name = "SpecularFrame"
	indicatorSpecFrame.Size = UDim2.new(1, 0, 1, 0)
	indicatorSpecFrame.BackgroundTransparency = 1
	indicatorSpecFrame.BorderSizePixel = 0
	indicatorSpecFrame.ZIndex = 2
	indicatorSpecFrame.Parent = selectedIndicator

	local indicatorSpecCorner = Instance.new("UICorner")
	indicatorSpecCorner.CornerRadius = UDim.new(0, 999)
	indicatorSpecCorner.Parent = indicatorSpecFrame

	local indicatorSpecStroke = Instance.new("UIStroke")
	indicatorSpecStroke.Name = "SpecularStroke"
	indicatorSpecStroke.Color = strokeColor
	indicatorSpecStroke.Thickness = 1
	indicatorSpecStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	indicatorSpecStroke.Parent = indicatorSpecFrame

	local indicatorSpecGradient = Instance.new("UIGradient")
	indicatorSpecGradient.Name = "SpecularGradient"
	indicatorSpecGradient.Rotation = 90
	indicatorSpecGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, fresnelStart + 0.05),
		NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid + 0.05),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})
	indicatorSpecGradient.Parent = indicatorSpecStroke

	-- Segment buttons
	local segmentButtons: {TextButton} = {}
	local segmentLabels: {TextButton} = {} -- reuse for color tweening

	for i = 1, segmentCount do
		local btn = Instance.new("TextButton")
		btn.Name = "Segment" .. i
		btn.Size = UDim2.new(0, segmentWidth, 1, 0)
		btn.Position = UDim2.new(0, (i - 1) * segmentWidth, 0, 0)
		btn.BackgroundTransparency = 1
		btn.BorderSizePixel = 0
		btn.Text = segments[i]
		btn.Font = Enum.Font.GothamMedium
		btn.TextSize = 14
		btn.TextColor3 = if i == currentIndex then primaryText else secondaryText
		btn.TextTruncate = Enum.TextTruncate.AtEnd
		btn.ZIndex = 10
		btn.AutoButtonColor = false
		btn.Parent = container

		table.insert(segmentButtons, btn)
		table.insert(segmentLabels, btn)
	end

	-- Outer specular frame (rim on entire container)
	local outerSpecFrame = Instance.new("Frame")
	outerSpecFrame.Name = "OuterSpecularFrame"
	outerSpecFrame.Size = UDim2.new(1, 0, 1, 0)
	outerSpecFrame.BackgroundTransparency = 1
	outerSpecFrame.BorderSizePixel = 0
	outerSpecFrame.ZIndex = 11
	outerSpecFrame.Parent = outerWrapper

	local outerSpecCorner = Instance.new("UICorner")
	outerSpecCorner.CornerRadius = UDim.new(0, 999)
	outerSpecCorner.Parent = outerSpecFrame

	local outerSpecStroke = Instance.new("UIStroke")
	outerSpecStroke.Name = "OuterSpecularStroke"
	outerSpecStroke.Color = strokeColor
	outerSpecStroke.Thickness = 1
	outerSpecStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	outerSpecStroke.Parent = outerSpecFrame

	local outerSpecGradient = Instance.new("UIGradient")
	outerSpecGradient.Name = "OuterSpecularGradient"
	outerSpecGradient.Rotation = 90
	outerSpecGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, fresnelStart + 0.10),
		NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid + 0.10),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})
	outerSpecGradient.Parent = outerSpecStroke

	-- Selection logic
	local function selectIndex(index: number)
		if index < 1 or index > segmentCount then
			return
		end
		cancelAllTweens()
		currentIndex = index

		-- Slide indicator
		local slideInfo = TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local slideTween = TweenService:Create(selectedIndicator, slideInfo, {
			Position = UDim2.new(0, (index - 1) * segmentWidth + 2, 0.5, 0),
		})
		trackTween(slideTween)
		slideTween:Play()

		-- Update text colors
		local colorInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		for i, btn in segmentLabels do
			local targetColor = if i == index then primaryText else secondaryText
			local colorTween = TweenService:Create(btn, colorInfo, {
				TextColor3 = targetColor,
			})
			trackTween(colorTween)
			colorTween:Play()
		end
	end

	-- Wire click handlers
	for i, btn in segmentButtons do
		local conn = btn.MouseButton1Click:Connect(function()
			if currentIndex ~= i then
				selectIndex(i)
				if config.OnChanged then
					config.OnChanged(i)
				end
			end
		end)
		table.insert(connections, conn)
	end

	-- Parent assignment
	if config.Parent then
		outerWrapper.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoSegmentedControl = {
		Container = outerWrapper,
		SetIndex = function(self: Types.MangoSegmentedControl, index: number)
			selectIndex(index)
		end,
		GetIndex = function(self: Types.MangoSegmentedControl): number
			return currentIndex
		end,
		Destroy = function(self: Types.MangoSegmentedControl)
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			outerWrapper:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoSearchBar"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")

local module = {}

function module.new(config: Types.MangoSearchBarConfig): Types.MangoSearchBar
	local theme = config.Theme

	-- Resolve config values
	local size = resolve(config.Size, nil, UDim2.new(0, 280, 0, 36)) :: UDim2
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local placeholder = resolve(config.Placeholder, nil, "Search") :: string

	-- Theme values
	local primaryText = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local placeholderColor = resolve(nil, theme and theme.SearchBarPlaceholderColor, Color3.fromRGB(142, 142, 147)) :: Color3
	local bgTransparency = resolve(nil, theme and theme.SearchBarBackgroundTransparency, 0.88) :: number

	-- State
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Container via MangoGlassFrame (pill, LightweightMode)
	local glassFrame = MangoGlassFrame.new({
		Size = size,
		Position = position,
		AnchorPoint = anchorPoint,
		CornerRadius = UDim.new(0, 999),
		BackgroundTransparency = bgTransparency,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 2,
		ShadowSpread = 4,
		ShadowOffsetY = 1,
		LightweightMode = true,
	})

	local container = glassFrame.Container
	local glassSurface = glassFrame.GlassSurface

	-- UIPadding inside GlassSurface
	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)
	padding.Parent = glassSurface

	-- Search icon (left side)
	local searchIcon = Instance.new("TextLabel")
	searchIcon.Name = "SearchIcon"
	searchIcon.Size = UDim2.new(0, 20, 0, 20)
	searchIcon.Position = UDim2.new(0, 0, 0.5, 0)
	searchIcon.AnchorPoint = Vector2.new(0, 0.5)
	searchIcon.BackgroundTransparency = 1
	searchIcon.BorderSizePixel = 0
	searchIcon.Font = Enum.Font.Gotham
	searchIcon.TextSize = 16
	searchIcon.Text = "\240\159\148\141" -- magnifying glass emoji
	searchIcon.TextColor3 = placeholderColor
	searchIcon.ZIndex = 10
	searchIcon.Parent = glassSurface

	-- InputBox (fills remaining width between icon and clear button)
	local inputBox = Instance.new("TextBox")
	inputBox.Name = "InputBox"
	inputBox.Size = UDim2.new(1, -48, 1, 0)
	inputBox.Position = UDim2.new(0, 24, 0, 0)
	inputBox.BackgroundTransparency = 1
	inputBox.BorderSizePixel = 0
	inputBox.Font = Enum.Font.GothamMedium
	inputBox.TextSize = 14
	inputBox.TextColor3 = primaryText
	inputBox.PlaceholderText = placeholder
	inputBox.PlaceholderColor3 = placeholderColor
	inputBox.Text = ""
	inputBox.ClearTextOnFocus = false
	inputBox.TextXAlignment = Enum.TextXAlignment.Left
	inputBox.ZIndex = 10
	inputBox.Parent = glassSurface

	-- Clear button (right side, visible when text is not empty)
	local clearFrame = Instance.new("Frame")
	clearFrame.Name = "ClearFrame"
	clearFrame.Size = UDim2.new(0, 20, 0, 20)
	clearFrame.Position = UDim2.new(1, -4, 0.5, 0)
	clearFrame.AnchorPoint = Vector2.new(1, 0.5)
	clearFrame.BackgroundTransparency = 1
	clearFrame.BorderSizePixel = 0
	clearFrame.Visible = false
	clearFrame.ZIndex = 10
	clearFrame.Parent = glassSurface

	local clearLabel = Instance.new("TextLabel")
	clearLabel.Name = "ClearLabel"
	clearLabel.Size = UDim2.new(1, 0, 1, 0)
	clearLabel.BackgroundTransparency = 1
	clearLabel.BorderSizePixel = 0
	clearLabel.Font = Enum.Font.GothamBold
	clearLabel.TextSize = 10
	clearLabel.Text = "X"
	clearLabel.TextColor3 = placeholderColor
	clearLabel.ZIndex = 10
	clearLabel.Parent = clearFrame

	local clearHitArea = Instance.new("TextButton")
	clearHitArea.Name = "HitArea"
	clearHitArea.Size = UDim2.new(1, 8, 1, 8)
	clearHitArea.AnchorPoint = Vector2.new(0.5, 0.5)
	clearHitArea.Position = UDim2.new(0.5, 0, 0.5, 0)
	clearHitArea.BackgroundTransparency = 1
	clearHitArea.Text = ""
	clearHitArea.BorderSizePixel = 0
	clearHitArea.ZIndex = 100
	clearHitArea.AutoButtonColor = false
	clearHitArea.Parent = clearFrame

	-- Focus animation
	local originalBgTransparency = glassSurface.BackgroundTransparency

	local focusedConn = inputBox.Focused:Connect(function()
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(glassSurface, tweenInfo, {
			BackgroundTransparency = math.clamp(originalBgTransparency - 0.05, 0, 1),
		})
		trackTween(tween)
		tween:Play()
	end)
	table.insert(connections, focusedConn)

	local focusLostConn = inputBox.FocusLost:Connect(function(enterPressed: boolean)
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(glassSurface, tweenInfo, {
			BackgroundTransparency = originalBgTransparency,
		})
		trackTween(tween)
		tween:Play()

		if config.OnSubmit then
			config.OnSubmit(inputBox.Text)
		end
	end)
	table.insert(connections, focusLostConn)

	-- Text changed: show/hide clear button, fire callback
	local textChangedConn = inputBox:GetPropertyChangedSignal("Text"):Connect(function()
		clearFrame.Visible = inputBox.Text ~= ""
		if config.OnTextChanged then
			config.OnTextChanged(inputBox.Text)
		end
	end)
	table.insert(connections, textChangedConn)

	-- Clear button click
	local clearConn = clearHitArea.MouseButton1Click:Connect(function()
		inputBox.Text = ""
		if config.OnTextChanged then
			config.OnTextChanged("")
		end
		inputBox:CaptureFocus()
	end)
	table.insert(connections, clearConn)

	-- Parent assignment
	if config.Parent then
		container.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoSearchBar = {
		Container = container,
		GetText = function(self: Types.MangoSearchBar): string
			return inputBox.Text
		end,
		SetText = function(self: Types.MangoSearchBar, text: string)
			inputBox.Text = text
		end,
		Focus = function(self: Types.MangoSearchBar)
			inputBox:CaptureFocus()
		end,
		Destroy = function(self: Types.MangoSearchBar)
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoTextField"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")

local module = {}

function module.new(config: Types.MangoTextFieldConfig): Types.MangoTextField
	local theme = config.Theme

	-- Resolve config values
	local size = resolve(config.Size, nil, UDim2.new(0, 280, 0, 40)) :: UDim2
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local placeholder = resolve(config.Placeholder, nil, "") :: string
	local initialText = resolve(config.InitialText, nil, "") :: string

	-- Theme values
	local primaryText = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local secondaryText = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3
	local bgColor = resolve(nil, theme and theme.BackgroundColor3, Color3.fromRGB(255, 255, 255)) :: Color3
	local bgTransparency = resolve(nil, theme and theme.TextFieldBackgroundTransparency, 0.92) :: number
	local borderColor = resolve(nil, theme and theme.TextFieldBorderColor, Color3.fromRGB(200, 200, 205)) :: Color3
	local focusBorderColor = resolve(nil, theme and theme.TextFieldFocusBorderColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local shadowColor = resolve(nil, theme and theme.ShadowColor, Color3.fromRGB(0, 0, 0)) :: Color3

	-- State
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Container
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("TextField")
	container.Size = size
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	-- Shadow visibility
	local shadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean

	-- Shadow layer 1 (outer)
	local shadow1 = Instance.new("Frame")
	shadow1.Name = "ShadowLayer1"
	shadow1.AnchorPoint = Vector2.new(0.5, 0.5)
	shadow1.Position = UDim2.new(0.5, 0, 0.5, 1)
	shadow1.Size = UDim2.new(1, 8, 1, 8)
	shadow1.BackgroundColor3 = shadowColor
	shadow1.BackgroundTransparency = 0.92
	shadow1.BorderSizePixel = 0
	shadow1.ZIndex = 0
	shadow1.Visible = shadowEnabled
	shadow1.Parent = container

	local shadow1Corner = Instance.new("UICorner")
	shadow1Corner.CornerRadius = UDim.new(0, 12)
	shadow1Corner.Parent = shadow1

	-- Shadow layer 2 (inner)
	local shadow2 = Instance.new("Frame")
	shadow2.Name = "ShadowLayer2"
	shadow2.AnchorPoint = Vector2.new(0.5, 0.5)
	shadow2.Position = UDim2.new(0.5, 0, 0.5, 0.5)
	shadow2.Size = UDim2.new(1, 4, 1, 4)
	shadow2.BackgroundColor3 = shadowColor
	shadow2.BackgroundTransparency = 0.88
	shadow2.BorderSizePixel = 0
	shadow2.ZIndex = 0
	shadow2.Visible = shadowEnabled
	shadow2.Parent = container

	local shadow2Corner = Instance.new("UICorner")
	shadow2Corner.CornerRadius = UDim.new(0, 11)
	shadow2Corner.Parent = shadow2

	-- FieldFrame (rounded rectangle)
	local fieldFrame = Instance.new("Frame")
	fieldFrame.Name = "FieldFrame"
	fieldFrame.Size = UDim2.new(1, 0, 1, 0)
	fieldFrame.BackgroundColor3 = bgColor
	fieldFrame.BackgroundTransparency = bgTransparency
	fieldFrame.BorderSizePixel = 0
	fieldFrame.ZIndex = 1
	fieldFrame.ClipsDescendants = true
	fieldFrame.Parent = container

	local fieldCorner = Instance.new("UICorner")
	fieldCorner.CornerRadius = UDim.new(0, 10)
	fieldCorner.Parent = fieldFrame

	-- UIStroke (border)
	local fieldStroke = Instance.new("UIStroke")
	fieldStroke.Name = "FieldStroke"
	fieldStroke.Color = borderColor
	fieldStroke.Thickness = 1
	fieldStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	fieldStroke.Parent = fieldFrame

	-- UIPadding
	local fieldPadding = Instance.new("UIPadding")
	fieldPadding.PaddingLeft = UDim.new(0, 12)
	fieldPadding.PaddingRight = UDim.new(0, 12)
	fieldPadding.Parent = fieldFrame

	-- InputBox
	local inputBox = Instance.new("TextBox")
	inputBox.Name = "InputBox"
	inputBox.Size = UDim2.new(1, -20, 1, 0)
	inputBox.Position = UDim2.new(0, 0, 0, 0)
	inputBox.BackgroundTransparency = 1
	inputBox.BorderSizePixel = 0
	inputBox.Font = Enum.Font.GothamMedium
	inputBox.TextSize = 14
	inputBox.TextColor3 = primaryText
	inputBox.PlaceholderText = placeholder
	inputBox.PlaceholderColor3 = secondaryText
	inputBox.Text = initialText
	inputBox.ClearTextOnFocus = false
	inputBox.TextXAlignment = Enum.TextXAlignment.Left
	inputBox.ZIndex = 10
	inputBox.Parent = fieldFrame

	-- Masked mode (password field)
	local isMasked = resolve(config.Masked, nil, false) :: boolean
	local showingMask = isMasked
	local realText: string = initialText

	local eyeFrame: Frame? = nil
	local eyeLabel: TextLabel? = nil

	if isMasked then
		-- Adjust input box width to make room for eye button
		inputBox.Size = UDim2.new(1, -40, 1, 0)

		-- Eye toggle button
		eyeFrame = Instance.new("Frame")
		eyeFrame.Name = "EyeFrame"
		eyeFrame.Size = UDim2.new(0, 16, 0, 16)
		eyeFrame.Position = UDim2.new(1, -22, 0.5, 0)
		eyeFrame.AnchorPoint = Vector2.new(1, 0.5)
		eyeFrame.BackgroundTransparency = 1
		eyeFrame.BorderSizePixel = 0
		eyeFrame.ZIndex = 10
		eyeFrame.Parent = fieldFrame

		eyeLabel = Instance.new("TextLabel")
		eyeLabel.Name = "EyeLabel"
		eyeLabel.Size = UDim2.new(1, 0, 1, 0)
		eyeLabel.BackgroundTransparency = 1
		eyeLabel.BorderSizePixel = 0
		eyeLabel.Font = Enum.Font.Gotham
		eyeLabel.TextSize = 14
		eyeLabel.Text = "\240\159\145\129" -- eye emoji
		eyeLabel.TextColor3 = secondaryText
		eyeLabel.ZIndex = 10
		eyeLabel.Parent = eyeFrame

		local eyeHitArea = Instance.new("TextButton")
		eyeHitArea.Name = "EyeHitArea"
		eyeHitArea.Size = UDim2.new(1, 8, 1, 8)
		eyeHitArea.AnchorPoint = Vector2.new(0.5, 0.5)
		eyeHitArea.Position = UDim2.new(0.5, 0, 0.5, 0)
		eyeHitArea.BackgroundTransparency = 1
		eyeHitArea.Text = ""
		eyeHitArea.BorderSizePixel = 0
		eyeHitArea.ZIndex = 100
		eyeHitArea.AutoButtonColor = false
		eyeHitArea.Parent = eyeFrame

		-- Toggle mask on eye click
		local eyeConn = eyeHitArea.MouseButton1Click:Connect(function()
			showingMask = not showingMask
			if eyeLabel then
				eyeLabel.Text = if showingMask then "\240\159\145\129" else "\240\159\145\129\226\128\141\240\159\151\168"
			end
			-- Update display
			if showingMask then
				inputBox.Text = string.rep("\226\151\143", utf8.len(realText) or 0) -- bullet character
			else
				inputBox.Text = realText
			end
		end)
		table.insert(connections, eyeConn)

		-- Set initial masked display
		if initialText ~= "" then
			realText = initialText
			inputBox.Text = string.rep("\226\151\143", utf8.len(initialText) or 0)
		end
	end

	-- Clear button (right side, visible when text is not empty)
	local clearFrame = Instance.new("Frame")
	clearFrame.Name = "ClearFrame"
	clearFrame.Size = UDim2.new(0, 16, 0, 16)
	clearFrame.Position = UDim2.new(1, -4, 0.5, 0)
	clearFrame.AnchorPoint = Vector2.new(1, 0.5)
	clearFrame.BackgroundTransparency = 1
	clearFrame.BorderSizePixel = 0
	clearFrame.Visible = initialText ~= ""
	clearFrame.ZIndex = 10
	clearFrame.Parent = fieldFrame

	local clearLabel = Instance.new("TextLabel")
	clearLabel.Name = "ClearLabel"
	clearLabel.Size = UDim2.new(1, 0, 1, 0)
	clearLabel.BackgroundTransparency = 1
	clearLabel.BorderSizePixel = 0
	clearLabel.Font = Enum.Font.GothamBold
	clearLabel.TextSize = 10
	clearLabel.Text = "X"
	clearLabel.TextColor3 = secondaryText
	clearLabel.ZIndex = 10
	clearLabel.Parent = clearFrame

	local clearHitArea = Instance.new("TextButton")
	clearHitArea.Name = "HitArea"
	clearHitArea.Size = UDim2.new(1, 8, 1, 8)
	clearHitArea.AnchorPoint = Vector2.new(0.5, 0.5)
	clearHitArea.Position = UDim2.new(0.5, 0, 0.5, 0)
	clearHitArea.BackgroundTransparency = 1
	clearHitArea.Text = ""
	clearHitArea.BorderSizePixel = 0
	clearHitArea.ZIndex = 100
	clearHitArea.AutoButtonColor = false
	clearHitArea.Parent = clearFrame

	-- Focus: animate UIStroke color
	local focusedConn = inputBox.Focused:Connect(function()
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(fieldStroke, tweenInfo, {
			Color = focusBorderColor,
		})
		trackTween(tween)
		tween:Play()
	end)
	table.insert(connections, focusedConn)

	local focusLostConn = inputBox.FocusLost:Connect(function(enterPressed: boolean)
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(fieldStroke, tweenInfo, {
			Color = borderColor,
		})
		trackTween(tween)
		tween:Play()

		if config.OnFocusLost then
			local reportText = if isMasked then realText else inputBox.Text
			config.OnFocusLost(reportText, enterPressed)
		end
	end)
	table.insert(connections, focusLostConn)

	-- Text changed: show/hide clear button, fire callback
	local isUpdatingMask = false
	local textChangedConn = inputBox:GetPropertyChangedSignal("Text"):Connect(function()
		if isMasked and not isUpdatingMask then
			isUpdatingMask = true
			local currentDisplay = inputBox.Text
			local prevLen = utf8.len(realText) or 0
			local currentLen = utf8.len(currentDisplay) or 0

			if currentLen > prevLen then
				-- Characters were added — extract new chars from the end
				local newChars = string.sub(currentDisplay, utf8.offset(currentDisplay, prevLen + 1) or (#currentDisplay + 1))
				realText = realText .. newChars
			elseif currentLen < prevLen then
				-- Characters were deleted
				local keepLen = currentLen
				if keepLen <= 0 then
					realText = ""
				else
					local endPos = utf8.offset(realText, keepLen + 1)
					realText = string.sub(realText, 1, (endPos or (#realText + 1)) - 1)
				end
			end

			if showingMask then
				inputBox.Text = string.rep("\226\151\143", utf8.len(realText) or 0)
			end
			isUpdatingMask = false
		end

		local displayText = if isMasked then realText else inputBox.Text
		clearFrame.Visible = displayText ~= ""
		if config.OnTextChanged then
			config.OnTextChanged(displayText)
		end
	end)
	table.insert(connections, textChangedConn)

	-- Clear button click
	local clearConn = clearHitArea.MouseButton1Click:Connect(function()
		if isMasked then
			realText = ""
		end
		inputBox.Text = ""
		if config.OnTextChanged then
			config.OnTextChanged("")
		end
		inputBox:CaptureFocus()
	end)
	table.insert(connections, clearConn)

	-- Parent assignment
	if config.Parent then
		container.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoTextField = {
		Container = container,
		GetText = function(self: Types.MangoTextField): string
			if isMasked then
				return realText
			end
			return inputBox.Text
		end,
		SetText = function(self: Types.MangoTextField, text: string)
			if isMasked then
				realText = text
				if showingMask then
					inputBox.Text = string.rep("\226\151\143", utf8.len(text) or 0)
				else
					inputBox.Text = text
				end
			else
				inputBox.Text = text
			end
		end,
		Focus = function(self: Types.MangoTextField)
			inputBox:CaptureFocus()
		end,
		Destroy = function(self: Types.MangoTextField)
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoEnvironmentLight"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")

local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local module = {}

type RegisteredFrame = {
	frame: Types.MangoGlassFrame,
	originalColor: Color3,
	originalSpecularColor: Color3?,
}

function module.new(config: Types.MangoEnvironmentLightConfig?): Types.MangoEnvironmentLight
	local cfg = config or {} :: Types.MangoEnvironmentLightConfig

	local updateAngleEveryFrame = resolve(cfg.UpdateAngleEveryFrame, nil, true) :: boolean
	local tintUpdateInterval = resolve(cfg.TintUpdateInterval, nil, 0.5) :: number
	local tintInfluence = resolve(cfg.TintInfluence, nil, 0.45) :: number
	local enabled = resolve(cfg.Enabled, nil, true) :: boolean

	local registeredFrames: {RegisteredFrame} = {}
	local renderStepName = MangoProtection.randomBindingName("MangoEnvLight")
	local lastTintUpdate: number = 0
	local currentSunAngle: number = 90
	local currentTint: Color3 = Color3.new(1, 1, 1)
	local lastAppliedAngle: number = -999

	-- Compute the sun/moon direction projected into screen-space gradient angle
	local function computeSunAngle(): number
		local camera = Workspace.CurrentCamera
		if not camera then
			return 90
		end

		local sunDir = Lighting:GetSunDirection()
		-- If sun is below horizon, try moon
		if sunDir.Y < -0.1 then
			sunDir = Lighting:GetMoonDirection()
		end

		-- Project into camera local space
		local localDir = camera.CFrame:VectorToObjectSpace(sunDir)
		-- Convert to gradient rotation angle
		-- localDir.X = right, localDir.Y = up
		local angle = (math.deg(math.atan2(-localDir.Y, localDir.X)) + 90) % 360
		return angle
	end

	-- Sample ambient/outdoor lighting for glass tint
	local function computeEnvironmentTint(): Color3
		local outdoor = Lighting.OutdoorAmbient
		local ambient = Lighting.Ambient
		local colorShiftTop = Lighting.ColorShift_Top

		-- Weighted blend: OutdoorAmbient * 0.5 + Ambient * 0.2 + ColorShift_Top * 0.3
		local r = outdoor.R * 0.5 + ambient.R * 0.2 + colorShiftTop.R * 0.3
		local g = outdoor.G * 0.5 + ambient.G * 0.2 + colorShiftTop.G * 0.3
		local b = outdoor.B * 0.5 + ambient.B * 0.2 + colorShiftTop.B * 0.3

		return Color3.new(math.clamp(r, 0, 1), math.clamp(g, 0, 1), math.clamp(b, 0, 1))
	end

	-- Apply tint to registered frames
	local function applyTint(tint: Color3)
		for _, entry in registeredFrames do
			local original = entry.originalColor
			local tinted = original:Lerp(tint, tintInfluence)
			entry.frame.GlassSurface.BackgroundColor3 = tinted
			-- Tint specular stroke at half influence
			local origSpecular = entry.originalSpecularColor
			if origSpecular then
				entry.frame.SpecularStroke.Color = origSpecular:Lerp(tint, tintInfluence * 0.5)
			end
		end
	end

	-- Main update function bound to RenderStep
	local function onRenderStep(_dt: number)
		if not enabled then
			return
		end

		-- Update sun angle every frame (or skip if disabled)
		if updateAngleEveryFrame then
			currentSunAngle = computeSunAngle()

			-- Only apply if angle changed significantly (caching threshold)
			if math.abs(currentSunAngle - lastAppliedAngle) >= 0.1 then
				lastAppliedAngle = currentSunAngle
				-- Update all registered frames' gradient rotations
				for _, entry in registeredFrames do
					entry.frame:SetLightDirection(currentSunAngle)
				end
			end
		end

		-- Throttle tint updates
		local now = tick()
		if now - lastTintUpdate >= tintUpdateInterval then
			lastTintUpdate = now
			currentTint = computeEnvironmentTint()
			applyTint(currentTint)
		end
	end

	-- Start the render step binding
	local function startBinding()
		pcall(function()
			RunService:UnbindFromRenderStep(renderStepName)
		end)
		RunService:BindToRenderStep(renderStepName, Enum.RenderPriority.Camera.Value + 2, onRenderStep)
	end

	-- Stop the render step binding
	local function stopBinding()
		pcall(function()
			RunService:UnbindFromRenderStep(renderStepName)
		end)
	end

	if enabled then
		startBinding()
	end

	local self: Types.MangoEnvironmentLight = {
		Enable = function(self: Types.MangoEnvironmentLight)
			if not enabled then
				enabled = true
				startBinding()
			end
		end,
		Disable = function(self: Types.MangoEnvironmentLight)
			if enabled then
				enabled = false
				stopBinding()
				-- Restore original colors
				for _, entry in registeredFrames do
					entry.frame.GlassSurface.BackgroundColor3 = entry.originalColor
					if entry.originalSpecularColor then
						entry.frame.SpecularStroke.Color = entry.originalSpecularColor
					end
				end
			end
		end,
		IsEnabled = function(self: Types.MangoEnvironmentLight): boolean
			return enabled
		end,
		GetSunAngle = function(self: Types.MangoEnvironmentLight): number
			return currentSunAngle
		end,
		GetEnvironmentTint = function(self: Types.MangoEnvironmentLight): Color3
			return currentTint
		end,
		RegisterGlassFrame = function(self: Types.MangoEnvironmentLight, frame: Types.MangoGlassFrame)
			-- Check if already registered
			for _, entry in registeredFrames do
				if entry.frame == frame then
					return
				end
			end
			table.insert(registeredFrames, {
				frame = frame,
				originalColor = frame.GlassSurface.BackgroundColor3,
				originalSpecularColor = frame.SpecularStroke.Color,
			})
		end,
		UnregisterGlassFrame = function(self: Types.MangoEnvironmentLight, frame: Types.MangoGlassFrame)
			for i, entry in registeredFrames do
				if entry.frame == frame then
					-- Restore original colors
					entry.frame.GlassSurface.BackgroundColor3 = entry.originalColor
					if entry.originalSpecularColor then
						entry.frame.SpecularStroke.Color = entry.originalSpecularColor
					end
					table.remove(registeredFrames, i)
					return
				end
			end
		end,
		Destroy = function(self: Types.MangoEnvironmentLight)
			enabled = false
			stopBinding()
			-- Restore original colors
			for _, entry in registeredFrames do
				entry.frame.GlassSurface.BackgroundColor3 = entry.originalColor
				if entry.originalSpecularColor then
					entry.frame.SpecularStroke.Color = entry.originalSpecularColor
				end
			end
			table.clear(registeredFrames)
		end,
	}

	return self
end

return module

end

_modules["MangoButton"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoHaptics = _require("MangoHaptics")
local resolve = Themes.resolve
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

local module = {}

function module.new(config: Types.MangoButtonConfig): Types.MangoButton
	local theme = config.Theme

	-- Resolve config values with nil-safe helper
	local textSize = resolve(config.TextSize, nil, 16) :: number
	local font = Enum.Font.GothamBold
	local text = resolve(config.Text, nil, "Button") :: string

	-- Button-specific opacity: more opaque than panels for readability
	local buttonTransparency = resolve(config.BackgroundTransparency, theme and theme.ButtonBackgroundTransparency, 0.65) :: number

	-- Auto-size: measure text and add padding if no explicit Size given
	local size: UDim2
	if config.Size then
		size = config.Size
	else
		local textBounds = TextService:GetTextSize(text, textSize, font, Vector2.new(1000, 1000))
		size = UDim2.new(0, textBounds.X + 24, 0, textBounds.Y + 16)
	end

	-- Create MangoGlassFrame with pill shape (CornerRadius = 999)
	-- Button-specific shadow: tighter spread + offset to avoid boxy look on small pills
	local glassFrame = MangoGlassFrame.new({
		Size = size,
		Position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2,
		AnchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2,
		CornerRadius = UDim.new(0, 999),
		BackgroundTransparency = buttonTransparency,
		Theme = config.Theme,
		ShadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean,
		ShadowLayerCount = 2,
		ShadowSpread = 5,
		ShadowOffsetY = 1,
		LightweightMode = true,
		Parent = config.Parent,
	})

	-- UIScale on Container for press animation
	local uiScale = Instance.new("UIScale")
	uiScale.Scale = 1
	uiScale.Parent = glassFrame.Container

	-- Directional specular on buttons — softer fresnel for small pills, responds to light direction
	local fresnelStart = resolve(nil, theme and theme.FresnelStartTransparency, 0.25) :: number
	local fresnelMid = resolve(nil, theme and theme.FresnelMidTransparency, 0.50) :: number
	local fresnelMidPoint = resolve(nil, theme and theme.FresnelMidPoint, 0.35) :: number
	local fresnelEnd = resolve(nil, theme and theme.FresnelEndTransparency, 0.95) :: number
	glassFrame.SpecularGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, fresnelStart + 0.05),
		NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid + 0.05),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})

	-- TextLabel inside GlassSurface
	local textColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3

	local textLabel = Instance.new("TextLabel")
	textLabel.Name = "ButtonText"
	textLabel.Text = text
	textLabel.Font = font
	textLabel.TextSize = textSize
	textLabel.TextColor3 = textColor
	textLabel.BackgroundTransparency = 1
	textLabel.Size = UDim2.new(1, -16, 1, 0)
	textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	textLabel.TextXAlignment = Enum.TextXAlignment.Center
	textLabel.TextYAlignment = Enum.TextYAlignment.Center
	textLabel.TextTruncate = Enum.TextTruncate.AtEnd
	textLabel.BorderSizePixel = 0
	textLabel.ZIndex = 10
	textLabel.Parent = glassFrame.GlassSurface

	-- Transparent TextButton hit area on top of all glass layers for reliable input
	local hitArea = Instance.new("TextButton")
	hitArea.Name = "HitArea"
	hitArea.Size = UDim2.new(1, 0, 1, 0)
	hitArea.BackgroundTransparency = 1
	hitArea.Text = ""
	hitArea.BorderSizePixel = 0
	hitArea.ZIndex = 100
	hitArea.AutoButtonColor = false
	hitArea.Parent = glassFrame.GlassSurface

	-- Press animation
	local pressScale = resolve(nil, theme and theme.ButtonPressScale, 0.97) :: number
	local originalBgTransparency = glassFrame.GlassSurface.BackgroundTransparency
	local activeTweens: {Tween} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	local connections: {RBXScriptConnection} = {}
	local isHovering = false

	-- Hover animation: subtle scale-up + specular gradient shift on mouse enter
	local hoverEnterConn = hitArea.MouseEnter:Connect(function()
		isHovering = true
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
		local scaleTween = TweenService:Create(uiScale, tweenInfo, { Scale = 1.02 })
		trackTween(scaleTween)
		scaleTween:Play()
		local gradientTween = TweenService:Create(glassFrame.SpecularGradient, tweenInfo, {
			Offset = Vector2.new(0.02, 0.02),
		})
		trackTween(gradientTween)
		gradientTween:Play()
	end)
	table.insert(connections, hoverEnterConn)

	local hoverLeaveConn = hitArea.MouseLeave:Connect(function()
		isHovering = false
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
		local scaleTween = TweenService:Create(uiScale, tweenInfo, { Scale = 1 })
		trackTween(scaleTween)
		scaleTween:Play()
		local gradientTween = TweenService:Create(glassFrame.SpecularGradient, tweenInfo, {
			Offset = Vector2.new(0, 0),
		})
		trackTween(gradientTween)
		gradientTween:Play()
	end)
	table.insert(connections, hoverLeaveConn)

	local pressConn = hitArea.MouseButton1Down:Connect(function()
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(uiScale, tweenInfo, { Scale = pressScale })
		trackTween(tween)
		tween:Play()
		-- Opacity pulse: glass becomes more opaque on press
		local opacityTween = TweenService:Create(glassFrame.GlassSurface, tweenInfo, {
			BackgroundTransparency = math.clamp(originalBgTransparency - 0.04, 0, 1),
		})
		trackTween(opacityTween)
		opacityTween:Play()
	end)
	table.insert(connections, pressConn)

	local releaseConn = hitArea.MouseButton1Up:Connect(function()
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		-- Restore to hover scale if still hovering, otherwise back to 1.0
		local restoreScale = if isHovering then 1.02 else 1
		local tween = TweenService:Create(uiScale, tweenInfo, { Scale = restoreScale })
		trackTween(tween)
		tween:Play()
		-- Restore opacity
		local opacityTween = TweenService:Create(glassFrame.GlassSurface, tweenInfo, {
			BackgroundTransparency = originalBgTransparency,
		})
		trackTween(opacityTween)
		opacityTween:Play()
		-- Restore specular offset to hover state if still hovering
		local gradientOffset = if isHovering then Vector2.new(0.02, 0.02) else Vector2.new(0, 0)
		local gradientTween = TweenService:Create(glassFrame.SpecularGradient, tweenInfo, {
			Offset = gradientOffset,
		})
		trackTween(gradientTween)
		gradientTween:Play()
		MangoHaptics.light()
		if config.OnActivated then
			config.OnActivated()
		end
	end)
	table.insert(connections, releaseConn)

	-- Return typed table
	local self: Types.MangoButton = {
		Container = glassFrame.Container,
		GlassSurface = glassFrame.GlassSurface,
		TextLabel = textLabel,
		SetText = function(self: Types.MangoButton, newText: string)
			textLabel.Text = newText
		end,
		Destroy = function(self: Types.MangoButton)
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoNotification"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoProtection = _require("MangoProtection")
local resolve = Themes.resolve
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

local module = {}

function module.new(config: Types.MangoNotificationConfig): Types.MangoNotification
	local theme = config.Theme
	local title = resolve(config.Title, nil, "Notification") :: string
	local body = config.Body
	local icon = config.Icon
	local duration = resolve(config.Duration, nil, 5) :: number

	-- Theme-driven visual properties
	local primaryTextColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local secondaryTextColor = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3

	-- Notification type styling
	local notifType = config.Type
	local typeColors: {[string]: Color3} = {
		success = Color3.fromRGB(34, 197, 94),
		warning = Color3.fromRGB(245, 158, 11),
		error = Color3.fromRGB(239, 68, 68),
		info = Color3.fromRGB(59, 130, 246),
	}
	local typeIcons: {[string]: string} = {
		success = "\226\156\147", -- checkmark
		warning = "\226\154\160", -- warning sign
		error = "\226\156\149", -- x mark
		info = "\226\132\185", -- info sign
	}

	-- Measure text to calculate height
	local titleFont = Enum.Font.GothamBold
	local bodyFont = Enum.Font.Gotham
	local titleSize = 15
	local bodySize = 13
	local contentWidth = 400 - 28 -- 14px padding on each side
	local hasIcon = icon ~= nil and icon ~= ""

	-- Auto-set icon from type if no explicit icon
	if notifType and typeIcons[notifType] and not hasIcon then
		icon = typeIcons[notifType]
		hasIcon = true
	end

	if hasIcon then
		contentWidth = contentWidth - 48 -- 36px icon + 12px gap
	end

	local titleBounds = TextService:GetTextSize(title, titleSize, titleFont, Vector2.new(contentWidth, 1000))
	local totalHeight = 28 + titleBounds.Y -- 14px top + 14px bottom padding

	local bodyBounds: Vector2? = nil
	if body and body ~= "" then
		bodyBounds = TextService:GetTextSize(body, bodySize, bodyFont, Vector2.new(contentWidth, 1000))
		totalHeight = totalHeight + 2 + (bodyBounds :: Vector2).Y -- 2px gap
	end

	-- Account for action buttons height
	local actions = config.Actions
	if actions and #actions > 0 then
		totalHeight = totalHeight + 36
	end

	-- Clamp height
	totalHeight = math.clamp(totalHeight, 64, 160)

	-- State
	local isShowing = false
	local isDismissing = false
	local isDestroyed = false
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}
	local dismissThread: thread? = nil
	local positionTweens: {Tween} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function cancelPositionTweens()
		for _, tween in positionTweens do
			tween:Cancel()
		end
		table.clear(positionTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Determine parent: config.Parent or create a ScreenGui in PlayerGui
	local screenGui: ScreenGui? = nil
	local parentInstance: Instance
	if config.Parent then
		parentInstance = config.Parent
	else
		local gui = MangoProtection.createScreenGui({
			DisplayOrder = 100,
		})
		screenGui = gui
		parentInstance = gui
	end

	-- NotificationContainer (starts offscreen above)
	local notifContainer = Instance.new("Frame")
	notifContainer.Name = MangoProtection.randomName("Notification")
	notifContainer.Size = UDim2.new(0, 400, 0, totalHeight)
	notifContainer.AnchorPoint = Vector2.new(0.5, 0)
	notifContainer.Position = UDim2.new(0.5, 0, 0, -80)
	notifContainer.BackgroundTransparency = 1
	notifContainer.BorderSizePixel = 0
	notifContainer.Parent = parentInstance

	-- Glass frame inside
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 20),
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 4,
		ShadowOffsetY = 4,
		ShadowSpread = 12,
		LightweightMode = true,
		Parent = notifContainer,
	})

	-- Store target transparency for fade-in animation
	local targetBgTransparency = glassFrame.GlassSurface.BackgroundTransparency

	-- Accent stripe for typed notifications
	if notifType and typeColors[notifType] then
		local accentStripe = Instance.new("Frame")
		accentStripe.Name = "AccentStripe"
		accentStripe.Size = UDim2.new(0, 3, 1, -8)
		accentStripe.Position = UDim2.new(0, 4, 0, 4)
		accentStripe.BackgroundColor3 = typeColors[notifType]
		accentStripe.BackgroundTransparency = 0.1
		accentStripe.BorderSizePixel = 0
		accentStripe.ZIndex = 15
		accentStripe.Parent = glassFrame.GlassSurface

		local stripeCorner = Instance.new("UICorner")
		stripeCorner.CornerRadius = UDim.new(0, 2)
		stripeCorner.Parent = accentStripe
	end

	-- ContentFrame (isolates UIListLayout from glass frame internals like InnerEdgeFrame)
	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "ContentFrame"
	contentFrame.Size = UDim2.new(1, 0, 1, 0)
	contentFrame.BackgroundTransparency = 1
	contentFrame.BorderSizePixel = 0
	contentFrame.ZIndex = 10
	contentFrame.Parent = glassFrame.GlassSurface

	-- UIPadding on ContentFrame
	local padding = Instance.new("UIPadding")
	padding.PaddingTop = UDim.new(0, 14)
	padding.PaddingBottom = UDim.new(0, 14)
	padding.PaddingLeft = UDim.new(0, 14)
	padding.PaddingRight = UDim.new(0, 14)
	padding.Parent = contentFrame

	-- UIListLayout (Horizontal, 12px gap)
	local hLayout = Instance.new("UIListLayout")
	hLayout.FillDirection = Enum.FillDirection.Horizontal
	hLayout.Padding = UDim.new(0, 12)
	hLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	hLayout.SortOrder = Enum.SortOrder.LayoutOrder
	hLayout.Parent = contentFrame

	-- Icon (optional — supports both image IDs and text emoji from type icons)
	if hasIcon and icon then
		local isImageIcon = string.find(icon, "rbxassetid") ~= nil or string.find(icon, "rbxthumb") ~= nil
		if isImageIcon then
			local iconFrame = Instance.new("ImageLabel")
			iconFrame.Name = "IconFrame"
			iconFrame.Size = UDim2.new(0, 36, 0, 36)
			iconFrame.Image = icon
			iconFrame.BackgroundTransparency = 1
			iconFrame.BorderSizePixel = 0
			iconFrame.LayoutOrder = 1
			iconFrame.ZIndex = 10
			iconFrame.Parent = contentFrame

			local iconCorner = Instance.new("UICorner")
			iconCorner.CornerRadius = UDim.new(0, 8)
			iconCorner.Parent = iconFrame
		else
			-- Text-based icon (emoji from type or user-provided text)
			local iconContainer = Instance.new("Frame")
			iconContainer.Name = "IconFrame"
			iconContainer.Size = UDim2.new(0, 36, 0, 36)
			iconContainer.BackgroundColor3 = if notifType and typeColors[notifType] then typeColors[notifType] else Color3.fromRGB(200, 200, 200)
			iconContainer.BackgroundTransparency = 0.85
			iconContainer.BorderSizePixel = 0
			iconContainer.LayoutOrder = 1
			iconContainer.ZIndex = 10
			iconContainer.Parent = contentFrame

			local iconContainerCorner = Instance.new("UICorner")
			iconContainerCorner.CornerRadius = UDim.new(0, 8)
			iconContainerCorner.Parent = iconContainer

			local iconText = Instance.new("TextLabel")
			iconText.Name = "IconText"
			iconText.Size = UDim2.new(1, 0, 1, 0)
			iconText.BackgroundTransparency = 1
			iconText.BorderSizePixel = 0
			iconText.Font = Enum.Font.GothamBold
			iconText.TextSize = 18
			iconText.Text = icon
			iconText.TextColor3 = if notifType and typeColors[notifType] then typeColors[notifType] else primaryTextColor
			iconText.ZIndex = 10
			iconText.Parent = iconContainer
		end
	end

	-- TextContainer
	local textContainer = Instance.new("Frame")
	textContainer.Name = "TextContainer"
	textContainer.Size = UDim2.new(1, if hasIcon then -48 else 0, 1, 0)
	textContainer.BackgroundTransparency = 1
	textContainer.BorderSizePixel = 0
	textContainer.LayoutOrder = 2
	textContainer.ZIndex = 10
	textContainer.Parent = contentFrame

	-- Vertical layout inside TextContainer
	local vLayout = Instance.new("UIListLayout")
	vLayout.FillDirection = Enum.FillDirection.Vertical
	vLayout.Padding = UDim.new(0, 2)
	vLayout.SortOrder = Enum.SortOrder.LayoutOrder
	vLayout.Parent = textContainer

	-- TitleLabel
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Text = title
	titleLabel.Font = titleFont
	titleLabel.TextSize = titleSize
	titleLabel.TextColor3 = primaryTextColor
	titleLabel.BackgroundTransparency = 1
	titleLabel.Size = UDim2.new(1, 0, 0, titleBounds.Y)
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextYAlignment = Enum.TextYAlignment.Top
	titleLabel.TextWrapped = true
	titleLabel.BorderSizePixel = 0
	titleLabel.LayoutOrder = 1
	titleLabel.ZIndex = 10
	titleLabel.Parent = textContainer

	-- BodyLabel (optional)
	if body and body ~= "" and bodyBounds then
		local bodyLabel = Instance.new("TextLabel")
		bodyLabel.Name = "BodyLabel"
		bodyLabel.Text = body
		bodyLabel.Font = bodyFont
		bodyLabel.TextSize = bodySize
		bodyLabel.TextColor3 = secondaryTextColor
		bodyLabel.BackgroundTransparency = 1
		bodyLabel.Size = UDim2.new(1, 0, 0, (bodyBounds :: Vector2).Y)
		bodyLabel.TextXAlignment = Enum.TextXAlignment.Left
		bodyLabel.TextYAlignment = Enum.TextYAlignment.Top
		bodyLabel.TextWrapped = true
		bodyLabel.BorderSizePixel = 0
		bodyLabel.LayoutOrder = 2
		bodyLabel.ZIndex = 10
		bodyLabel.Parent = textContainer
	end

	-- Forward-declared dismiss function (shared by action buttons, tap-to-dismiss, and self.Dismiss)
	local doDismiss: (() -> ())? = nil
	local doDestroy: (() -> ())? = nil

	local function performDismiss()
		if isDismissing or isDestroyed or not isShowing then
			return
		end
		isDismissing = true

		-- Cancel auto-dismiss thread
		if dismissThread then
			task.cancel(dismissThread)
			dismissThread = nil
		end

		cancelAllTweens()
		cancelPositionTweens()
		local tweenOut = TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		local slideTween = TweenService:Create(notifContainer, tweenOut, {
			Position = UDim2.new(0.5, 0, 0, -80),
		})
		trackTween(slideTween)
		slideTween:Play()
		slideTween.Completed:Once(function()
			if not isDestroyed then
				-- Set isDestroyed BEFORE callback to prevent re-entrancy
				isDestroyed = true
				if config.OnDismissed then
					config.OnDismissed()
				end
				-- Clean up
				if dismissThread then
					task.cancel(dismissThread)
					dismissThread = nil
				end
				cancelAllTweens()
				cancelPositionTweens()
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				glassFrame:Destroy()
				notifContainer:Destroy()
				if screenGui then
					screenGui:Destroy()
				end
			end
		end)
	end

	doDismiss = performDismiss

	-- Action buttons
	if actions and #actions > 0 then
		local actionsRow = Instance.new("Frame")
		actionsRow.Name = "ActionsRow"
		actionsRow.Size = UDim2.new(1, 0, 0, 28)
		actionsRow.BackgroundTransparency = 1
		actionsRow.BorderSizePixel = 0
		actionsRow.LayoutOrder = 3
		actionsRow.ZIndex = 10
		actionsRow.Parent = textContainer

		local actionsLayout = Instance.new("UIListLayout")
		actionsLayout.FillDirection = Enum.FillDirection.Horizontal
		actionsLayout.Padding = UDim.new(0, 8)
		actionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
		actionsLayout.Parent = actionsRow

		for i, action in actions do
			local actionBtn = Instance.new("TextButton")
			actionBtn.Name = "Action" .. i
			actionBtn.Size = UDim2.new(0, 70, 0, 28)
			actionBtn.BackgroundColor3 = if action.Style == "cancel" then Color3.fromRGB(200, 200, 205) else (notifType and typeColors[notifType] or Color3.fromRGB(0, 122, 255))
			actionBtn.BackgroundTransparency = 0.75
			actionBtn.BorderSizePixel = 0
			actionBtn.Font = if action.Style == "cancel" then Enum.Font.GothamMedium else Enum.Font.GothamBold
			actionBtn.TextSize = 12
			actionBtn.Text = action.Text
			actionBtn.TextColor3 = if action.Style == "cancel" then secondaryTextColor else primaryTextColor
			actionBtn.AutoButtonColor = false
			actionBtn.ZIndex = 10
			actionBtn.LayoutOrder = i
			actionBtn.Parent = actionsRow

			local btnCorner = Instance.new("UICorner")
			btnCorner.CornerRadius = UDim.new(0, 999)
			btnCorner.Parent = actionBtn

			local btnConn = actionBtn.MouseButton1Click:Connect(function()
				if action.Callback then
					action.Callback()
				end
				performDismiss()
			end)
			table.insert(connections, btnConn)
		end
	end

	-- Hit area for tap-to-dismiss (transparent TextButton for reliable input on transparent container)
	local dismissHitArea = Instance.new("TextButton")
	dismissHitArea.Name = "DismissHitArea"
	dismissHitArea.Size = UDim2.new(1, 0, 1, 0)
	dismissHitArea.BackgroundTransparency = 1
	dismissHitArea.BorderSizePixel = 0
	dismissHitArea.Text = ""
	dismissHitArea.AutoButtonColor = false
	dismissHitArea.ZIndex = 50
	dismissHitArea.Parent = notifContainer

	-- Tap to dismiss
	local tapConn = dismissHitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			performDismiss()
		end
	end)
	table.insert(connections, tapConn)

	-- Return table
	local self: Types.MangoNotification = {
		Container = notifContainer,
		Show = function(self: Types.MangoNotification)
			if isShowing or isDestroyed then
				return
			end
			isShowing = true

			-- Start with glass surface fully transparent for fade-in
			glassFrame.GlassSurface.BackgroundTransparency = 1

			-- Spring tween to visible position
			cancelAllTweens()
			local springInfo = TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local slideTween = TweenService:Create(notifContainer, springInfo, {
				Position = UDim2.new(0.5, 0, 0, 16),
			})
			trackTween(slideTween)
			slideTween:Play()

			-- Fade in glass surface
			local fadeInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local fadeTween = TweenService:Create(glassFrame.GlassSurface, fadeInfo, {
				BackgroundTransparency = targetBgTransparency,
			})
			trackTween(fadeTween)
			fadeTween:Play()

			-- Auto-dismiss after duration (0 = no auto-dismiss)
			if duration > 0 then
				dismissThread = task.delay(duration, function()
					if not isDismissing and not isDestroyed and isShowing then
						performDismiss()
					end
				end)
			end
		end,
		Dismiss = function(self: Types.MangoNotification)
			performDismiss()
		end,
		SetPosition = function(self: Types.MangoNotification, position: UDim2)
			if isDestroyed or isDismissing then
				return
			end
			cancelPositionTweens()
			local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local posTween = TweenService:Create(notifContainer, tweenInfo, {
				Position = position,
			})
			table.insert(positionTweens, posTween)
			posTween:Play()
		end,
		GetHeight = function(self: Types.MangoNotification): number
			return totalHeight
		end,
		Destroy = function(self: Types.MangoNotification)
			if isDestroyed then
				return
			end
			isDestroyed = true

			-- Cancel auto-dismiss thread
			if dismissThread then
				task.cancel(dismissThread)
				dismissThread = nil
			end

			cancelAllTweens()
			cancelPositionTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
			notifContainer:Destroy()
			if screenGui then
				screenGui:Destroy()
			end
		end,
	}

	return self
end

return module

end

_modules["MangoBadge"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TextService = game:GetService("TextService")

local module = {}

function module.new(config: Types.MangoBadgeConfig): Types.MangoBadge
	local theme = config.Theme

	local textSize = resolve(config.TextSize, nil, 12) :: number
	local font = Enum.Font.GothamBold
	local text = resolve(config.Text, nil, "Badge") :: string
	local textColor = resolve(config.TextColor, theme and theme.BadgeTextColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local bgColor = resolve(config.BackgroundColor, theme and theme.BadgeBackgroundColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local bgTransparency = resolve(config.BackgroundTransparency, theme and theme.BadgeBackgroundTransparency, 0.15) :: number

	-- Measure text and add padding (16px horizontal + 8px vertical)
	local textBounds = TextService:GetTextSize(text, textSize, font, Vector2.new(1000, 1000))
	local badgeWidth = textBounds.X + 16
	local badgeHeight = textBounds.Y + 8

	-- Create MangoGlassFrame with pill shape, lightweight for small element
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(0, badgeWidth, 0, badgeHeight),
		Position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2,
		AnchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2,
		CornerRadius = UDim.new(0, 999),
		BackgroundColor3 = bgColor,
		BackgroundTransparency = bgTransparency,
		ShadowEnabled = true,
		ShadowLayerCount = 1,
		ShadowSpread = 3,
		ShadowOffsetY = 1,
		LightweightMode = true,
		Theme = config.Theme,
		Parent = config.Parent,
	})

	-- TextLabel inside GlassSurface
	local textLabel = Instance.new("TextLabel")
	textLabel.Name = "BadgeText"
	textLabel.Text = text
	textLabel.Font = font
	textLabel.TextSize = textSize
	textLabel.TextColor3 = textColor
	textLabel.BackgroundTransparency = 1
	textLabel.Size = UDim2.new(1, 0, 1, 0)
	textLabel.TextXAlignment = Enum.TextXAlignment.Center
	textLabel.TextYAlignment = Enum.TextYAlignment.Center
	textLabel.BorderSizePixel = 0
	textLabel.ZIndex = 10
	textLabel.Parent = glassFrame.GlassSurface

	local self: Types.MangoBadge = {
		Container = glassFrame.Container,
		SetText = function(self: Types.MangoBadge, newText: string)
			textLabel.Text = newText
			-- Re-measure and resize container
			local newBounds = TextService:GetTextSize(newText, textSize, font, Vector2.new(1000, 1000))
			local newWidth = newBounds.X + 16
			local newHeight = newBounds.Y + 8
			glassFrame.Container.Size = UDim2.new(0, newWidth, 0, newHeight)
			glassFrame.GlassSurface.Size = UDim2.new(1, 0, 1, 0)
		end,
		Destroy = function(self: Types.MangoBadge)
			glassFrame:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoSkeleton"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoShimmer = _require("MangoShimmer")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")

local module = {}

function module.new(config: Types.MangoSkeletonConfig): Types.MangoSkeleton
	local theme = config.Theme
	local bgColor = resolve(nil, theme and theme.SkeletonBackgroundColor, Color3.fromRGB(230, 230, 235)) :: Color3
	local bgTransparency = resolve(nil, theme and theme.SkeletonBackgroundTransparency, 0.50) :: number
	local cornerRadius = resolve(config.CornerRadius, nil, UDim.new(0, 8)) :: UDim

	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Skeleton")
	container.Size = resolve(config.Size, nil, UDim2.new(0, 100, 0, 20)) :: UDim2
	container.Position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	container.AnchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	container.BackgroundColor3 = bgColor
	container.BackgroundTransparency = bgTransparency
	container.BorderSizePixel = 0

	local corner = Instance.new("UICorner")
	corner.CornerRadius = cornerRadius
	corner.Parent = container

	-- Apply shimmer overlay
	local shimmer = MangoShimmer.new({
		Target = container,
		Theme = theme,
		Enabled = true,
	})

	if config.Parent then
		container.Parent = config.Parent
	end

	local self: Types.MangoSkeleton = {
		Container = container,
		Destroy = function(self: Types.MangoSkeleton)
			shimmer:Destroy()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoStepper"] = function()


local TweenService = game:GetService("TweenService")

local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")

local module = {}

function module.new(config: Types.MangoStepperConfig): Types.MangoStepper
	local theme = config.Theme

	local initialValue = resolve(config.InitialValue, nil, 0) :: number
	local minValue = resolve(config.Min, nil, 0) :: number
	local maxValue = resolve(config.Max, nil, 100) :: number
	local stepSize = resolve(config.Step, nil, 1) :: number
	local bgTransparency = resolve(nil, theme and theme.StepperBackgroundTransparency, 0.80) :: number

	local currentValue = math.clamp(initialValue, minValue, maxValue)

	-- Create MangoGlassFrame (pill, LightweightMode)
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(0, 120, 0, 36),
		Position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2,
		AnchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2,
		CornerRadius = UDim.new(0, 999),
		BackgroundTransparency = bgTransparency,
		Theme = theme,
		ShadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean,
		ShadowLayerCount = 2,
		ShadowSpread = 4,
		ShadowOffsetY = 1,
		LightweightMode = true,
		Parent = config.Parent,
	})

	local textColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3

	-- Left separator (1px line between minus and value)
	local leftSep = Instance.new("Frame")
	leftSep.Name = "LeftSeparator"
	leftSep.Size = UDim2.new(0, 1, 0.6, 0)
	leftSep.Position = UDim2.new(1 / 3, 0, 0.2, 0)
	leftSep.BackgroundColor3 = textColor
	leftSep.BackgroundTransparency = 0.75
	leftSep.BorderSizePixel = 0
	leftSep.ZIndex = 10
	leftSep.Parent = glassFrame.GlassSurface

	-- Right separator (1px line between value and plus)
	local rightSep = Instance.new("Frame")
	rightSep.Name = "RightSeparator"
	rightSep.Size = UDim2.new(0, 1, 0.6, 0)
	rightSep.Position = UDim2.new(2 / 3, 0, 0.2, 0)
	rightSep.BackgroundColor3 = textColor
	rightSep.BackgroundTransparency = 0.75
	rightSep.BorderSizePixel = 0
	rightSep.ZIndex = 10
	rightSep.Parent = glassFrame.GlassSurface

	-- Minus button (left third)
	local minusButton = Instance.new("TextButton")
	minusButton.Name = "MinusButton"
	minusButton.Size = UDim2.new(1 / 3, 0, 1, 0)
	minusButton.Position = UDim2.new(0, 0, 0, 0)
	minusButton.BackgroundTransparency = 1
	minusButton.Text = "-"
	minusButton.Font = Enum.Font.GothamBold
	minusButton.TextSize = 18
	minusButton.TextColor3 = textColor
	minusButton.BorderSizePixel = 0
	minusButton.ZIndex = 100
	minusButton.AutoButtonColor = false
	minusButton.Parent = glassFrame.GlassSurface

	-- UIScale for minus press animation
	local minusScale = Instance.new("UIScale")
	minusScale.Scale = 1
	minusScale.Parent = minusButton

	-- Value label (center third)
	local valueLabel = Instance.new("TextLabel")
	valueLabel.Name = "ValueLabel"
	valueLabel.Size = UDim2.new(1 / 3, 0, 1, 0)
	valueLabel.Position = UDim2.new(1 / 3, 0, 0, 0)
	valueLabel.BackgroundTransparency = 1
	valueLabel.Text = tostring(currentValue)
	valueLabel.Font = Enum.Font.GothamMedium
	valueLabel.TextSize = 14
	valueLabel.TextColor3 = textColor
	valueLabel.TextXAlignment = Enum.TextXAlignment.Center
	valueLabel.TextYAlignment = Enum.TextYAlignment.Center
	valueLabel.BorderSizePixel = 0
	valueLabel.ZIndex = 10
	valueLabel.Parent = glassFrame.GlassSurface

	-- Plus button (right third)
	local plusButton = Instance.new("TextButton")
	plusButton.Name = "PlusButton"
	plusButton.Size = UDim2.new(1 / 3, 0, 1, 0)
	plusButton.Position = UDim2.new(2 / 3, 0, 0, 0)
	plusButton.BackgroundTransparency = 1
	plusButton.Text = "+"
	plusButton.Font = Enum.Font.GothamBold
	plusButton.TextSize = 18
	plusButton.TextColor3 = textColor
	plusButton.BorderSizePixel = 0
	plusButton.ZIndex = 100
	plusButton.AutoButtonColor = false
	plusButton.Parent = glassFrame.GlassSurface

	-- UIScale for plus press animation
	local plusScale = Instance.new("UIScale")
	plusScale.Scale = 1
	plusScale.Parent = plusButton

	-- State
	local connections: {RBXScriptConnection} = {}
	local activeTweens: {Tween} = {}
	local repeatThread: thread? = nil

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	local function updateDisableStates()
		minusButton.TextTransparency = if currentValue <= minValue then 0.5 else 0
		plusButton.TextTransparency = if currentValue >= maxValue then 0.5 else 0
	end

	local function updateValue(newValue: number)
		newValue = math.clamp(newValue, minValue, maxValue)
		-- Snap to step increments
		newValue = math.round((newValue - minValue) / stepSize) * stepSize + minValue
		newValue = math.clamp(newValue, minValue, maxValue)
		if newValue == currentValue then
			return
		end
		currentValue = newValue
		valueLabel.Text = tostring(currentValue)
		updateDisableStates()
		if config.OnChanged then
			config.OnChanged(currentValue)
		end
	end

	local function playPressAnim(scale: UIScale)
		local downInfo = TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local downTween = TweenService:Create(scale, downInfo, { Scale = 0.92 })
		trackTween(downTween)
		downTween:Play()
	end

	local function playReleaseAnim(scale: UIScale)
		local upInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local upTween = TweenService:Create(scale, upInfo, { Scale = 1 })
		trackTween(upTween)
		upTween:Play()
	end

	local function stopRepeat()
		if repeatThread then
			task.cancel(repeatThread)
			repeatThread = nil
		end
	end

	local function startRepeat(delta: number)
		stopRepeat()
		repeatThread = task.delay(0.5, function()
			while true do
				updateValue(currentValue + delta)
				task.wait(0.1)
			end
		end)
	end

	-- Initialize disable states
	updateDisableStates()

	-- Minus button input
	local minusDownConn = minusButton.MouseButton1Down:Connect(function()
		if currentValue <= minValue then
			return
		end
		playPressAnim(minusScale)
		updateValue(currentValue - stepSize)
		startRepeat(-stepSize)
	end)
	table.insert(connections, minusDownConn)

	local minusUpConn = minusButton.MouseButton1Up:Connect(function()
		stopRepeat()
		playReleaseAnim(minusScale)
	end)
	table.insert(connections, minusUpConn)

	local minusLeaveConn = minusButton.MouseLeave:Connect(function()
		stopRepeat()
		playReleaseAnim(minusScale)
	end)
	table.insert(connections, minusLeaveConn)

	-- Plus button input
	local plusDownConn = plusButton.MouseButton1Down:Connect(function()
		if currentValue >= maxValue then
			return
		end
		playPressAnim(plusScale)
		updateValue(currentValue + stepSize)
		startRepeat(stepSize)
	end)
	table.insert(connections, plusDownConn)

	local plusUpConn = plusButton.MouseButton1Up:Connect(function()
		stopRepeat()
		playReleaseAnim(plusScale)
	end)
	table.insert(connections, plusUpConn)

	local plusLeaveConn = plusButton.MouseLeave:Connect(function()
		stopRepeat()
		playReleaseAnim(plusScale)
	end)
	table.insert(connections, plusLeaveConn)

	-- Return typed table
	local self: Types.MangoStepper = {
		Container = glassFrame.Container,
		SetValue = function(self: Types.MangoStepper, value: number)
			updateValue(value)
		end,
		GetValue = function(self: Types.MangoStepper): number
			return currentValue
		end,
		Destroy = function(self: Types.MangoStepper)
			stopRepeat()
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoTooltip"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

local module = {}

local function findScreenGui(instance: Instance): ScreenGui?
	local current: Instance? = instance
	while current do
		if current:IsA("ScreenGui") then
			return current :: ScreenGui
		end
		current = current.Parent
	end
	return nil
end

function module.new(config: Types.MangoTooltipConfig): Types.MangoTooltip
	local theme = config.Theme
	local target = config.Target
	local text = resolve(config.Text, nil, "Tooltip") :: string
	local textSize = resolve(config.TextSize, nil, 13) :: number
	local maxWidth = resolve(config.MaxWidth, nil, 200) :: number
	local delayTime = resolve(config.Delay, nil, 0.5) :: number
	local placement = resolve(config.Placement, nil, "auto") :: string
	local arrowSize = resolve(config.ArrowSize, nil, 8) :: number

	-- Theme-driven properties
	local bgTransparency = resolve(nil, theme and theme.TooltipBackgroundTransparency, 0.15) :: number
	local bgColor = resolve(nil, theme and theme.BackgroundColor3, Color3.fromRGB(255, 255, 255)) :: Color3
	local textColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3

	-- Padding
	local paddingH = 16
	local paddingV = 12

	-- Measure text
	local font = Enum.Font.Gotham
	local textBounds = TextService:GetTextSize(text, textSize, font, Vector2.new(maxWidth - paddingH, 1000))
	local tooltipWidth = math.min(textBounds.X + paddingH, maxWidth)
	local tooltipHeight = textBounds.Y + paddingV

	-- State
	local isVisible = false
	local isDestroyed = false
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}
	local delayThread: thread? = nil
	local currentPlacement = "top"

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Determine parent
	local parentGui: GuiObject
	if config.Parent then
		parentGui = config.Parent
	else
		local screenGui = findScreenGui(target)
		if screenGui then
			parentGui = screenGui :: any
		else
			parentGui = target.Parent :: GuiObject
		end
	end

	-- Glass frame for tooltip body
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(0, tooltipWidth, 0, tooltipHeight),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 8),
		BackgroundTransparency = bgTransparency,
		LightweightMode = true,
		ShadowEnabled = true,
		ShadowLayerCount = 2,
		ShadowSpread = 4,
		ShadowOffsetY = 2,
		Theme = theme,
		Parent = parentGui,
	})

	local container = glassFrame.Container
	container.Visible = false
	container.ZIndex = 200

	-- UIScale for animation
	local uiScale = Instance.new("UIScale")
	uiScale.Scale = 0.9
	uiScale.Parent = container

	-- TextLabel inside GlassSurface
	local textLabel = Instance.new("TextLabel")
	textLabel.Name = "TooltipText"
	textLabel.Text = text
	textLabel.Font = font
	textLabel.TextSize = textSize
	textLabel.TextColor3 = textColor
	textLabel.TextWrapped = true
	textLabel.TextXAlignment = Enum.TextXAlignment.Center
	textLabel.TextYAlignment = Enum.TextYAlignment.Center
	textLabel.BackgroundTransparency = 1
	textLabel.BorderSizePixel = 0
	textLabel.Size = UDim2.new(1, 0, 1, 0)
	textLabel.ZIndex = 10
	textLabel.Parent = glassFrame.GlassSurface

	-- Arrow (45-degree rotated frame)
	local arrow = Instance.new("Frame")
	arrow.Name = "TooltipArrow"
	arrow.Size = UDim2.new(0, arrowSize, 0, arrowSize)
	arrow.Rotation = 45
	arrow.BackgroundColor3 = bgColor
	arrow.BackgroundTransparency = bgTransparency
	arrow.BorderSizePixel = 0
	arrow.ZIndex = 0
	arrow.Parent = container

	-- Helper to get viewport size
	local function getViewportSize(): Vector2
		local camera = game:GetService("Workspace").CurrentCamera
		if camera then
			return camera.ViewportSize
		end
		return Vector2.new(1920, 1080)
	end

	-- Position tooltip relative to target
	local function positionTooltip(desiredPlacement: string)
		local targetPos = target.AbsolutePosition
		local targetSize = target.AbsoluteSize
		local viewportSize = getViewportSize()
		local gap = arrowSize / 2 + 4

		local tx = targetPos.X + targetSize.X / 2
		local ty = targetPos.Y

		local tooltipX: number
		local tooltipY: number
		local arrowX: number
		local arrowY: number
		local finalPlacement = desiredPlacement

		if finalPlacement == "auto" then
			finalPlacement = "top"
		end

		-- Try the requested placement, fall back if offscreen
		local function tryPlacement(p: string): boolean
			if p == "top" then
				tooltipX = tx - tooltipWidth / 2
				tooltipY = targetPos.Y - tooltipHeight - gap
				arrowX = tooltipWidth / 2 - arrowSize / 2
				arrowY = tooltipHeight - arrowSize / 2
				return tooltipY >= 0
			elseif p == "bottom" then
				tooltipX = tx - tooltipWidth / 2
				tooltipY = targetPos.Y + targetSize.Y + gap
				arrowX = tooltipWidth / 2 - arrowSize / 2
				arrowY = -arrowSize / 2
				return tooltipY + tooltipHeight <= viewportSize.Y
			elseif p == "left" then
				tooltipX = targetPos.X - tooltipWidth - gap
				tooltipY = ty + targetSize.Y / 2 - tooltipHeight / 2
				arrowX = tooltipWidth - arrowSize / 2
				arrowY = tooltipHeight / 2 - arrowSize / 2
				return tooltipX >= 0
			elseif p == "right" then
				tooltipX = targetPos.X + targetSize.X + gap
				tooltipY = ty + targetSize.Y / 2 - tooltipHeight / 2
				arrowX = -arrowSize / 2
				arrowY = tooltipHeight / 2 - arrowSize / 2
				return tooltipX + tooltipWidth <= viewportSize.X
			end
			return false
		end

		if not tryPlacement(finalPlacement) then
			local fallbacks = {"top", "bottom", "left", "right"}
			local placed = false
			for _, fb in fallbacks do
				if fb ~= finalPlacement and tryPlacement(fb) then
					finalPlacement = fb
					placed = true
					break
				end
			end
			if not placed then
				tryPlacement("top")
				finalPlacement = "top"
			end
		end

		-- Clamp to viewport
		tooltipX = math.clamp(tooltipX, 4, viewportSize.X - tooltipWidth - 4)
		tooltipY = math.clamp(tooltipY, 4, viewportSize.Y - tooltipHeight - 4)

		container.Position = UDim2.new(0, tooltipX, 0, tooltipY)
		arrow.Position = UDim2.new(0, arrowX, 0, arrowY)
		currentPlacement = finalPlacement
	end

	-- Remeasure and resize
	local function remeasure()
		local bounds = TextService:GetTextSize(textLabel.Text, textSize, font, Vector2.new(maxWidth - paddingH, 1000))
		tooltipWidth = math.min(bounds.X + paddingH, maxWidth)
		tooltipHeight = bounds.Y + paddingV
		container.Size = UDim2.new(0, tooltipWidth, 0, tooltipHeight)
	end

	-- Connect hover events on target
	local enterConn = target.MouseEnter:Connect(function()
		if isDestroyed or isVisible then
			return
		end
		-- Start delay
		if delayThread then
			task.cancel(delayThread)
			delayThread = nil
		end
		delayThread = task.delay(delayTime, function()
			delayThread = nil
			if not isDestroyed and not isVisible then
				-- Show tooltip
				isVisible = true
				positionTooltip(placement)
				container.Visible = true
				uiScale.Scale = 0.9

				cancelAllTweens()
				local tweenIn = TweenService:Create(uiScale, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
					Scale = 1.0,
				})
				trackTween(tweenIn)
				tweenIn:Play()
			end
		end)
	end)
	table.insert(connections, enterConn)

	local leaveConn = target.MouseLeave:Connect(function()
		if isDestroyed then
			return
		end
		-- Cancel pending delay
		if delayThread then
			task.cancel(delayThread)
			delayThread = nil
		end
		if isVisible then
			isVisible = false
			cancelAllTweens()
			local tweenOut = TweenService:Create(uiScale, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Scale = 0.95,
			})
			trackTween(tweenOut)
			tweenOut:Play()
			tweenOut.Completed:Connect(function()
				if not isVisible and not isDestroyed then
					container.Visible = false
				end
			end)
		end
	end)
	table.insert(connections, leaveConn)

	-- Return table
	local self: Types.MangoTooltip = {
		Show = function(self: Types.MangoTooltip)
			if isDestroyed or isVisible then
				return
			end
			isVisible = true
			-- Cancel pending delay
			if delayThread then
				task.cancel(delayThread)
				delayThread = nil
			end
			positionTooltip(placement)
			container.Visible = true
			uiScale.Scale = 0.9

			cancelAllTweens()
			local tweenIn = TweenService:Create(uiScale, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
				Scale = 1.0,
			})
			trackTween(tweenIn)
			tweenIn:Play()
		end,
		Hide = function(self: Types.MangoTooltip)
			if isDestroyed or not isVisible then
				return
			end
			isVisible = false
			-- Cancel pending delay
			if delayThread then
				task.cancel(delayThread)
				delayThread = nil
			end

			cancelAllTweens()
			local tweenOut = TweenService:Create(uiScale, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Scale = 0.95,
			})
			trackTween(tweenOut)
			tweenOut:Play()
			tweenOut.Completed:Connect(function()
				if not isVisible and not isDestroyed then
					container.Visible = false
				end
			end)
		end,
		SetText = function(self: Types.MangoTooltip, newText: string)
			if isDestroyed then
				return
			end
			textLabel.Text = newText
			remeasure()
			if isVisible then
				positionTooltip(currentPlacement)
			end
		end,
		Destroy = function(self: Types.MangoTooltip)
			if isDestroyed then
				return
			end
			isDestroyed = true

			if delayThread then
				task.cancel(delayThread)
				delayThread = nil
			end

			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoToast"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoProtection = _require("MangoProtection")
local resolve = Themes.resolve
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

local module = {}

function module.new(config: Types.MangoToastConfig): Types.MangoToast
	local theme = config.Theme
	local text = resolve(config.Text, nil, "Toast") :: string
	local icon = config.Icon
	local duration = resolve(config.Duration, nil, 3) :: number

	-- Theme-driven properties
	local bgTransparency = resolve(nil, theme and theme.ToastBackgroundTransparency, 0.20) :: number
	local textColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3

	-- Measure text
	local font = Enum.Font.GothamMedium
	local fontSize = 14
	local hasIcon = icon ~= nil and icon ~= ""
	local iconSpace = if hasIcon then 28 else 0 -- 20px icon + 8px gap
	local textBounds = TextService:GetTextSize(text, fontSize, font, Vector2.new(400, 48))
	local toastWidth = math.clamp(textBounds.X + 32 + iconSpace, 80, 400) -- 16px padding each side
	local toastHeight = math.clamp(textBounds.Y + 20, 36, 48) -- 10px padding top/bottom, clamp 36-48

	-- State
	local isShowing = false
	local isDismissing = false
	local isDestroyed = false
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}
	local dismissThread: thread? = nil
	local positionTweens: {Tween} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function cancelPositionTweens()
		for _, tween in positionTweens do
			tween:Cancel()
		end
		table.clear(positionTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Determine parent
	local screenGui: ScreenGui? = nil
	local parentInstance: Instance
	if config.Parent then
		parentInstance = config.Parent
	else
		local gui = MangoProtection.createScreenGui({
			DisplayOrder = 100,
		})
		screenGui = gui
		parentInstance = gui
	end

	-- Toast container (anchored bottom-center, starts offscreen below)
	local toastContainer = Instance.new("Frame")
	toastContainer.Name = MangoProtection.randomName("Toast")
	toastContainer.Size = UDim2.new(0, toastWidth, 0, toastHeight)
	toastContainer.AnchorPoint = Vector2.new(0.5, 1)
	toastContainer.Position = UDim2.new(0.5, 0, 1, 60) -- offscreen below
	toastContainer.BackgroundTransparency = 1
	toastContainer.BorderSizePixel = 0
	toastContainer.Parent = parentInstance

	-- Glass frame (pill shape)
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 999),
		BackgroundTransparency = bgTransparency,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 2,
		ShadowSpread = 6,
		ShadowOffsetY = 2,
		LightweightMode = true,
		Parent = toastContainer,
	})

	-- Store target transparency for fade-in
	local targetBgTransparency = glassFrame.GlassSurface.BackgroundTransparency

	-- UIPadding on GlassSurface
	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 16)
	padding.PaddingRight = UDim.new(0, 16)
	padding.PaddingTop = UDim.new(0, 0)
	padding.PaddingBottom = UDim.new(0, 0)
	padding.Parent = glassFrame.GlassSurface

	-- Horizontal layout
	local hLayout = Instance.new("UIListLayout")
	hLayout.FillDirection = Enum.FillDirection.Horizontal
	hLayout.Padding = UDim.new(0, 8)
	hLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	hLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	hLayout.SortOrder = Enum.SortOrder.LayoutOrder
	hLayout.Parent = glassFrame.GlassSurface

	-- Icon (optional)
	if hasIcon then
		local iconLabel = Instance.new("TextLabel")
		iconLabel.Name = "IconLabel"
		iconLabel.Text = icon :: string
		iconLabel.Font = Enum.Font.GothamBold
		iconLabel.TextSize = 16
		iconLabel.TextColor3 = textColor
		iconLabel.BackgroundTransparency = 1
		iconLabel.BorderSizePixel = 0
		iconLabel.Size = UDim2.new(0, 20, 0, 20)
		iconLabel.LayoutOrder = 1
		iconLabel.ZIndex = 10
		iconLabel.Parent = glassFrame.GlassSurface
	end

	-- Text label
	local textLabel = Instance.new("TextLabel")
	textLabel.Name = "ToastText"
	textLabel.Text = text
	textLabel.Font = font
	textLabel.TextSize = fontSize
	textLabel.TextColor3 = textColor
	textLabel.BackgroundTransparency = 1
	textLabel.BorderSizePixel = 0
	textLabel.Size = UDim2.new(0, textBounds.X, 1, 0)
	textLabel.TextXAlignment = Enum.TextXAlignment.Center
	textLabel.TextYAlignment = Enum.TextYAlignment.Center
	textLabel.LayoutOrder = 2
	textLabel.ZIndex = 10
	textLabel.Parent = glassFrame.GlassSurface

	-- DismissHitArea (tap-to-dismiss)
	local dismissHitArea = Instance.new("TextButton")
	dismissHitArea.Name = "DismissHitArea"
	dismissHitArea.Size = UDim2.new(1, 0, 1, 0)
	dismissHitArea.BackgroundTransparency = 1
	dismissHitArea.BorderSizePixel = 0
	dismissHitArea.Text = ""
	dismissHitArea.AutoButtonColor = false
	dismissHitArea.ZIndex = 50
	dismissHitArea.Parent = toastContainer

	-- Forward-declared dismiss for tap handler
	local dismiss: () -> ()

	-- Tap to dismiss
	local tapConn = dismissHitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			if isShowing and not isDismissing then
				dismiss()
			end
		end
	end)
	table.insert(connections, tapConn)

	-- Dismiss implementation
	dismiss = function()
		if isDismissing or isDestroyed or not isShowing then
			return
		end
		isDismissing = true

		-- Cancel auto-dismiss thread
		if dismissThread then
			task.cancel(dismissThread)
			dismissThread = nil
		end

		cancelAllTweens()
		local tweenOut = TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		local slideTween = TweenService:Create(toastContainer, tweenOut, {
			Position = UDim2.new(0.5, 0, 1, 60),
		})
		trackTween(slideTween)
		slideTween:Play()
		slideTween.Completed:Connect(function()
			if not isDestroyed then
				isDestroyed = true
				if config.OnDismissed then
					config.OnDismissed()
				end
				-- Auto-destroy after dismiss
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				glassFrame:Destroy()
				toastContainer:Destroy()
				if screenGui then
					screenGui:Destroy()
				end
			end
		end)
	end

	-- Return table
	local self: Types.MangoToast = {
		Container = toastContainer,
		Show = function(self: Types.MangoToast)
			if isShowing or isDestroyed then
				return
			end
			isShowing = true

			-- Start with glass surface fully transparent for fade-in
			glassFrame.GlassSurface.BackgroundTransparency = 1

			-- Slide up into view
			cancelAllTweens()
			local springInfo = TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local slideTween = TweenService:Create(toastContainer, springInfo, {
				Position = UDim2.new(0.5, 0, 1, -16),
			})
			trackTween(slideTween)
			slideTween:Play()

			-- Fade in glass surface
			local fadeInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local fadeTween = TweenService:Create(glassFrame.GlassSurface, fadeInfo, {
				BackgroundTransparency = targetBgTransparency,
			})
			trackTween(fadeTween)
			fadeTween:Play()

			-- Auto-dismiss after duration (0 = no auto-dismiss)
			if duration > 0 then
				dismissThread = task.delay(duration, function()
					dismissThread = nil
					if not isDismissing and not isDestroyed and isShowing then
						dismiss()
					end
				end)
			end
		end,
		Dismiss = function(self: Types.MangoToast)
			dismiss()
		end,
		SetPosition = function(self: Types.MangoToast, position: UDim2)
			if isDestroyed then
				return
			end
			cancelPositionTweens()
			local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local posTween = TweenService:Create(toastContainer, tweenInfo, {
				Position = position,
			})
			table.insert(positionTweens, posTween)
			posTween:Play()
		end,
		GetHeight = function(self: Types.MangoToast): number
			return toastHeight
		end,
		Destroy = function(self: Types.MangoToast)
			if isDestroyed then
				return
			end
			isDestroyed = true

			-- Cancel auto-dismiss thread
			if dismissThread then
				task.cancel(dismissThread)
				dismissThread = nil
			end

			cancelAllTweens()
			cancelPositionTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
			toastContainer:Destroy()
			if screenGui then
				screenGui:Destroy()
			end
		end,
	}

	return self
end

function module.newStack(config: Types.MangoToastStackConfig): Types.MangoToastStack
	local theme = config.Theme

	local maxVisible = resolve(config.MaxVisible, nil, 3) :: number
	local stackGap = resolve(config.StackGap, nil, 8) :: number

	-- State
	local isDestroyed = false
	local activeToasts: {Types.MangoToast} = {}

	-- Determine parent container
	local screenGui: ScreenGui? = nil
	local parentInstance: Instance
	if config.Parent then
		parentInstance = config.Parent
	else
		local gui = MangoProtection.createScreenGui({
			DisplayOrder = 100,
		})
		screenGui = gui
		parentInstance = gui
	end

	-- Compute Y offset from bottom for a toast at the given index (1-based)
	-- Stacks upward: index 1 is closest to bottom
	local function computeYForIndex(index: number): number
		local y = -16 -- base offset from bottom edge
		for i = 1, index - 1 do
			local toast = activeToasts[i]
			if toast then
				y = y - toast:GetHeight() - stackGap
			end
		end
		return y
	end

	-- Reflow all active toasts to fill gaps
	local function reflowToasts()
		for i, toast in activeToasts do
			local y = computeYForIndex(i)
			toast:SetPosition(UDim2.new(0.5, 0, 1, y))
		end
	end

	-- Remove a toast from the active array and reflow
	local function removeFromArray(toast: Types.MangoToast)
		local idx: number? = nil
		for i, t in activeToasts do
			if t == toast then
				idx = i
				break
			end
		end
		if idx then
			table.remove(activeToasts, idx)
			reflowToasts()
		end
	end

	local self: Types.MangoToastStack = {
		Push = function(self: Types.MangoToastStack, toastConfig: Types.MangoToastConfig): Types.MangoToast
			if isDestroyed then
				error("Cannot push to a destroyed MangoToastStack")
			end

			-- Auto-dismiss oldest if at max capacity
			if #activeToasts >= maxVisible then
				local oldest = activeToasts[1]
				if oldest then
					oldest:Dismiss()
				end
			end

			-- Wrap the OnDismissed callback
			local originalOnDismissed = toastConfig.OnDismissed

			local stackToastConfig: Types.MangoToastConfig = {
				Text = toastConfig.Text,
				Icon = toastConfig.Icon,
				Duration = toastConfig.Duration,
				Theme = toastConfig.Theme or theme,
				Parent = parentInstance,
				OnDismissed = nil,
			}

			-- Forward reference for dismiss callback
			local toastRef: Types.MangoToast? = nil

			stackToastConfig.OnDismissed = function()
				if toastRef then
					removeFromArray(toastRef :: Types.MangoToast)
				end
				if originalOnDismissed then
					originalOnDismissed()
				end
			end

			local toast = module.new(stackToastConfig)
			toastRef = toast

			-- Position and show
			table.insert(activeToasts, toast)
			local y = computeYForIndex(#activeToasts)
			toast.Container.Position = UDim2.new(0.5, 0, 1, 60) -- start offscreen below
			toast:Show()
			toast:SetPosition(UDim2.new(0.5, 0, 1, y))

			return toast
		end,
		DismissAll = function(self: Types.MangoToastStack)
			local copy = table.clone(activeToasts)
			for _, toast in copy do
				toast:Dismiss()
			end
		end,
		GetCount = function(self: Types.MangoToastStack): number
			return #activeToasts
		end,
		Destroy = function(self: Types.MangoToastStack)
			if isDestroyed then
				return
			end
			isDestroyed = true

			local copy = table.clone(activeToasts)
			for _, toast in copy do
				toast:Destroy()
			end
			table.clear(activeToasts)

			if screenGui then
				screenGui:Destroy()
			end
		end,
	}

	return self
end

return module

end

_modules["MangoDialog"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoProtection = _require("MangoProtection")
local resolve = Themes.resolve
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

local module = {}

function module.new(config: Types.MangoDialogConfig): Types.MangoDialog
	local theme = config.Theme
	local title = resolve(config.Title, nil, "Dialog") :: string
	local message = config.Message
	local buttons = config.Buttons

	-- Theme-driven values
	local overlayTransparency = resolve(nil, theme and theme.DialogOverlayTransparency, 0.40) :: number
	local dialogBgTransparency = resolve(nil, theme and theme.DialogBackgroundTransparency, 0.78) :: number
	local primaryTextColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local secondaryTextColor = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3

	-- If no buttons config, add a single OK button
	if not buttons or #buttons == 0 then
		buttons = {
			{ Text = "OK", Style = "cancel" },
		}
	end

	-- State
	local isShowing = false
	local isDismissing = false
	local isDestroyed = false
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Create ScreenGui
	local screenGui: ScreenGui? = nil
	local parentInstance: Instance
	if config.Parent then
		parentInstance = config.Parent
	else
		local gui = MangoProtection.createScreenGui({
			DisplayOrder = 150,
		})
		screenGui = gui
		parentInstance = gui
	end

	-- Overlay
	local overlay = Instance.new("Frame")
	overlay.Name = MangoProtection.randomName("Overlay")
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	overlay.BackgroundTransparency = 1 -- starts fully transparent
	overlay.BorderSizePixel = 0
	overlay.ZIndex = 1
	overlay.Parent = parentInstance

	-- DialogContainer
	local dialogContainer = Instance.new("Frame")
	dialogContainer.Name = MangoProtection.randomName("Container")
	dialogContainer.AnchorPoint = Vector2.new(0.5, 0.5)
	dialogContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	dialogContainer.BackgroundTransparency = 1
	dialogContainer.BorderSizePixel = 0
	dialogContainer.ZIndex = 2
	dialogContainer.Parent = parentInstance

	-- UIScale for dialog animation
	local dialogScale = Instance.new("UIScale")
	dialogScale.Scale = 0.8
	dialogScale.Parent = dialogContainer

	-- Measure text to compute dialog height
	local contentWidth = 300 - 32 -- 16px padding each side
	local titleFont = Enum.Font.GothamBold
	local titleSize = 17
	local messageFont = Enum.Font.Gotham
	local messageSize = 14

	local titleBounds = TextService:GetTextSize(title, titleSize, titleFont, Vector2.new(contentWidth, 1000))
	local dialogContentHeight = 20 + titleBounds.Y -- 20px top padding

	local messageBounds: Vector2? = nil
	if message and message ~= "" then
		messageBounds = TextService:GetTextSize(message, messageSize, messageFont, Vector2.new(contentWidth, 1000))
		dialogContentHeight = dialogContentHeight + 4 + (messageBounds :: Vector2).Y
	end

	dialogContentHeight = dialogContentHeight + 16 -- bottom padding before separator

	-- Separator + buttons height
	local buttonCount = #(buttons :: {Types.MangoDialogButtonConfig})
	local buttonsHeight = 1 + (buttonCount * 44) + math.max(0, buttonCount - 1) -- 1px separator + buttons + inter-button separators
	local totalDialogHeight = dialogContentHeight + buttonsHeight

	dialogContainer.Size = UDim2.new(0, 300, 0, totalDialogHeight)

	-- Glass frame inside dialog
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 16),
		Theme = theme,
		BackgroundTransparency = dialogBgTransparency,
		ShadowEnabled = true,
		ShadowLayerCount = 4,
		ShadowOffsetY = 4,
		ShadowSpread = 16,
		LightweightMode = true,
		Parent = dialogContainer,
	})

	-- Store target transparency for animation
	local targetGlassTransparency = glassFrame.GlassSurface.BackgroundTransparency

	-- UIPadding on GlassSurface for title/message area
	-- We use a content frame for the text area and separate the buttons
	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "ContentFrame"
	contentFrame.Size = UDim2.new(1, 0, 0, dialogContentHeight)
	contentFrame.Position = UDim2.new(0, 0, 0, 0)
	contentFrame.BackgroundTransparency = 1
	contentFrame.BorderSizePixel = 0
	contentFrame.ZIndex = 10
	contentFrame.Parent = glassFrame.GlassSurface

	local contentPadding = Instance.new("UIPadding")
	contentPadding.PaddingTop = UDim.new(0, 20)
	contentPadding.PaddingLeft = UDim.new(0, 16)
	contentPadding.PaddingRight = UDim.new(0, 16)
	contentPadding.Parent = contentFrame

	local contentLayout = Instance.new("UIListLayout")
	contentLayout.FillDirection = Enum.FillDirection.Vertical
	contentLayout.Padding = UDim.new(0, 4)
	contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
	contentLayout.Parent = contentFrame

	-- TitleLabel
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Text = title
	titleLabel.Font = titleFont
	titleLabel.TextSize = titleSize
	titleLabel.TextColor3 = primaryTextColor
	titleLabel.BackgroundTransparency = 1
	titleLabel.Size = UDim2.new(1, 0, 0, titleBounds.Y)
	titleLabel.TextXAlignment = Enum.TextXAlignment.Center
	titleLabel.TextYAlignment = Enum.TextYAlignment.Center
	titleLabel.TextWrapped = true
	titleLabel.BorderSizePixel = 0
	titleLabel.LayoutOrder = 1
	titleLabel.ZIndex = 10
	titleLabel.Parent = contentFrame

	-- MessageLabel (optional)
	if message and message ~= "" and messageBounds then
		local messageLabel = Instance.new("TextLabel")
		messageLabel.Name = "MessageLabel"
		messageLabel.Text = message
		messageLabel.Font = messageFont
		messageLabel.TextSize = messageSize
		messageLabel.TextColor3 = secondaryTextColor
		messageLabel.BackgroundTransparency = 1
		messageLabel.Size = UDim2.new(1, 0, 0, (messageBounds :: Vector2).Y)
		messageLabel.TextXAlignment = Enum.TextXAlignment.Center
		messageLabel.TextYAlignment = Enum.TextYAlignment.Top
		messageLabel.TextWrapped = true
		messageLabel.BorderSizePixel = 0
		messageLabel.LayoutOrder = 2
		messageLabel.ZIndex = 10
		messageLabel.Parent = contentFrame
	end

	-- Separator between content and buttons
	local separator = Instance.new("Frame")
	separator.Name = "Separator"
	separator.Size = UDim2.new(1, 0, 0, 1)
	separator.Position = UDim2.new(0, 0, 0, dialogContentHeight)
	separator.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
	separator.BackgroundTransparency = 0.7
	separator.BorderSizePixel = 0
	separator.ZIndex = 10
	separator.Parent = glassFrame.GlassSurface

	-- Buttons container
	local buttonsContainer = Instance.new("Frame")
	buttonsContainer.Name = "ButtonsContainer"
	buttonsContainer.Size = UDim2.new(1, 0, 0, buttonsHeight - 1) -- minus the top separator
	buttonsContainer.Position = UDim2.new(0, 0, 0, dialogContentHeight + 1)
	buttonsContainer.BackgroundTransparency = 1
	buttonsContainer.BorderSizePixel = 0
	buttonsContainer.ZIndex = 10
	buttonsContainer.Parent = glassFrame.GlassSurface

	local buttonsLayout = Instance.new("UIListLayout")
	buttonsLayout.FillDirection = Enum.FillDirection.Vertical
	buttonsLayout.Padding = UDim.new(0, 0) -- separators are inline
	buttonsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	buttonsLayout.Parent = buttonsContainer

	-- Forward reference for dismiss
	local dismissFunc: (() -> ())? = nil

	-- Create each button
	for i, buttonConfig in buttons :: {Types.MangoDialogButtonConfig} do
		-- Inter-button separator (not before the first button)
		if i > 1 then
			local btnSep = Instance.new("Frame")
			btnSep.Name = "ButtonSeparator" .. i
			btnSep.Size = UDim2.new(1, 0, 0, 1)
			btnSep.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
			btnSep.BackgroundTransparency = 0.7
			btnSep.BorderSizePixel = 0
			btnSep.ZIndex = 10
			btnSep.LayoutOrder = (i - 1) * 2
			btnSep.Parent = buttonsContainer
		end

		local btnFrame = Instance.new("Frame")
		btnFrame.Name = "Button" .. i
		btnFrame.Size = UDim2.new(1, 0, 0, 44)
		btnFrame.BackgroundTransparency = 1
		btnFrame.BorderSizePixel = 0
		btnFrame.ZIndex = 10
		btnFrame.LayoutOrder = (i - 1) * 2 + 1
		btnFrame.Parent = buttonsContainer

		-- Determine style
		local style = buttonConfig.Style or "default"
		local btnTextColor: Color3
		local btnFont: Enum.Font
		if style == "destructive" then
			btnTextColor = Color3.fromRGB(255, 59, 48)
			btnFont = Enum.Font.Gotham
		elseif style == "cancel" then
			btnTextColor = primaryTextColor
			btnFont = Enum.Font.GothamBold
		else
			btnTextColor = primaryTextColor
			btnFont = Enum.Font.Gotham
		end

		local btnLabel = Instance.new("TextLabel")
		btnLabel.Name = "ButtonLabel"
		btnLabel.Text = buttonConfig.Text
		btnLabel.Font = btnFont
		btnLabel.TextSize = 17
		btnLabel.TextColor3 = btnTextColor
		btnLabel.BackgroundTransparency = 1
		btnLabel.Size = UDim2.new(1, 0, 1, 0)
		btnLabel.TextXAlignment = Enum.TextXAlignment.Center
		btnLabel.TextYAlignment = Enum.TextYAlignment.Center
		btnLabel.TextTruncate = Enum.TextTruncate.AtEnd
		btnLabel.BorderSizePixel = 0
		btnLabel.ZIndex = 10
		btnLabel.Parent = btnFrame

		-- HitArea
		local hitArea = Instance.new("TextButton")
		hitArea.Name = "HitArea"
		hitArea.Size = UDim2.new(1, 0, 1, 0)
		hitArea.BackgroundTransparency = 1
		hitArea.Text = ""
		hitArea.BorderSizePixel = 0
		hitArea.ZIndex = 100
		hitArea.AutoButtonColor = false
		hitArea.Parent = btnFrame

		local conn = hitArea.Activated:Connect(function()
			if buttonConfig.OnActivated then
				buttonConfig.OnActivated()
			end
			if dismissFunc then
				dismissFunc()
			end
		end)
		table.insert(connections, conn)
	end

	-- Overlay tap to dismiss
	local overlayHit = Instance.new("TextButton")
	overlayHit.Name = "OverlayHitArea"
	overlayHit.Size = UDim2.new(1, 0, 1, 0)
	overlayHit.BackgroundTransparency = 1
	overlayHit.Text = ""
	overlayHit.BorderSizePixel = 0
	overlayHit.ZIndex = 0
	overlayHit.AutoButtonColor = false
	overlayHit.Parent = overlay

	local overlayConn = overlayHit.Activated:Connect(function()
		if dismissFunc then
			dismissFunc()
		end
	end)
	table.insert(connections, overlayConn)

	-- Dismiss implementation
	local function doDismiss()
		if isDismissing or isDestroyed or not isShowing then
			return
		end
		isDismissing = true

		cancelAllTweens()
		local tweenOut = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

		-- Fade overlay out
		local overlayTween = TweenService:Create(overlay, tweenOut, {
			BackgroundTransparency = 1,
		})
		trackTween(overlayTween)
		overlayTween:Play()

		-- Scale dialog down + fade glass
		local scaleTween = TweenService:Create(dialogScale, tweenOut, { Scale = 0.8 })
		trackTween(scaleTween)
		scaleTween:Play()

		local glassFadeTween = TweenService:Create(glassFrame.GlassSurface, tweenOut, {
			BackgroundTransparency = 1,
		})
		trackTween(glassFadeTween)
		glassFadeTween:Play()

		scaleTween.Completed:Once(function()
			if not isDestroyed then
				-- Set isDestroyed BEFORE callback to prevent re-entrancy
				isDestroyed = true
				if config.OnDismissed then
					config.OnDismissed()
				end
				cancelAllTweens()
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				glassFrame:Destroy()
				dialogContainer:Destroy()
				overlay:Destroy()
				if screenGui then
					screenGui:Destroy()
				end
			end
		end)
	end

	dismissFunc = doDismiss

	-- Return table
	local self: Types.MangoDialog = {
		Show = function(self: Types.MangoDialog)
			if isShowing or isDestroyed then
				return
			end
			isShowing = true

			-- Start with glass surface fully transparent
			glassFrame.GlassSurface.BackgroundTransparency = 1
			dialogScale.Scale = 0.8

			cancelAllTweens()

			-- Fade overlay in
			local overlayInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local overlayTween = TweenService:Create(overlay, overlayInfo, {
				BackgroundTransparency = overlayTransparency,
			})
			trackTween(overlayTween)
			overlayTween:Play()

			-- Scale dialog in
			local scaleInfo = TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local scaleTween = TweenService:Create(dialogScale, scaleInfo, { Scale = 1 })
			trackTween(scaleTween)
			scaleTween:Play()

			-- Fade glass surface in
			local fadeInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local glassFadeTween = TweenService:Create(glassFrame.GlassSurface, fadeInfo, {
				BackgroundTransparency = targetGlassTransparency,
			})
			trackTween(glassFadeTween)
			glassFadeTween:Play()
		end,
		Dismiss = function(self: Types.MangoDialog)
			doDismiss()
		end,
		Destroy = function(self: Types.MangoDialog)
			if isDestroyed then
				return
			end
			isDestroyed = true

			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
			dialogContainer:Destroy()
			overlay:Destroy()
			if screenGui then
				screenGui:Destroy()
			end
		end,
	}

	return self
end

return module

end

_modules["MangoActionSheet"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoProtection = _require("MangoProtection")
local resolve = Themes.resolve
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

local module = {}

function module.new(config: Types.MangoActionSheetConfig): Types.MangoActionSheet
	local theme = config.Theme
	local title = config.Title
	local message = config.Message
	local actions = resolve(config.Actions, nil, {{Text = "OK"}}) :: {Types.MangoActionSheetActionConfig}
	local cancelText = resolve(config.CancelText, nil, "Cancel") :: string

	-- Theme-driven values
	local overlayTransparency = resolve(nil, theme and theme.DialogOverlayTransparency, 0.40) :: number
	local primaryTextColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local secondaryTextColor = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3
	local cancelButtonColor = resolve(nil, theme and theme.TabBarSelectedColor, primaryTextColor) :: Color3

	-- State
	local isShowing = false
	local isDismissing = false
	local isDestroyed = false
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Create ScreenGui
	local screenGui: ScreenGui? = nil
	local parentInstance: Instance
	if config.Parent then
		parentInstance = config.Parent
	else
		local gui = MangoProtection.createScreenGui({
			DisplayOrder = 150,
		})
		screenGui = gui
		parentInstance = gui
	end

	-- Overlay
	local overlay = Instance.new("Frame")
	overlay.Name = MangoProtection.randomName("Overlay")
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	overlay.BackgroundTransparency = 1 -- starts fully transparent
	overlay.BorderSizePixel = 0
	overlay.ZIndex = 1
	overlay.Parent = parentInstance

	-- SheetContainer (anchored bottom center)
	local sheetContainer = Instance.new("Frame")
	sheetContainer.Name = MangoProtection.randomName("Container")
	sheetContainer.AnchorPoint = Vector2.new(0.5, 1)
	sheetContainer.Position = UDim2.new(0.5, 0, 1, 100) -- starts offscreen below
	sheetContainer.BackgroundTransparency = 1
	sheetContainer.BorderSizePixel = 0
	sheetContainer.ZIndex = 2
	sheetContainer.Parent = parentInstance

	-- Compute actions group height
	local hasHeader = (title and title ~= "") or (message and message ~= "")
	local headerHeight = 0
	local titleFont = Enum.Font.Gotham
	local titleSize = 13
	local messageFont = Enum.Font.Gotham
	local messageSize = 13
	-- Use a reasonable content width: min(400, estimate) - padding
	local sheetWidth = 400 -- will be constrained by UISizeConstraint
	local contentWidth = sheetWidth - 32 -- 16px padding each side

	local titleBounds: Vector2? = nil
	local messageBounds: Vector2? = nil

	if title and title ~= "" then
		titleBounds = TextService:GetTextSize(title, titleSize, titleFont, Vector2.new(contentWidth, 1000))
		headerHeight = headerHeight + 16 + (titleBounds :: Vector2).Y -- 16px top padding
	end

	if message and message ~= "" then
		messageBounds = TextService:GetTextSize(message, messageSize, messageFont, Vector2.new(contentWidth, 1000))
		local topGap = if headerHeight > 0 then 4 else 16
		headerHeight = headerHeight + topGap + (messageBounds :: Vector2).Y
	end

	if hasHeader then
		headerHeight = headerHeight + 12 -- bottom padding
		headerHeight = headerHeight + 1 -- separator
	end

	local actionCount = #actions
	local actionsAreaHeight = (actionCount * 56) + math.max(0, actionCount - 1) -- 56px per action + 1px separators
	local actionsGroupHeight = headerHeight + actionsAreaHeight

	-- Cancel group height
	local cancelGroupHeight = 56

	-- Total sheet height
	local totalSheetHeight = actionsGroupHeight + 8 + cancelGroupHeight

	-- Width: min(400, screen width - 16) — we use a UISizeConstraint to handle screen width
	sheetContainer.Size = UDim2.new(1, -16, 0, totalSheetHeight)

	local sizeConstraint = Instance.new("UISizeConstraint")
	sizeConstraint.MaxSize = Vector2.new(400, totalSheetHeight)
	sizeConstraint.Parent = sheetContainer

	-- Vertical layout for sheet container
	local sheetLayout = Instance.new("UIListLayout")
	sheetLayout.FillDirection = Enum.FillDirection.Vertical
	sheetLayout.Padding = UDim.new(0, 8)
	sheetLayout.SortOrder = Enum.SortOrder.LayoutOrder
	sheetLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	sheetLayout.Parent = sheetContainer

	-- Actions Group Glass Frame
	local actionsGroupContainer = Instance.new("Frame")
	actionsGroupContainer.Name = "ActionsGroupContainer"
	actionsGroupContainer.Size = UDim2.new(1, 0, 0, actionsGroupHeight)
	actionsGroupContainer.BackgroundTransparency = 1
	actionsGroupContainer.BorderSizePixel = 0
	actionsGroupContainer.LayoutOrder = 1
	actionsGroupContainer.Parent = sheetContainer

	local actionsGlass = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 14),
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 3,
		ShadowOffsetY = 2,
		ShadowSpread = 8,
		LightweightMode = true,
		Parent = actionsGroupContainer,
	})

	-- Forward reference for dismiss
	local dismissFunc: (() -> ())? = nil

	-- Build header inside actions glass
	local currentY = 0

	if hasHeader then
		local headerFrame = Instance.new("Frame")
		headerFrame.Name = "HeaderFrame"
		headerFrame.Size = UDim2.new(1, 0, 0, headerHeight - 1) -- minus separator
		headerFrame.Position = UDim2.new(0, 0, 0, 0)
		headerFrame.BackgroundTransparency = 1
		headerFrame.BorderSizePixel = 0
		headerFrame.ZIndex = 10
		headerFrame.Parent = actionsGlass.GlassSurface

		local headerPadding = Instance.new("UIPadding")
		headerPadding.PaddingTop = UDim.new(0, 16)
		headerPadding.PaddingLeft = UDim.new(0, 16)
		headerPadding.PaddingRight = UDim.new(0, 16)
		headerPadding.Parent = headerFrame

		local headerLayout = Instance.new("UIListLayout")
		headerLayout.FillDirection = Enum.FillDirection.Vertical
		headerLayout.Padding = UDim.new(0, 4)
		headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		headerLayout.SortOrder = Enum.SortOrder.LayoutOrder
		headerLayout.Parent = headerFrame

		if title and title ~= "" and titleBounds then
			local titleLabel = Instance.new("TextLabel")
			titleLabel.Name = "TitleLabel"
			titleLabel.Text = title
			titleLabel.Font = titleFont
			titleLabel.TextSize = titleSize
			titleLabel.TextColor3 = secondaryTextColor
			titleLabel.BackgroundTransparency = 1
			titleLabel.Size = UDim2.new(1, 0, 0, (titleBounds :: Vector2).Y)
			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
			titleLabel.TextYAlignment = Enum.TextYAlignment.Center
			titleLabel.TextWrapped = true
			titleLabel.BorderSizePixel = 0
			titleLabel.LayoutOrder = 1
			titleLabel.ZIndex = 10
			titleLabel.Parent = headerFrame
		end

		if message and message ~= "" and messageBounds then
			local messageLabel = Instance.new("TextLabel")
			messageLabel.Name = "MessageLabel"
			messageLabel.Text = message
			messageLabel.Font = messageFont
			messageLabel.TextSize = messageSize
			messageLabel.TextColor3 = secondaryTextColor
			messageLabel.BackgroundTransparency = 1
			messageLabel.Size = UDim2.new(1, 0, 0, (messageBounds :: Vector2).Y)
			messageLabel.TextXAlignment = Enum.TextXAlignment.Center
			messageLabel.TextYAlignment = Enum.TextYAlignment.Top
			messageLabel.TextWrapped = true
			messageLabel.BorderSizePixel = 0
			messageLabel.LayoutOrder = 2
			messageLabel.ZIndex = 10
			messageLabel.Parent = headerFrame
		end

		-- Separator after header
		local headerSep = Instance.new("Frame")
		headerSep.Name = "HeaderSeparator"
		headerSep.Size = UDim2.new(1, 0, 0, 1)
		headerSep.Position = UDim2.new(0, 0, 0, headerHeight - 1)
		headerSep.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
		headerSep.BackgroundTransparency = 0.7
		headerSep.BorderSizePixel = 0
		headerSep.ZIndex = 10
		headerSep.Parent = actionsGlass.GlassSurface

		currentY = headerHeight
	end

	-- Action items
	for i, actionConfig in actions do
		-- Inter-action separator (not before first if no header, or always between actions)
		if i > 1 then
			local actionSep = Instance.new("Frame")
			actionSep.Name = "ActionSeparator" .. i
			actionSep.Size = UDim2.new(1, 0, 0, 1)
			actionSep.Position = UDim2.new(0, 0, 0, currentY)
			actionSep.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
			actionSep.BackgroundTransparency = 0.7
			actionSep.BorderSizePixel = 0
			actionSep.ZIndex = 10
			actionSep.Parent = actionsGlass.GlassSurface
			currentY = currentY + 1
		end

		local actionFrame = Instance.new("Frame")
		actionFrame.Name = "Action" .. i
		actionFrame.Size = UDim2.new(1, 0, 0, 56)
		actionFrame.Position = UDim2.new(0, 0, 0, currentY)
		actionFrame.BackgroundTransparency = 1
		actionFrame.BorderSizePixel = 0
		actionFrame.ZIndex = 10
		actionFrame.Parent = actionsGlass.GlassSurface

		local style = actionConfig.Style or "default"
		local actionTextColor: Color3
		if style == "destructive" then
			actionTextColor = Color3.fromRGB(255, 59, 48)
		else
			actionTextColor = primaryTextColor
		end

		local actionLabel = Instance.new("TextLabel")
		actionLabel.Name = "ActionLabel"
		actionLabel.Text = actionConfig.Text
		actionLabel.Font = Enum.Font.Gotham
		actionLabel.TextSize = 20
		actionLabel.TextColor3 = actionTextColor
		actionLabel.BackgroundTransparency = 1
		actionLabel.Size = UDim2.new(1, 0, 1, 0)
		actionLabel.TextXAlignment = Enum.TextXAlignment.Center
		actionLabel.TextYAlignment = Enum.TextYAlignment.Center
		actionLabel.TextTruncate = Enum.TextTruncate.AtEnd
		actionLabel.BorderSizePixel = 0
		actionLabel.ZIndex = 10
		actionLabel.Parent = actionFrame

		local hitArea = Instance.new("TextButton")
		hitArea.Name = "HitArea"
		hitArea.Size = UDim2.new(1, 0, 1, 0)
		hitArea.BackgroundTransparency = 1
		hitArea.Text = ""
		hitArea.BorderSizePixel = 0
		hitArea.ZIndex = 100
		hitArea.AutoButtonColor = false
		hitArea.Parent = actionFrame

		local conn = hitArea.Activated:Connect(function()
			if actionConfig.OnActivated then
				actionConfig.OnActivated()
			end
			if dismissFunc then
				dismissFunc()
			end
		end)
		table.insert(connections, conn)

		currentY = currentY + 56
	end

	-- Cancel Group
	local cancelGroupContainer = Instance.new("Frame")
	cancelGroupContainer.Name = "CancelGroupContainer"
	cancelGroupContainer.Size = UDim2.new(1, 0, 0, cancelGroupHeight)
	cancelGroupContainer.BackgroundTransparency = 1
	cancelGroupContainer.BorderSizePixel = 0
	cancelGroupContainer.LayoutOrder = 2
	cancelGroupContainer.Parent = sheetContainer

	local cancelGlass = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 14),
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 2,
		ShadowOffsetY = 1,
		ShadowSpread = 4,
		LightweightMode = true,
		Parent = cancelGroupContainer,
	})

	local cancelLabel = Instance.new("TextLabel")
	cancelLabel.Name = "CancelLabel"
	cancelLabel.Text = cancelText
	cancelLabel.Font = Enum.Font.GothamBold
	cancelLabel.TextSize = 20
	cancelLabel.TextColor3 = cancelButtonColor
	cancelLabel.BackgroundTransparency = 1
	cancelLabel.Size = UDim2.new(1, 0, 1, 0)
	cancelLabel.TextXAlignment = Enum.TextXAlignment.Center
	cancelLabel.TextYAlignment = Enum.TextYAlignment.Center
	cancelLabel.TextTruncate = Enum.TextTruncate.AtEnd
	cancelLabel.BorderSizePixel = 0
	cancelLabel.ZIndex = 10
	cancelLabel.Parent = cancelGlass.GlassSurface

	local cancelHitArea = Instance.new("TextButton")
	cancelHitArea.Name = "HitArea"
	cancelHitArea.Size = UDim2.new(1, 0, 1, 0)
	cancelHitArea.BackgroundTransparency = 1
	cancelHitArea.Text = ""
	cancelHitArea.BorderSizePixel = 0
	cancelHitArea.ZIndex = 100
	cancelHitArea.AutoButtonColor = false
	cancelHitArea.Parent = cancelGlass.GlassSurface

	local cancelConn = cancelHitArea.Activated:Connect(function()
		if dismissFunc then
			dismissFunc()
		end
	end)
	table.insert(connections, cancelConn)

	-- Overlay tap to dismiss
	local overlayHit = Instance.new("TextButton")
	overlayHit.Name = "OverlayHitArea"
	overlayHit.Size = UDim2.new(1, 0, 1, 0)
	overlayHit.BackgroundTransparency = 1
	overlayHit.Text = ""
	overlayHit.BorderSizePixel = 0
	overlayHit.ZIndex = 0
	overlayHit.AutoButtonColor = false
	overlayHit.Parent = overlay

	local overlayConn = overlayHit.Activated:Connect(function()
		if dismissFunc then
			dismissFunc()
		end
	end)
	table.insert(connections, overlayConn)

	-- Dismiss implementation
	local function doDismiss()
		if isDismissing or isDestroyed or not isShowing then
			return
		end
		isDismissing = true

		cancelAllTweens()
		local tweenOut = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

		-- Fade overlay out
		local overlayTween = TweenService:Create(overlay, tweenOut, {
			BackgroundTransparency = 1,
		})
		trackTween(overlayTween)
		overlayTween:Play()

		-- Slide sheet down
		local slideTween = TweenService:Create(sheetContainer, tweenOut, {
			Position = UDim2.new(0.5, 0, 1, 100),
		})
		trackTween(slideTween)
		slideTween:Play()

		slideTween.Completed:Once(function()
			if not isDestroyed then
				-- Set isDestroyed BEFORE callback to prevent re-entrancy
				isDestroyed = true
				if config.OnDismissed then
					config.OnDismissed()
				end
				cancelAllTweens()
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				actionsGlass:Destroy()
				cancelGlass:Destroy()
				sheetContainer:Destroy()
				overlay:Destroy()
				if screenGui then
					screenGui:Destroy()
				end
			end
		end)
	end

	dismissFunc = doDismiss

	-- Return table
	local self: Types.MangoActionSheet = {
		Show = function(self: Types.MangoActionSheet)
			if isShowing or isDestroyed then
				return
			end
			isShowing = true

			-- Start offscreen
			sheetContainer.Position = UDim2.new(0.5, 0, 1, 100)

			cancelAllTweens()

			-- Fade overlay in
			local overlayInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local overlayTween = TweenService:Create(overlay, overlayInfo, {
				BackgroundTransparency = overlayTransparency,
			})
			trackTween(overlayTween)
			overlayTween:Play()

			-- Slide sheet up
			local slideInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local slideTween = TweenService:Create(sheetContainer, slideInfo, {
				Position = UDim2.new(0.5, 0, 1, -8),
			})
			trackTween(slideTween)
			slideTween:Play()
		end,
		Dismiss = function(self: Types.MangoActionSheet)
			doDismiss()
		end,
		Destroy = function(self: Types.MangoActionSheet)
			if isDestroyed then
				return
			end
			isDestroyed = true

			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			actionsGlass:Destroy()
			cancelGlass:Destroy()
			sheetContainer:Destroy()
			overlay:Destroy()
			if screenGui then
				screenGui:Destroy()
			end
		end,
	}

	return self
end

return module

end

_modules["MangoDropdown"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")

local module = {}

function module.new(config: Types.MangoDropdownConfig): Types.MangoDropdown
	local theme = config.Theme
	local items = table.clone(resolve(config.Items, nil, {"Option 1"}) :: {string})
	local itemCount = #items

	-- Resolve config values
	local size = resolve(config.Size, nil, UDim2.new(0, 200, 0, 36)) :: UDim2
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local initialIndex = resolve(config.InitialIndex, nil, 1) :: number

	-- Theme values
	local primaryText = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local secondaryText = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3
	local dropdownBgTransparency = resolve(nil, theme and theme.DropdownBackgroundTransparency, 0.82) :: number
	local itemHoverColor = resolve(nil, theme and theme.DropdownItemHoverColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local itemHoverTransparency = resolve(nil, theme and theme.DropdownItemHoverTransparency, 0.85) :: number

	-- Multi-select support
	local isMultiSelect = config.MultiSelect == true
	local selectedIndices: {[number]: boolean} = {}

	-- State
	local selectedIndex: number = math.clamp(initialIndex, 1, math.max(itemCount, 1))
	local isOpen = false
	local isDestroyed = false
	local activeTweens: {Tween} = {}
	local itemHoverTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}
	local itemConnections: {RBXScriptConnection} = {}
	local clickBlocker: TextButton? = nil
	local positionTrackConn: RBXScriptConnection? = nil

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function cancelItemHoverTweens()
		for _, tween in itemHoverTweens do
			tween:Cancel()
		end
		table.clear(itemHoverTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	local function trackItemHoverTween(tween: Tween): Tween
		table.insert(itemHoverTweens, tween)
		return tween
	end

	-- Initialize multi-select
	if isMultiSelect and config.InitialItems then
		for _, itemName in config.InitialItems do
			for i, name in items do
				if name == itemName then
					selectedIndices[i] = true
				end
			end
		end
	elseif isMultiSelect then
		selectedIndices[selectedIndex] = true
	end

	local function getMultiSelectDisplayText(): string
		local selected: {string} = {}
		for i, item in items do
			if selectedIndices[i] then
				table.insert(selected, item)
			end
		end
		if #selected == 0 then return "Select..." end
		if #selected <= 2 then return table.concat(selected, ", ") end
		return #selected .. " selected"
	end

	-- Forward declaration for closeDropdown (used by click-blocker before definition)
	local closeDropdown: () -> ()

	-- Container (transparent wrapper, holds trigger + panel)
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Dropdown")
	container.Size = UDim2.new(size.X.Scale, size.X.Offset, size.Y.Scale, size.Y.Offset + 0)
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.ClipsDescendants = false

	local function findScreenGui(): ScreenGui?
		local current: Instance? = container
		while current do
			if current:IsA("ScreenGui") then
				return current :: ScreenGui
			end
			current = current.Parent
		end
		return nil
	end

	local function createClickBlocker()
		local screenGui = findScreenGui()
		if not screenGui then return end

		local blocker = Instance.new("TextButton")
		blocker.Name = MangoProtection.randomName("Blocker")
		blocker.Size = UDim2.new(1, 0, 1, 0)
		blocker.BackgroundTransparency = 1
		blocker.Text = ""
		blocker.ZIndex = 49
		blocker.AutoButtonColor = false
		blocker.Parent = screenGui
		clickBlocker = blocker

		blocker.MouseButton1Click:Connect(function()
			closeDropdown()
		end)
	end

	local function destroyClickBlocker()
		if clickBlocker then
			clickBlocker:Destroy()
			clickBlocker = nil
		end
	end

	-- Trigger button via MangoGlassFrame (LightweightMode)
	local triggerGlass = MangoGlassFrame.new({
		Size = size,
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 999),
		BackgroundTransparency = dropdownBgTransparency,
		Theme = theme,
		ShadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean,
		ShadowLayerCount = 2,
		ShadowSpread = 4,
		ShadowOffsetY = 1,
		LightweightMode = true,
		Parent = container,
	})

	-- SelectedLabel (left-aligned text)
	local selectedLabel = Instance.new("TextLabel")
	selectedLabel.Name = "SelectedLabel"
	selectedLabel.Size = UDim2.new(1, -40, 1, 0)
	selectedLabel.Position = UDim2.new(0, 14, 0, 0)
	selectedLabel.BackgroundTransparency = 1
	selectedLabel.BorderSizePixel = 0
	selectedLabel.Font = Enum.Font.GothamMedium
	selectedLabel.TextSize = 14
	selectedLabel.TextColor3 = primaryText
	selectedLabel.TextXAlignment = Enum.TextXAlignment.Left
	selectedLabel.TextTruncate = Enum.TextTruncate.AtEnd
	selectedLabel.Text = if isMultiSelect then getMultiSelectDisplayText() elseif itemCount > 0 then items[selectedIndex] else ""
	selectedLabel.ZIndex = 10
	selectedLabel.Parent = triggerGlass.GlassSurface

	-- Chevron (right side)
	local chevronLabel = Instance.new("TextLabel")
	chevronLabel.Name = "ChevronLabel"
	chevronLabel.Size = UDim2.new(0, 20, 1, 0)
	chevronLabel.Position = UDim2.new(1, -28, 0, 0)
	chevronLabel.BackgroundTransparency = 1
	chevronLabel.BorderSizePixel = 0
	chevronLabel.Font = Enum.Font.GothamMedium
	chevronLabel.TextSize = 10
	chevronLabel.TextColor3 = secondaryText
	chevronLabel.Text = "v"
	chevronLabel.ZIndex = 10
	chevronLabel.Parent = triggerGlass.GlassSurface

	-- HitArea on trigger
	local triggerHitArea = Instance.new("TextButton")
	triggerHitArea.Name = "HitArea"
	triggerHitArea.Size = UDim2.new(1, 0, 1, 0)
	triggerHitArea.BackgroundTransparency = 1
	triggerHitArea.Text = ""
	triggerHitArea.BorderSizePixel = 0
	triggerHitArea.ZIndex = 100
	triggerHitArea.AutoButtonColor = false
	triggerHitArea.Parent = triggerGlass.GlassSurface

	-- Dropdown panel (below trigger)
	local maxVisibleItems = 5
	local itemHeight = 36
	local panelItemCount = math.min(itemCount, maxVisibleItems)
	local panelHeight = panelItemCount * itemHeight + 8

	local panelGlass = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 0, panelHeight),
		Position = UDim2.new(0, 0, 0, size.Y.Offset + 4),
		CornerRadius = UDim.new(0, 12),
		BackgroundTransparency = dropdownBgTransparency - 0.05,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 4,
		ShadowSpread = 6,
		ShadowOffsetY = 2,
		LightweightMode = true,
		Parent = container,
	})
	panelGlass.Container.Visible = false
	panelGlass.Container.ZIndex = 50

	-- UIScale for open animation
	local panelUIScale = Instance.new("UIScale")
	panelUIScale.Scale = 0.92
	panelUIScale.Parent = panelGlass.Container

	-- ScrollingFrame inside panel GlassSurface
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ScrollFrame"
	scrollFrame.Size = UDim2.new(1, 0, 1, 0)
	scrollFrame.Position = UDim2.new(0, 0, 0, 0)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = if itemCount > maxVisibleItems then 4 else 0
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, itemCount * itemHeight)
	scrollFrame.ScrollingDirection = Enum.ScrollingDirection.Y
	scrollFrame.ZIndex = 10
	scrollFrame.Parent = panelGlass.GlassSurface

	local scrollPadding = Instance.new("UIPadding")
	scrollPadding.PaddingTop = UDim.new(0, 4)
	scrollPadding.PaddingBottom = UDim.new(0, 4)
	scrollPadding.Parent = scrollFrame

	local scrollLayout = Instance.new("UIListLayout")
	scrollLayout.FillDirection = Enum.FillDirection.Vertical
	scrollLayout.SortOrder = Enum.SortOrder.LayoutOrder
	scrollLayout.Padding = UDim.new(0, 0)
	scrollLayout.Parent = scrollFrame

	-- Build item list
	local itemFrames: {Frame} = {}

	local function clearItemConnections()
		for _, conn in itemConnections do
			conn:Disconnect()
		end
		table.clear(itemConnections)
	end

	local function buildItems()
		-- Clear old items
		clearItemConnections()
		for _, frame in itemFrames do
			frame:Destroy()
		end
		table.clear(itemFrames)

		for i = 1, #items do
			local itemFrame = Instance.new("Frame")
			itemFrame.Name = "Item" .. i
			itemFrame.Size = UDim2.new(1, 0, 0, itemHeight)
			itemFrame.BackgroundColor3 = itemHoverColor
			itemFrame.BackgroundTransparency = 1
			itemFrame.BorderSizePixel = 0
			itemFrame.LayoutOrder = i
			itemFrame.Parent = scrollFrame

			local itemCorner = Instance.new("UICorner")
			itemCorner.CornerRadius = UDim.new(0, 8)
			itemCorner.Parent = itemFrame

			local itemLabel = Instance.new("TextLabel")
			itemLabel.Name = "ItemLabel"
			itemLabel.Size = UDim2.new(1, -48, 1, 0)
			itemLabel.Position = UDim2.new(0, 12, 0, 0)
			itemLabel.BackgroundTransparency = 1
			itemLabel.BorderSizePixel = 0
			itemLabel.Font = Enum.Font.GothamMedium
			itemLabel.TextSize = 14
			itemLabel.TextColor3 = if i == selectedIndex then primaryText else secondaryText
			itemLabel.TextXAlignment = Enum.TextXAlignment.Left
			itemLabel.TextTruncate = Enum.TextTruncate.AtEnd
			itemLabel.Text = items[i]
			itemLabel.ZIndex = 10
			itemLabel.Parent = itemFrame

			local checkLabel = Instance.new("TextLabel")
			checkLabel.Name = "CheckLabel"
			checkLabel.Size = UDim2.new(0, 20, 1, 0)
			checkLabel.Position = UDim2.new(1, -28, 0, 0)
			checkLabel.BackgroundTransparency = 1
			checkLabel.BorderSizePixel = 0
			checkLabel.Font = Enum.Font.SourceSansBold
			checkLabel.TextSize = 14
			checkLabel.TextColor3 = primaryText
			if isMultiSelect then
				checkLabel.Text = if selectedIndices[i] then "\226\152\145" else "\226\152\144" -- checkbox style
			else
				checkLabel.Text = if i == selectedIndex then "\226\156\147" else "" -- checkmark
			end
			checkLabel.ZIndex = 10
			checkLabel.Parent = itemFrame

			if i < #items then
				local sep = Instance.new("Frame")
				sep.Name = "Separator"
				sep.Size = UDim2.new(1, -24, 0, 1)
				sep.Position = UDim2.new(0, 12, 1, 0)
				sep.BackgroundColor3 = resolve(nil, theme and theme.BackgroundColor3, Color3.fromRGB(230, 230, 235)) :: Color3
				sep.BackgroundTransparency = 0.80
				sep.BorderSizePixel = 0
				sep.ZIndex = 5
				sep.Parent = itemFrame
			end

			local itemHitArea = Instance.new("TextButton")
			itemHitArea.Name = "HitArea"
			itemHitArea.Size = UDim2.new(1, 0, 1, 0)
			itemHitArea.BackgroundTransparency = 1
			itemHitArea.Text = ""
			itemHitArea.BorderSizePixel = 0
			itemHitArea.ZIndex = 100
			itemHitArea.AutoButtonColor = false
			itemHitArea.Parent = itemFrame

			-- Hover highlight (tweened — uses separate tween array to avoid cancelling panel tweens)
			local hoverEnter = itemHitArea.MouseEnter:Connect(function()
				cancelItemHoverTweens()
				local tw = TweenService:Create(itemFrame, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					BackgroundTransparency = itemHoverTransparency,
				})
				trackItemHoverTween(tw)
				tw:Play()
			end)
			table.insert(itemConnections, hoverEnter)

			local hoverLeave = itemHitArea.MouseLeave:Connect(function()
				cancelItemHoverTweens()
				local tw = TweenService:Create(itemFrame, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					BackgroundTransparency = 1,
				})
				trackItemHoverTween(tw)
				tw:Play()
			end)
			table.insert(itemConnections, hoverLeave)

			-- Click
			local clickConn = itemHitArea.MouseButton1Click:Connect(function()
				if isMultiSelect then
					-- Toggle selection for this item
					selectedIndices[i] = not selectedIndices[i] or nil
					selectedLabel.Text = getMultiSelectDisplayText()
					-- Update all checkmarks for multi-select
					for j, f in itemFrames do
						local lbl = f:FindFirstChild("ItemLabel")
						if lbl and lbl:IsA("TextLabel") then
							lbl.TextColor3 = if selectedIndices[j] then primaryText else secondaryText
						end
						local chk = f:FindFirstChild("CheckLabel")
						if chk and chk:IsA("TextLabel") then
							chk.Text = if selectedIndices[j] then "\226\152\145" else "\226\152\144"
						end
					end
					-- Fire multi-select callback
					if config.OnMultiChanged then
						local selected: {string} = {}
						for si, item in items do
							if selectedIndices[si] then
								table.insert(selected, item)
							end
						end
						config.OnMultiChanged(selected)
					end
					-- Don't close dropdown in multi-select mode
				else
					selectedIndex = i
					selectedLabel.Text = items[i]
					-- Update all item label colors and checkmarks
					for j, f in itemFrames do
						local lbl = f:FindFirstChild("ItemLabel")
						if lbl and lbl:IsA("TextLabel") then
							lbl.TextColor3 = if j == i then primaryText else secondaryText
						end
						local chk = f:FindFirstChild("CheckLabel")
						if chk and chk:IsA("TextLabel") then
							chk.Text = if j == i then "\226\156\147" else ""
						end
					end
					closeDropdown()
					if config.OnChanged then
						config.OnChanged(i)
					end
				end
			end)
			table.insert(itemConnections, clickConn)

			table.insert(itemFrames, itemFrame)
		end

		-- Update scroll canvas size
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, #items * itemHeight)
		scrollFrame.ScrollBarThickness = if #items > maxVisibleItems then 4 else 0

		-- Update panel height
		local newPanelItemCount = math.min(#items, maxVisibleItems)
		local newPanelHeight = newPanelItemCount * itemHeight + 8
		panelGlass.Container.Size = UDim2.new(1, 0, 0, newPanelHeight)
	end

	-- Open/Close
	closeDropdown = function()
		if not isOpen then
			return
		end
		isOpen = false
		cancelAllTweens()
		destroyClickBlocker()

		-- Stop tracking trigger position
		if positionTrackConn then
			positionTrackConn:Disconnect()
			positionTrackConn = nil
		end

		local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local scaleTween = TweenService:Create(panelUIScale, tweenInfo, { Scale = 0.95 })
		trackTween(scaleTween)
		scaleTween:Play()

		local fadeTween = TweenService:Create(panelGlass.GlassSurface, tweenInfo, {
			BackgroundTransparency = 1,
		})
		trackTween(fadeTween)
		fadeTween:Play()

		scaleTween.Completed:Once(function()
			if isDestroyed then return end
			panelGlass.Container.Visible = false
			-- Restore panel parent to container
			panelGlass.Container.Parent = container
			panelGlass.Container.Position = UDim2.new(0, 0, 0, size.Y.Offset + 4)
			panelGlass.Container.Size = UDim2.new(1, 0, 0, panelGlass.Container.Size.Y.Offset)
		end)
	end

	local function openDropdown()
		if isOpen then
			return
		end
		isOpen = true
		cancelAllTweens()
		createClickBlocker()

		-- Reparent panel to ScreenGui for proper Z layering
		local screenGui = findScreenGui()
		if screenGui then
			local triggerAbsPos = triggerGlass.Container.AbsolutePosition
			local triggerAbsSize = triggerGlass.Container.AbsoluteSize
			panelGlass.Container.Parent = screenGui
			panelGlass.Container.Position = UDim2.new(0, triggerAbsPos.X, 0, triggerAbsPos.Y + triggerAbsSize.Y + 4)
			panelGlass.Container.Size = UDim2.new(0, triggerAbsSize.X, 0, panelGlass.Container.Size.Y.Offset)

			-- Track trigger position changes so panel follows window drag/scroll
			if positionTrackConn then
				positionTrackConn:Disconnect()
				positionTrackConn = nil
			end
			positionTrackConn = triggerGlass.Container:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
				if not isOpen or isDestroyed then return end
				local newPos = triggerGlass.Container.AbsolutePosition
				local newSize = triggerGlass.Container.AbsoluteSize
				panelGlass.Container.Position = UDim2.new(0, newPos.X, 0, newPos.Y + newSize.Y + 4)
			end)
		end

		panelGlass.Container.Visible = true
		panelGlass.Container.ZIndex = 50
		panelUIScale.Scale = 0.92
		panelGlass.GlassSurface.BackgroundTransparency = 1

		local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local scaleTween = TweenService:Create(panelUIScale, tweenInfo, { Scale = 1 })
		trackTween(scaleTween)
		scaleTween:Play()

		local fadeTween = TweenService:Create(panelGlass.GlassSurface, tweenInfo, {
			BackgroundTransparency = dropdownBgTransparency - 0.05,
		})
		trackTween(fadeTween)
		fadeTween:Play()
	end

	-- Toggle on trigger click
	local triggerConn = triggerHitArea.MouseButton1Click:Connect(function()
		if isOpen then
			closeDropdown()
		else
			openDropdown()
		end
	end)
	table.insert(connections, triggerConn)

	-- Build initial items
	buildItems()

	-- Parent assignment
	if config.Parent then
		container.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoDropdown = {
		Container = container,
		SetSelectedIndex = function(self: Types.MangoDropdown, index: number)
			if index >= 1 and index <= #items then
				selectedIndex = index
				selectedLabel.Text = items[index]
			end
		end,
		GetSelectedIndex = function(self: Types.MangoDropdown): number
			return selectedIndex
		end,
		SetItems = function(self: Types.MangoDropdown, newItems: {string})
			if isOpen then
				closeDropdown()
			end
			items = table.clone(newItems)
			selectedIndex = math.clamp(selectedIndex, 1, math.max(#items, 1))
			if isMultiSelect then
				-- Clear selections that no longer exist
				local newIndices: {[number]: boolean} = {}
				for si, _ in selectedIndices do
					if si <= #items then
						newIndices[si] = true
					end
				end
				selectedIndices = newIndices
				selectedLabel.Text = getMultiSelectDisplayText()
			else
				selectedLabel.Text = if #items > 0 then items[selectedIndex] else ""
			end
			buildItems()
		end,
		GetSelectedItems = function(self: Types.MangoDropdown): {string}
			if not isMultiSelect then return {items[selectedIndex]} end
			local result: {string} = {}
			for i, item in items do
				if selectedIndices[i] then
					table.insert(result, item)
				end
			end
			return result
		end,
		Open = function(self: Types.MangoDropdown)
			openDropdown()
		end,
		Close = function(self: Types.MangoDropdown)
			closeDropdown()
		end,
		Destroy = function(self: Types.MangoDropdown)
			isDestroyed = true
			cancelAllTweens()
			cancelItemHoverTweens()
			clearItemConnections()
			destroyClickBlocker()
			if positionTrackConn then
				positionTrackConn:Disconnect()
				positionTrackConn = nil
			end
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			triggerGlass:Destroy()
			panelGlass:Destroy()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoContextMenu"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local module = {}

function module.new(config: Types.MangoContextMenuConfig): Types.MangoContextMenu
	local theme = config.Theme
	local items = table.clone(resolve(config.Items, nil, {{Text = "Item"}}) :: {Types.MangoContextMenuItemConfig})
	local target = config.Target

	-- Theme values (reuse dropdown theme fields)
	local primaryText = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local secondaryText = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3
	local dropdownBgTransparency = resolve(nil, theme and theme.DropdownBackgroundTransparency, 0.82) :: number
	local itemHoverColor = resolve(nil, theme and theme.DropdownItemHoverColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local itemHoverTransparency = resolve(nil, theme and theme.DropdownItemHoverTransparency, 0.85) :: number
	local bgColor = resolve(nil, theme and theme.BackgroundColor3, Color3.fromRGB(230, 230, 235)) :: Color3

	-- State
	local isOpen = false
	local isDestroyed = false
	local activeTweens: {Tween} = {}
	local itemHoverTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}
	local itemConnections: {RBXScriptConnection} = {}
	local clickBlocker: TextButton? = nil
	local longPressThread: thread? = nil

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function cancelItemHoverTweens()
		for _, tween in itemHoverTweens do
			tween:Cancel()
		end
		table.clear(itemHoverTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	local function trackItemHoverTween(tween: Tween): Tween
		table.insert(itemHoverTweens, tween)
		return tween
	end

	-- Forward declaration for closeMenu
	local closeMenu: () -> ()

	-- Find ScreenGui by walking ancestors
	local function findScreenGui(): ScreenGui?
		local current: Instance? = target
		while current do
			if current:IsA("ScreenGui") then
				return current :: ScreenGui
			end
			current = current.Parent
		end
		return nil
	end

	-- Click blocker management
	local function createClickBlocker()
		local screenGui = findScreenGui()
		if not screenGui then return end

		local blocker = Instance.new("TextButton")
		blocker.Name = MangoProtection.randomName("Blocker")
		blocker.Size = UDim2.new(1, 0, 1, 0)
		blocker.BackgroundTransparency = 1
		blocker.Text = ""
		blocker.ZIndex = 49
		blocker.AutoButtonColor = false
		blocker.Parent = screenGui
		clickBlocker = blocker

		blocker.MouseButton1Click:Connect(function()
			closeMenu()
		end)
	end

	local function destroyClickBlocker()
		if clickBlocker then
			clickBlocker:Destroy()
			clickBlocker = nil
		end
	end

	-- Panel glass frame
	local itemHeight = 36
	local maxVisibleItems = 8
	local panelItemCount = math.min(#items, maxVisibleItems)
	local panelHeight = panelItemCount * itemHeight + 8

	local panelGlass = MangoGlassFrame.new({
		Size = UDim2.new(0, 200, 0, panelHeight),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 12),
		BackgroundTransparency = dropdownBgTransparency - 0.05,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 4,
		ShadowSpread = 6,
		ShadowOffsetY = 2,
		LightweightMode = true,
	})
	panelGlass.Container.Visible = false
	panelGlass.Container.ZIndex = 50

	-- UIScale for open/close animation
	local panelUIScale = Instance.new("UIScale")
	panelUIScale.Scale = 0.92
	panelUIScale.Parent = panelGlass.Container

	-- ScrollingFrame inside panel GlassSurface
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ScrollFrame"
	scrollFrame.Size = UDim2.new(1, 0, 1, 0)
	scrollFrame.Position = UDim2.new(0, 0, 0, 0)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = if #items > maxVisibleItems then 4 else 0
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, #items * itemHeight)
	scrollFrame.ScrollingDirection = Enum.ScrollingDirection.Y
	scrollFrame.ZIndex = 10
	scrollFrame.Parent = panelGlass.GlassSurface

	local scrollPadding = Instance.new("UIPadding")
	scrollPadding.PaddingTop = UDim.new(0, 4)
	scrollPadding.PaddingBottom = UDim.new(0, 4)
	scrollPadding.Parent = scrollFrame

	local scrollLayout = Instance.new("UIListLayout")
	scrollLayout.FillDirection = Enum.FillDirection.Vertical
	scrollLayout.SortOrder = Enum.SortOrder.LayoutOrder
	scrollLayout.Padding = UDim.new(0, 0)
	scrollLayout.Parent = scrollFrame

	-- Item frames storage
	local itemFrames: {Frame} = {}

	local function clearItemConnections()
		for _, conn in itemConnections do
			conn:Disconnect()
		end
		table.clear(itemConnections)
	end

	local function buildItems()
		-- Clear old items
		clearItemConnections()
		for _, frame in itemFrames do
			frame:Destroy()
		end
		table.clear(itemFrames)

		for i = 1, #items do
			local itemConfig = items[i]
			local itemFrame = Instance.new("Frame")
			itemFrame.Name = "Item" .. i
			itemFrame.Size = UDim2.new(1, 0, 0, itemHeight)
			itemFrame.BackgroundColor3 = itemHoverColor
			itemFrame.BackgroundTransparency = 1
			itemFrame.BorderSizePixel = 0
			itemFrame.LayoutOrder = i
			itemFrame.Parent = scrollFrame

			local itemCorner = Instance.new("UICorner")
			itemCorner.CornerRadius = UDim.new(0, 8)
			itemCorner.Parent = itemFrame

			-- Determine text offset based on icon presence
			local hasIcon = itemConfig.Icon ~= nil and itemConfig.Icon ~= ""
			local textOffsetX = if hasIcon then 36 else 12

			-- Optional icon label (left side)
			if hasIcon then
				local iconLabel = Instance.new("TextLabel")
				iconLabel.Name = "IconLabel"
				iconLabel.Size = UDim2.new(0, 20, 1, 0)
				iconLabel.Position = UDim2.new(0, 10, 0, 0)
				iconLabel.BackgroundTransparency = 1
				iconLabel.BorderSizePixel = 0
				iconLabel.Font = Enum.Font.Gotham
				iconLabel.TextSize = 16
				iconLabel.TextColor3 = primaryText
				iconLabel.Text = itemConfig.Icon :: string
				iconLabel.ZIndex = 10
				iconLabel.Parent = itemFrame
			end

			-- Determine text color based on style and disabled state
			local style = itemConfig.Style or "default"
			local isDisabled = itemConfig.Disabled == true
			local textColor: Color3
			if style == "destructive" then
				textColor = Color3.fromRGB(255, 59, 48)
			else
				textColor = primaryText
			end

			local itemLabel = Instance.new("TextLabel")
			itemLabel.Name = "ItemLabel"
			itemLabel.Size = UDim2.new(1, -(textOffsetX + 12), 1, 0)
			itemLabel.Position = UDim2.new(0, textOffsetX, 0, 0)
			itemLabel.BackgroundTransparency = 1
			itemLabel.BorderSizePixel = 0
			itemLabel.Font = Enum.Font.GothamMedium
			itemLabel.TextSize = 14
			itemLabel.TextColor3 = textColor
			itemLabel.TextTransparency = if isDisabled then 0.5 else 0
			itemLabel.TextXAlignment = Enum.TextXAlignment.Left
			itemLabel.TextTruncate = Enum.TextTruncate.AtEnd
			itemLabel.Text = itemConfig.Text
			itemLabel.ZIndex = 10
			itemLabel.Parent = itemFrame

			-- Separator between items
			if i < #items then
				local sep = Instance.new("Frame")
				sep.Name = "Separator"
				sep.Size = UDim2.new(1, -24, 0, 1)
				sep.Position = UDim2.new(0, 12, 1, 0)
				sep.BackgroundColor3 = bgColor
				sep.BackgroundTransparency = 0.80
				sep.BorderSizePixel = 0
				sep.ZIndex = 5
				sep.Parent = itemFrame
			end

			local itemHitArea = Instance.new("TextButton")
			itemHitArea.Name = "HitArea"
			itemHitArea.Size = UDim2.new(1, 0, 1, 0)
			itemHitArea.BackgroundTransparency = 1
			itemHitArea.Text = ""
			itemHitArea.BorderSizePixel = 0
			itemHitArea.ZIndex = 100
			itemHitArea.AutoButtonColor = false
			itemHitArea.Parent = itemFrame

			-- Hover highlight (skip for disabled items)
			if not isDisabled then
				local hoverEnter = itemHitArea.MouseEnter:Connect(function()
					cancelItemHoverTweens()
					local tw = TweenService:Create(itemFrame, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
						BackgroundTransparency = itemHoverTransparency,
					})
					trackItemHoverTween(tw)
					tw:Play()
				end)
				table.insert(itemConnections, hoverEnter)

				local hoverLeave = itemHitArea.MouseLeave:Connect(function()
					cancelItemHoverTweens()
					local tw = TweenService:Create(itemFrame, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
						BackgroundTransparency = 1,
					})
					trackItemHoverTween(tw)
					tw:Play()
				end)
				table.insert(itemConnections, hoverLeave)

				-- Click handler
				local clickConn = itemHitArea.MouseButton1Click:Connect(function()
					closeMenu()
					if itemConfig.OnActivated then
						itemConfig.OnActivated()
					end
				end)
				table.insert(itemConnections, clickConn)
			end

			table.insert(itemFrames, itemFrame)
		end

		-- Update scroll canvas size
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, #items * itemHeight)
		scrollFrame.ScrollBarThickness = if #items > maxVisibleItems then 4 else 0

		-- Update panel height
		local newPanelItemCount = math.min(#items, maxVisibleItems)
		local newPanelHeight = newPanelItemCount * itemHeight + 8
		panelGlass.Container.Size = UDim2.new(0, 200, 0, newPanelHeight)
	end

	-- Open/Close
	closeMenu = function()
		if not isOpen then
			return
		end
		isOpen = false
		cancelAllTweens()
		destroyClickBlocker()

		local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local scaleTween = TweenService:Create(panelUIScale, tweenInfo, { Scale = 0.95 })
		trackTween(scaleTween)
		scaleTween:Play()

		local fadeTween = TweenService:Create(panelGlass.GlassSurface, tweenInfo, {
			BackgroundTransparency = 1,
		})
		trackTween(fadeTween)
		fadeTween:Play()

		scaleTween.Completed:Once(function()
			if isDestroyed then return end
			panelGlass.Container.Visible = false
		end)
	end

	local function openMenu(position: Vector2?)
		if isOpen then
			closeMenu()
		end
		if isDestroyed then return end
		isOpen = true
		cancelAllTweens()
		createClickBlocker()

		-- Determine position
		local menuPos: Vector2
		if position then
			menuPos = position
		else
			local mouseLocation = UserInputService:GetMouseLocation()
			menuPos = mouseLocation
		end

		-- Reparent panel to ScreenGui for proper Z layering
		local screenGui = findScreenGui()
		if screenGui then
			panelGlass.Container.Parent = screenGui
			panelGlass.Container.Position = UDim2.new(0, menuPos.X, 0, menuPos.Y)
		end

		panelGlass.Container.Visible = true
		panelGlass.Container.ZIndex = 50
		panelUIScale.Scale = 0.92
		panelGlass.GlassSurface.BackgroundTransparency = 1

		local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local scaleTween = TweenService:Create(panelUIScale, tweenInfo, { Scale = 1 })
		trackTween(scaleTween)
		scaleTween:Play()

		local fadeTween = TweenService:Create(panelGlass.GlassSurface, tweenInfo, {
			BackgroundTransparency = dropdownBgTransparency - 0.05,
		})
		trackTween(fadeTween)
		fadeTween:Play()
	end

	-- Bind right-click to target
	local targetHitArea: TextButton? = nil

	-- Check if target already has a TextButton child we can use, otherwise create one
	local existingHit = target:FindFirstChild("ContextMenuHitArea")
	if existingHit and existingHit:IsA("TextButton") then
		targetHitArea = existingHit :: TextButton
	else
		local hitArea = Instance.new("TextButton")
		hitArea.Name = "ContextMenuHitArea"
		hitArea.Size = UDim2.new(1, 0, 1, 0)
		hitArea.BackgroundTransparency = 1
		hitArea.Text = ""
		hitArea.BorderSizePixel = 0
		hitArea.ZIndex = 99
		hitArea.AutoButtonColor = false
		hitArea.Parent = target
		targetHitArea = hitArea
	end

	-- Right-click binding
	local rightClickConn = (targetHitArea :: TextButton).MouseButton2Click:Connect(function()
		local mouseLocation = UserInputService:GetMouseLocation()
		openMenu(mouseLocation)
	end)
	table.insert(connections, rightClickConn)

	-- Touch long-press binding (0.5s hold)
	local touchConn = (targetHitArea :: TextButton).InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.Touch then
			local touchPos = input.Position
			longPressThread = task.delay(0.5, function()
				longPressThread = nil
				openMenu(Vector2.new(touchPos.X, touchPos.Y))
			end)
		end
	end)
	table.insert(connections, touchConn)

	local touchEndConn = (targetHitArea :: TextButton).InputEnded:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.Touch then
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
		end
	end)
	table.insert(connections, touchEndConn)

	-- Build initial items
	buildItems()

	-- Parent assignment
	if config.Parent then
		panelGlass.Container.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoContextMenu = {
		Open = function(self: Types.MangoContextMenu, position: Vector2?)
			openMenu(position)
		end,
		Close = function(self: Types.MangoContextMenu)
			closeMenu()
		end,
		SetItems = function(self: Types.MangoContextMenu, newItems: {Types.MangoContextMenuItemConfig})
			items = table.clone(newItems)
			buildItems()
		end,
		Destroy = function(self: Types.MangoContextMenu)
			if isDestroyed then return end
			isDestroyed = true
			closeMenu()
			cancelAllTweens()
			cancelItemHoverTweens()
			clearItemConnections()
			destroyClickBlocker()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
			if targetHitArea and targetHitArea.Name == "ContextMenuHitArea" then
				targetHitArea:Destroy()
			end
			panelGlass:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoTabBar"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")

local module = {}

function module.new(config: Types.MangoTabBarConfig): Types.MangoTabBar
	local theme = config.Theme
	local tabs = resolve(config.Tabs, nil, {{Label = "Tab"}}) :: {{Icon: string?, Label: string}}
	local tabCount = #tabs

	-- Resolve config values
	local initialIndex = resolve(config.InitialIndex, nil, 1) :: number

	-- Theme values
	local bgTransparency = resolve(nil, theme and theme.TabBarBackgroundTransparency, 0.82) :: number
	local selectedColor = resolve(nil, theme and theme.TabBarSelectedColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local iconColor = resolve(nil, theme and theme.TabBarIconColor, Color3.fromRGB(140, 140, 150)) :: Color3
	local iconSelectedColor = resolve(nil, theme and theme.TabBarIconSelectedColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local secondaryText = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3

	-- State
	local currentIndex: number = math.clamp(initialIndex, 1, tabCount)
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Container (full width, 54px tall, anchored to bottom)
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("TabBar")
	container.Size = UDim2.new(1, 0, 0, 54)
	container.Position = UDim2.new(0, 0, 1, 0)
	container.AnchorPoint = Vector2.new(0, 1)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	-- MangoGlassFrame (full tab bar background)
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 0),
		BackgroundTransparency = bgTransparency,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 2,
		ShadowSpread = 6,
		ShadowOffsetY = -2,
		LightweightMode = true,
		Parent = container,
	})

	-- Layout inside GlassSurface
	local tabLayout = Instance.new("UIListLayout")
	tabLayout.FillDirection = Enum.FillDirection.Horizontal
	tabLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	tabLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	tabLayout.SortOrder = Enum.SortOrder.LayoutOrder
	tabLayout.Padding = UDim.new(0, 0)
	tabLayout.Parent = glassFrame.GlassSurface

	-- Tab items
	local tabFrames: {Frame} = {}
	local iconLabels: {TextLabel} = {}
	local textLabels: {TextLabel} = {}
	local dotFrames: {Frame} = {}

	for i = 1, tabCount do
		local tab = tabs[i]
		local hasIcon = tab.Icon ~= nil and tab.Icon ~= ""
		local isSelected = i == currentIndex

		local tabFrame = Instance.new("Frame")
		tabFrame.Name = "Tab" .. i
		tabFrame.Size = UDim2.new(1 / tabCount, 0, 1, 0)
		tabFrame.BackgroundTransparency = 1
		tabFrame.BorderSizePixel = 0
		tabFrame.LayoutOrder = i
		tabFrame.Parent = glassFrame.GlassSurface

		-- Icon (if provided)
		local iconLabel = Instance.new("TextLabel")
		iconLabel.Name = "IconLabel"
		iconLabel.Size = UDim2.new(1, 0, 0, 24)
		iconLabel.Position = UDim2.new(0, 0, 0, 4)
		iconLabel.BackgroundTransparency = 1
		iconLabel.BorderSizePixel = 0
		iconLabel.Font = Enum.Font.Gotham
		iconLabel.TextSize = 20
		iconLabel.Text = if hasIcon then (tab.Icon :: string) else ""
		iconLabel.TextColor3 = if isSelected then iconSelectedColor else iconColor
		iconLabel.TextXAlignment = Enum.TextXAlignment.Center
		iconLabel.TextYAlignment = Enum.TextYAlignment.Center
		iconLabel.Visible = hasIcon
		iconLabel.ZIndex = 5
		iconLabel.Parent = tabFrame

		-- Tab label
		local textLabel = Instance.new("TextLabel")
		textLabel.Name = "TabLabel"
		textLabel.Size = UDim2.new(1, 0, 0, 14)
		textLabel.Position = if hasIcon then UDim2.new(0, 0, 0, 28) else UDim2.new(0, 0, 0.5, -7)
		textLabel.BackgroundTransparency = 1
		textLabel.BorderSizePixel = 0
		textLabel.Font = Enum.Font.GothamMedium
		textLabel.TextSize = 11
		textLabel.Text = tab.Label
		textLabel.TextColor3 = if isSelected then selectedColor else secondaryText
		textLabel.TextXAlignment = Enum.TextXAlignment.Center
		textLabel.TextYAlignment = Enum.TextYAlignment.Center
		textLabel.ZIndex = 5
		textLabel.Parent = tabFrame

		-- Selected dot
		local dot = Instance.new("Frame")
		dot.Name = "SelectedDot"
		dot.Size = UDim2.new(0, 4, 0, 4)
		dot.AnchorPoint = Vector2.new(0.5, 0)
		dot.Position = if hasIcon then UDim2.new(0.5, 0, 0, 44) else UDim2.new(0.5, 0, 0, 38)
		dot.BackgroundColor3 = selectedColor
		dot.BackgroundTransparency = 0
		dot.BorderSizePixel = 0
		dot.Visible = isSelected
		dot.ZIndex = 5
		dot.Parent = tabFrame

		local dotCorner = Instance.new("UICorner")
		dotCorner.CornerRadius = UDim.new(0, 999)
		dotCorner.Parent = dot

		-- HitArea
		local hitArea = Instance.new("TextButton")
		hitArea.Name = "HitArea"
		hitArea.Size = UDim2.new(1, 0, 1, 0)
		hitArea.BackgroundTransparency = 1
		hitArea.Text = ""
		hitArea.BorderSizePixel = 0
		hitArea.ZIndex = 100
		hitArea.AutoButtonColor = false
		hitArea.Parent = tabFrame

		table.insert(tabFrames, tabFrame)
		table.insert(iconLabels, iconLabel)
		table.insert(textLabels, textLabel)
		table.insert(dotFrames, dot)
	end

	-- Selection logic
	local function selectIndex(index: number)
		if index < 1 or index > tabCount then
			return
		end
		cancelAllTweens()
		currentIndex = index

		local colorInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

		for i = 1, tabCount do
			local isSelected = i == index

			-- Animate icon color
			local iconTween = TweenService:Create(iconLabels[i], colorInfo, {
				TextColor3 = if isSelected then iconSelectedColor else iconColor,
			})
			trackTween(iconTween)
			iconTween:Play()

			-- Animate text color
			local textTween = TweenService:Create(textLabels[i], colorInfo, {
				TextColor3 = if isSelected then selectedColor else secondaryText,
			})
			trackTween(textTween)
			textTween:Play()

			-- Show/hide dot
			dotFrames[i].Visible = isSelected
		end
	end

	-- Wire click handlers
	for i = 1, tabCount do
		local hitArea = tabFrames[i]:FindFirstChild("HitArea") :: TextButton
		local conn = hitArea.MouseButton1Click:Connect(function()
			if currentIndex ~= i then
				selectIndex(i)
				if config.OnChanged then
					config.OnChanged(i)
				end
			end
		end)
		table.insert(connections, conn)
	end

	-- Parent assignment
	if config.Parent then
		container.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoTabBar = {
		Container = container,
		SetIndex = function(self: Types.MangoTabBar, index: number)
			selectIndex(index)
		end,
		GetIndex = function(self: Types.MangoTabBar): number
			return currentIndex
		end,
		Destroy = function(self: Types.MangoTabBar)
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoBillboardLabel"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TextService = game:GetService("TextService")

local module = {}

function module.new(config: Types.MangoBillboardLabelConfig): Types.MangoBillboardLabel
	-- Determine target part
	local targetPart: BasePart? = config.TargetPart
	if not targetPart and config.TargetCharacter then
		targetPart = config.TargetCharacter:FindFirstChild("Head") :: BasePart?
	end

	-- Resolve config values with nil-safe helper
	local theme = config.Theme
	local text = resolve(config.Text, nil, "Label") :: string
	local textSize = resolve(config.TextSize, nil, 14) :: number
	local maxDistance = resolve(config.MaxDistance, nil, 50) :: number
	local studsOffset = resolve(config.StudsOffset, nil, Vector3.new(0, 2.2, 0)) :: Vector3
	local alwaysOnTop = resolve(config.AlwaysOnTop, nil, false) :: boolean

	-- Theme-driven visual properties
	local bgColor = resolve(nil, theme and theme.BackgroundColor3, Color3.fromRGB(255, 255, 255)) :: Color3
	local bgTransparency = resolve(nil, theme and theme.BackgroundTransparency, 0.78) :: number
	-- Override for billboard readability - more opaque than panels
	bgTransparency = math.max(0, bgTransparency - 0.15)
	local textColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local strokeColor = resolve(nil, theme and theme.StrokeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local shadowColor = resolve(nil, theme and theme.ShadowColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local innerGlowColor = resolve(nil, theme and theme.InnerGlowColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local innerGlowTransparency = resolve(nil, theme and theme.InnerGlowTransparency, 0.65) :: number
	local innerEdgeColor = resolve(nil, theme and theme.InnerEdgeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local innerEdgeTop = resolve(nil, theme and theme.InnerEdgeTopTransparency, 0.35) :: number
	local innerEdgeMid = resolve(nil, theme and theme.InnerEdgeMidTransparency, 0.72) :: number
	local innerEdgeBottom = resolve(nil, theme and theme.InnerEdgeBottomTransparency, 0.92) :: number
	local fresnelStart = resolve(nil, theme and theme.FresnelStartTransparency, 0.30) :: number
	local fresnelEnd = resolve(nil, theme and theme.FresnelEndTransparency, 0.95) :: number
	local fresnelMid = resolve(nil, theme and theme.FresnelMidTransparency, 0.55) :: number
	local fresnelMidPoint = resolve(nil, theme and theme.FresnelMidPoint, 0.35) :: number

	-- Auto-size based on text measurement
	local font = Enum.Font.GothamMedium
	local textBounds = TextService:GetTextSize(text, textSize, font, Vector2.new(500, 100))
	local containerWidth = textBounds.X + 28
	local containerHeight = textBounds.Y + 14

	-- BillboardGui
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = MangoProtection.randomName("Billboard")
	billboardGui.Size = UDim2.new(0, containerWidth, 0, containerHeight)
	billboardGui.MaxDistance = maxDistance
	billboardGui.StudsOffset = studsOffset
	billboardGui.AlwaysOnTop = alwaysOnTop
	billboardGui.Active = false
	billboardGui.ResetOnSpawn = false
	if targetPart then
		billboardGui.Adornee = targetPart
	end

	-- Container (transparent wrapper, full size)
	local container = Instance.new("Frame")
	container.Name = "Container"
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.Parent = billboardGui

	-- ShadowLayer1 (outer, larger spread)
	local shadowLayer1 = Instance.new("Frame")
	shadowLayer1.Name = "ShadowLayer1"
	shadowLayer1.AnchorPoint = Vector2.new(0.5, 0.5)
	shadowLayer1.Position = UDim2.new(0.5, 0, 0.5, 1)
	shadowLayer1.Size = UDim2.new(1, 8, 1, 8)
	shadowLayer1.BackgroundColor3 = shadowColor
	shadowLayer1.BackgroundTransparency = 0.88
	shadowLayer1.BorderSizePixel = 0
	shadowLayer1.ZIndex = 0
	shadowLayer1.Parent = container

	local shadowCorner1 = Instance.new("UICorner")
	shadowCorner1.CornerRadius = UDim.new(0, 999)
	shadowCorner1.Parent = shadowLayer1

	-- ShadowLayer2 (inner, tighter spread)
	local shadowLayer2 = Instance.new("Frame")
	shadowLayer2.Name = "ShadowLayer2"
	shadowLayer2.AnchorPoint = Vector2.new(0.5, 0.5)
	shadowLayer2.Position = UDim2.new(0.5, 0, 0.5, 1.5)
	shadowLayer2.Size = UDim2.new(1, 5, 1, 5)
	shadowLayer2.BackgroundColor3 = shadowColor
	shadowLayer2.BackgroundTransparency = 0.86
	shadowLayer2.BorderSizePixel = 0
	shadowLayer2.ZIndex = 0
	shadowLayer2.Parent = container

	local shadowCorner2 = Instance.new("UICorner")
	shadowCorner2.CornerRadius = UDim.new(0, 999)
	shadowCorner2.Parent = shadowLayer2

	-- GlassSurface (pill shape, clipping inner frame)
	local glassSurface = Instance.new("Frame")
	glassSurface.Name = "GlassSurface"
	glassSurface.Size = UDim2.new(1, 0, 1, 0)
	glassSurface.BackgroundColor3 = bgColor
	glassSurface.BackgroundTransparency = bgTransparency
	glassSurface.ClipsDescendants = true
	glassSurface.BorderSizePixel = 0
	glassSurface.ZIndex = 1
	glassSurface.Parent = container

	local glassCorner = Instance.new("UICorner")
	glassCorner.CornerRadius = UDim.new(0, 999)
	glassCorner.Parent = glassSurface

	-- InnerHighlight (subtle top glow inside GlassSurface)
	local innerHighlight = Instance.new("Frame")
	innerHighlight.Name = "InnerHighlight"
	innerHighlight.Size = UDim2.new(1, 0, 0.4, 0)
	innerHighlight.Position = UDim2.new(0, 0, 0, 0)
	innerHighlight.BackgroundColor3 = innerGlowColor
	innerHighlight.BackgroundTransparency = innerGlowTransparency
	innerHighlight.BorderSizePixel = 0
	innerHighlight.ZIndex = 2
	innerHighlight.Parent = glassSurface

	local highlightCorner = Instance.new("UICorner")
	highlightCorner.CornerRadius = UDim.new(0, 999)
	highlightCorner.Parent = innerHighlight

	local highlightGradient = Instance.new("UIGradient")
	highlightGradient.Name = "HighlightGradient"
	highlightGradient.Rotation = 90
	highlightGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(1, 1),
	})
	highlightGradient.Parent = innerHighlight

	-- InnerEdgeHighlight (full-perimeter inner stroke inside GlassSurface)
	local innerEdgeFrame = Instance.new("Frame")
	innerEdgeFrame.Name = "InnerEdgeHighlight"
	innerEdgeFrame.Size = UDim2.new(1, 0, 1, 0)
	innerEdgeFrame.BackgroundTransparency = 1
	innerEdgeFrame.BorderSizePixel = 0
	innerEdgeFrame.ZIndex = 3
	innerEdgeFrame.Parent = glassSurface

	local innerEdgeCorner = Instance.new("UICorner")
	innerEdgeCorner.CornerRadius = UDim.new(0, 999)
	innerEdgeCorner.Parent = innerEdgeFrame

	local innerEdgeStroke = Instance.new("UIStroke")
	innerEdgeStroke.Name = "InnerEdgeStroke"
	innerEdgeStroke.Color = innerEdgeColor
	innerEdgeStroke.Thickness = 1
	innerEdgeStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	innerEdgeStroke.Parent = innerEdgeFrame

	local innerEdgeGradient = Instance.new("UIGradient")
	innerEdgeGradient.Name = "InnerEdgeGradient"
	innerEdgeGradient.Rotation = 90
	innerEdgeGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, math.min(1, innerEdgeTop + 0.05)),
		NumberSequenceKeypoint.new(0.5, math.min(1, innerEdgeMid + 0.03)),
		NumberSequenceKeypoint.new(1, innerEdgeBottom),
	})
	innerEdgeGradient.Parent = innerEdgeStroke

	-- LabelText (centered text inside GlassSurface)
	local textLabel = Instance.new("TextLabel")
	textLabel.Name = "LabelText"
	textLabel.Text = text
	textLabel.Font = font
	textLabel.TextSize = textSize
	textLabel.TextColor3 = textColor
	textLabel.BackgroundTransparency = 1
	textLabel.Size = UDim2.new(1, 0, 1, 0)
	textLabel.TextXAlignment = Enum.TextXAlignment.Center
	textLabel.TextYAlignment = Enum.TextYAlignment.Center
	textLabel.BorderSizePixel = 0
	textLabel.ZIndex = 10
	textLabel.Parent = glassSurface

	-- SpecularFrame (outside clip boundary, child of Container)
	local specularFrame = Instance.new("Frame")
	specularFrame.Name = "SpecularFrame"
	specularFrame.Size = UDim2.new(1, 0, 1, 0)
	specularFrame.BackgroundTransparency = 1
	specularFrame.BorderSizePixel = 0
	specularFrame.ZIndex = 2
	specularFrame.Parent = container

	local specularCorner = Instance.new("UICorner")
	specularCorner.CornerRadius = UDim.new(0, 999)
	specularCorner.Parent = specularFrame

	local specularStroke = Instance.new("UIStroke")
	specularStroke.Name = "SpecularStroke"
	specularStroke.Color = strokeColor
	specularStroke.Thickness = 1
	specularStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	specularStroke.Parent = specularFrame

	local specularGradient = Instance.new("UIGradient")
	specularGradient.Name = "SpecularGradient"
	specularGradient.Rotation = 90
	specularGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, math.min(1, fresnelStart + 0.03)),
		NumberSequenceKeypoint.new(fresnelMidPoint, math.min(1, fresnelMid + 0.02)),
		NumberSequenceKeypoint.new(1, fresnelEnd),
	})
	specularGradient.Parent = specularStroke

	-- Parent assignment
	if config.Parent then
		billboardGui.Parent = config.Parent
	elseif targetPart then
		billboardGui.Parent = targetPart
	end

	-- Return typed table
	local self: Types.MangoBillboardLabel = {
		BillboardGui = billboardGui,
		GlassSurface = glassSurface,
		TextLabel = textLabel,
		SetText = function(self: Types.MangoBillboardLabel, newText: string)
			textLabel.Text = newText
			local newBounds = TextService:GetTextSize(newText, textSize, font, Vector2.new(500, 100))
			local newWidth = newBounds.X + 28
			local newHeight = newBounds.Y + 14
			billboardGui.Size = UDim2.new(0, newWidth, 0, newHeight)
		end,
		Destroy = function(self: Types.MangoBillboardLabel)
			billboardGui:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoNotificationStack"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoNotification = _require("MangoNotification")
local MangoProtection = _require("MangoProtection")
local resolve = Themes.resolve

local module = {}

function module.new(config: Types.MangoNotificationStackConfig): Types.MangoNotificationStack
	local theme = config.Theme

	local maxVisible = resolve(config.MaxVisible, theme and theme.NotificationMaxVisible, 3) :: number
	local stackGap = resolve(config.StackGap, theme and theme.NotificationStackGap, 8) :: number

	-- State
	local isDestroyed = false
	local activeNotifications: {Types.MangoNotification} = {}

	-- Determine parent container
	local screenGui: ScreenGui? = nil
	local parentInstance: Instance
	if config.Parent then
		parentInstance = config.Parent
	else
		local gui = MangoProtection.createScreenGui({
			DisplayOrder = 100,
		})
		screenGui = gui
		parentInstance = gui
	end

	-- Compute Y position for a notification at the given index (1-based)
	local function computeYForIndex(index: number): number
		local y = 16
		for i = 1, index - 1 do
			local notif = activeNotifications[i]
			if notif then
				y = y + notif:GetHeight() + stackGap
			end
		end
		return y
	end

	-- Reflow all active notifications to fill gaps
	local function reflowNotifications()
		for i, notif in activeNotifications do
			local y = computeYForIndex(i)
			notif:SetPosition(UDim2.new(0.5, 0, 0, y))
		end
	end

	-- Remove a notification from the active array and reflow
	local function removeFromArray(notification: Types.MangoNotification)
		local idx: number? = nil
		for i, notif in activeNotifications do
			if notif == notification then
				idx = i
				break
			end
		end
		if idx then
			table.remove(activeNotifications, idx)
			reflowNotifications()
		end
	end

	local self: Types.MangoNotificationStack = {
		Push = function(self: Types.MangoNotificationStack, notifConfig: Types.MangoNotificationConfig): Types.MangoNotification
			if isDestroyed then
				-- Return a dummy; won't happen in practice
				error("Cannot push to a destroyed MangoNotificationStack")
			end

			-- Auto-dismiss oldest if at max capacity
			if #activeNotifications >= maxVisible then
				local oldest = activeNotifications[1]
				if oldest then
					-- Remove from array immediately so new notifications don't
					-- stack behind a dismissing notification, and so rapid pushes
					-- don't try to re-dismiss an already-dismissing notification
					table.remove(activeNotifications, 1)
					oldest:Dismiss()
				end
			end

			-- Wrap the OnDismissed callback to also clean up the stack
			local originalOnDismissed = notifConfig.OnDismissed

			-- Create a modified config with overridden Parent and OnDismissed
			local stackNotifConfig: Types.MangoNotificationConfig = {
				Title = notifConfig.Title,
				Body = notifConfig.Body,
				Icon = notifConfig.Icon,
				Duration = notifConfig.Duration,
				Type = notifConfig.Type,
				Actions = notifConfig.Actions,
				Theme = notifConfig.Theme or theme,
				Parent = parentInstance,
				OnDismissed = nil, -- set below
			}

			-- We need a forward reference to the notification for the dismiss callback
			local notificationRef: Types.MangoNotification? = nil

			stackNotifConfig.OnDismissed = function()
				if notificationRef then
					removeFromArray(notificationRef :: Types.MangoNotification)
				end
				if originalOnDismissed then
					originalOnDismissed()
				end
			end

			local notification = MangoNotification.new(stackNotifConfig)
			notificationRef = notification

			-- Position the new notification
			table.insert(activeNotifications, notification)
			local y = computeYForIndex(#activeNotifications)
			notification.Container.Position = UDim2.new(0.5, 0, 0, -80) -- start offscreen
			notification:Show()
			notification:SetPosition(UDim2.new(0.5, 0, 0, y))

			return notification
		end,
		DismissAll = function(self: Types.MangoNotificationStack)
			-- Copy array since Dismiss triggers removal
			local copy = table.clone(activeNotifications)
			for _, notif in copy do
				notif:Dismiss()
			end
		end,
		GetCount = function(self: Types.MangoNotificationStack): number
			return #activeNotifications
		end,
		Destroy = function(self: Types.MangoNotificationStack)
			if isDestroyed then
				return
			end
			isDestroyed = true

			-- Dismiss all active notifications
			local copy = table.clone(activeNotifications)
			for _, notif in copy do
				notif:Destroy()
			end
			table.clear(activeNotifications)

			if screenGui then
				screenGui:Destroy()
			end
		end,
	}

	return self
end

return module

end

_modules["MangoBottomSheet"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoProtection = _require("MangoProtection")
local resolve = Themes.resolve
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local module = {}

function module.new(config: Types.MangoBottomSheetConfig): Types.MangoBottomSheet
	local theme = config.Theme
	local title = config.Title
	local contentSize = resolve(config.ContentSize, nil, UDim2.new(1, 0, 1, 0)) :: UDim2
	local snapPositions = resolve(config.SnapPositions, nil, {0.4, 0.8}) :: {number}
	local initialSnap = resolve(config.InitialSnap, nil, 1) :: number
	local dismissThreshold = resolve(config.DismissThreshold, nil, 0.15) :: number

	-- Theme values
	local sheetBgTransparency = resolve(nil, theme and theme.BottomSheetBackgroundTransparency, 0.15) :: number
	local handleColor = resolve(nil, theme and theme.BottomSheetHandleColor, Color3.fromRGB(200, 200, 205)) :: Color3
	local primaryTextColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local overlayTransparency = resolve(nil, theme and theme.DialogOverlayTransparency, 0.40) :: number

	-- State
	local isShowing = false
	local isDismissing = false
	local isDestroyed = false
	local isDragging = false
	local currentSnapIndex: number = math.clamp(initialSnap, 1, #snapPositions)
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}
	local dragOffset: number = 0

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Create ScreenGui
	local screenGui: ScreenGui? = nil
	local parentInstance: Instance
	if config.Parent then
		parentInstance = config.Parent
	else
		local gui = MangoProtection.createScreenGui({
			DisplayOrder = 140,
		})
		screenGui = gui
		parentInstance = gui
	end

	-- Overlay (full screen, black, starts transparent)
	local overlay = Instance.new("Frame")
	overlay.Name = MangoProtection.randomName("Overlay")
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	overlay.BackgroundTransparency = 1
	overlay.BorderSizePixel = 0
	overlay.ZIndex = 1
	overlay.Parent = parentInstance

	-- Overlay hit area for tap-to-dismiss
	local overlayHit = Instance.new("TextButton")
	overlayHit.Name = "OverlayHitArea"
	overlayHit.Size = UDim2.new(1, 0, 1, 0)
	overlayHit.BackgroundTransparency = 1
	overlayHit.Text = ""
	overlayHit.BorderSizePixel = 0
	overlayHit.ZIndex = 0
	overlayHit.AutoButtonColor = false
	overlayHit.Parent = overlay

	-- SheetContainer (anchored bottom, starts below screen)
	local sheetContainer = Instance.new("Frame")
	sheetContainer.Name = MangoProtection.randomName("Container")
	sheetContainer.AnchorPoint = Vector2.new(0.5, 1)
	sheetContainer.Size = UDim2.new(1, 0, 0.9, 0) -- max 90% of screen height
	sheetContainer.Position = UDim2.new(0.5, 0, 1, sheetContainer.AbsoluteSize.Y + 100)
	sheetContainer.BackgroundTransparency = 1
	sheetContainer.BorderSizePixel = 0
	sheetContainer.ClipsDescendants = false
	sheetContainer.ZIndex = 2
	sheetContainer.Parent = parentInstance

	-- Glass frame inside sheet (top corners only)
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 16),
		BackgroundTransparency = sheetBgTransparency,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 4,
		ShadowOffsetY = -4,
		ShadowSpread = 12,
		LightweightMode = true,
		Parent = sheetContainer,
	})

	-- Drag handle (40x5 pill, centered top)
	local dragHandle = Instance.new("Frame")
	dragHandle.Name = "DragHandle"
	dragHandle.Size = UDim2.new(0, 40, 0, 5)
	dragHandle.Position = UDim2.new(0.5, 0, 0, 8)
	dragHandle.AnchorPoint = Vector2.new(0.5, 0)
	dragHandle.BackgroundColor3 = handleColor
	dragHandle.BackgroundTransparency = 0.3
	dragHandle.BorderSizePixel = 0
	dragHandle.ZIndex = 20
	dragHandle.Parent = glassFrame.GlassSurface

	local handleCorner = Instance.new("UICorner")
	handleCorner.CornerRadius = UDim.new(0, 999)
	handleCorner.Parent = dragHandle

	-- DragHitArea (top 40px of sheet for drag input)
	local dragHitArea = Instance.new("TextButton")
	dragHitArea.Name = "DragHitArea"
	dragHitArea.Size = UDim2.new(1, 0, 0, 40)
	dragHitArea.Position = UDim2.new(0, 0, 0, 0)
	dragHitArea.BackgroundTransparency = 1
	dragHitArea.Text = ""
	dragHitArea.BorderSizePixel = 0
	dragHitArea.ZIndex = 15
	dragHitArea.AutoButtonColor = false
	dragHitArea.Parent = glassFrame.GlassSurface

	-- Title label (optional, below handle)
	local contentStartY = 20 -- below drag handle area
	if title and title ~= "" then
		local titleLabel = Instance.new("TextLabel")
		titleLabel.Name = "TitleLabel"
		titleLabel.Size = UDim2.new(1, -32, 0, 24)
		titleLabel.Position = UDim2.new(0, 16, 0, contentStartY)
		titleLabel.BackgroundTransparency = 1
		titleLabel.BorderSizePixel = 0
		titleLabel.Font = Enum.Font.GothamBold
		titleLabel.TextSize = 17
		titleLabel.TextColor3 = primaryTextColor
		titleLabel.TextXAlignment = Enum.TextXAlignment.Center
		titleLabel.TextYAlignment = Enum.TextYAlignment.Center
		titleLabel.Text = title
		titleLabel.ZIndex = 10
		titleLabel.Parent = glassFrame.GlassSurface
		contentStartY = contentStartY + 32
	end

	-- ContentFrame (user parents their content here)
	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "ContentFrame"
	contentFrame.Size = UDim2.new(contentSize.X.Scale, contentSize.X.Offset, contentSize.Y.Scale, contentSize.Y.Offset - contentStartY)
	contentFrame.Position = UDim2.new(0, 0, 0, contentStartY)
	contentFrame.BackgroundTransparency = 1
	contentFrame.BorderSizePixel = 0
	contentFrame.ClipsDescendants = true
	contentFrame.ZIndex = 10
	contentFrame.Parent = glassFrame.GlassSurface

	local contentPadding = Instance.new("UIPadding")
	contentPadding.PaddingTop = UDim.new(0, 8)
	contentPadding.PaddingBottom = UDim.new(0, 8)
	contentPadding.PaddingLeft = UDim.new(0, 8)
	contentPadding.PaddingRight = UDim.new(0, 8)
	contentPadding.Parent = contentFrame

	-- Helper: compute Y position for a snap fraction
	-- snapFraction is the fraction of viewport height visible from bottom
	-- Position is relative to bottom of screen (AnchorPoint=0.5,1)
	local function getSnapPosition(snapFraction: number): UDim2
		return UDim2.new(0.5, 0, 1 - snapFraction, 0)
	end

	-- Helper: compute overlay transparency based on sheet position
	local function getOverlayTransparencyForFraction(fraction: number): number
		-- Scale overlay from fully transparent (0 visible) to target (max snap visible)
		local maxSnap = 0
		for _, snap in snapPositions do
			if snap > maxSnap then
				maxSnap = snap
			end
		end
		local ratio = math.clamp(fraction / maxSnap, 0, 1)
		return 1 - (1 - overlayTransparency) * ratio
	end

	-- Helper: find nearest snap position
	local function findNearestSnap(currentFraction: number): number
		local nearestIdx = 1
		local nearestDist = math.huge
		for i, snap in snapPositions do
			local dist = math.abs(currentFraction - snap)
			if dist < nearestDist then
				nearestDist = dist
				nearestIdx = i
			end
		end
		return nearestIdx
	end

	-- Helper: get current fraction from sheet position
	local function getCurrentFraction(): number
		return 1 - sheetContainer.Position.Y.Scale
	end

	-- Forward reference for dismiss
	local dismissFunc: (() -> ())? = nil

	-- Drag logic
	local dragInputBeganConn = dragHitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if isDestroyed or isDismissing then return end
			isDragging = true
			cancelAllTweens()
			-- Calculate offset: distance from touch point to sheet top position
			local viewportHeight = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize.Y or 1000
			local sheetTopY = sheetContainer.Position.Y.Scale * viewportHeight + sheetContainer.Position.Y.Offset
			dragOffset = input.Position.Y - sheetTopY
		end
	end)
	table.insert(connections, dragInputBeganConn)

	local inputChangedConn = UserInputService.InputChanged:Connect(function(input: InputObject)
		if not isDragging then return end
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			local viewportHeight = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize.Y or 1000
			local newTopY = input.Position.Y - dragOffset
			local newScale = math.clamp(newTopY / viewportHeight, 0.05, 1.0)
			sheetContainer.Position = UDim2.new(0.5, 0, newScale, 0)

			-- Update overlay transparency based on visible fraction
			local visibleFraction = 1 - newScale
			overlay.BackgroundTransparency = getOverlayTransparencyForFraction(visibleFraction)
		end
	end)
	table.insert(connections, inputChangedConn)

	local inputEndedConn = UserInputService.InputEnded:Connect(function(input: InputObject)
		if not isDragging then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			isDragging = false

			local currentFraction = getCurrentFraction()

			-- Check dismiss threshold
			if currentFraction < dismissThreshold then
				if dismissFunc then
					dismissFunc()
				end
				return
			end

			-- Snap to nearest position
			local snapIdx = findNearestSnap(currentFraction)
			currentSnapIndex = snapIdx
			local targetFraction = snapPositions[snapIdx]

			cancelAllTweens()
			local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local snapTween = TweenService:Create(sheetContainer, tweenInfo, {
				Position = getSnapPosition(targetFraction),
			})
			trackTween(snapTween)
			snapTween:Play()

			local overlayTween = TweenService:Create(overlay, tweenInfo, {
				BackgroundTransparency = getOverlayTransparencyForFraction(targetFraction),
			})
			trackTween(overlayTween)
			overlayTween:Play()

			if config.OnSnapChanged then
				config.OnSnapChanged(snapIdx)
			end
		end
	end)
	table.insert(connections, inputEndedConn)

	-- Overlay tap to dismiss
	local overlayConn = overlayHit.Activated:Connect(function()
		if dismissFunc then
			dismissFunc()
		end
	end)
	table.insert(connections, overlayConn)

	-- Dismiss implementation
	local function doDismiss()
		if isDismissing or isDestroyed or not isShowing then
			return
		end
		isDismissing = true
		isDragging = false

		cancelAllTweens()
		local tweenOut = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

		-- Fade overlay out
		local overlayTween = TweenService:Create(overlay, tweenOut, {
			BackgroundTransparency = 1,
		})
		trackTween(overlayTween)
		overlayTween:Play()

		-- Slide sheet below screen
		local slideTween = TweenService:Create(sheetContainer, tweenOut, {
			Position = UDim2.new(0.5, 0, 1, 100),
		})
		trackTween(slideTween)
		slideTween:Play()

		slideTween.Completed:Once(function()
			if not isDestroyed then
				isShowing = false
				isDismissing = false
				if config.OnDismissed then
					config.OnDismissed()
				end
			end
		end)
	end

	dismissFunc = doDismiss

	-- Return table
	local self: Types.MangoBottomSheet = {
		Container = sheetContainer,
		ContentFrame = contentFrame,
		Show = function(self: Types.MangoBottomSheet)
			if isShowing or isDestroyed then
				return
			end
			isShowing = true
			isDismissing = false

			-- Start offscreen
			sheetContainer.Position = UDim2.new(0.5, 0, 1, 100)
			overlay.BackgroundTransparency = 1

			cancelAllTweens()

			-- Fade overlay in
			local targetFraction = snapPositions[currentSnapIndex]
			local overlayInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local overlayTween = TweenService:Create(overlay, overlayInfo, {
				BackgroundTransparency = getOverlayTransparencyForFraction(targetFraction),
			})
			trackTween(overlayTween)
			overlayTween:Play()

			-- Slide sheet up to snap position
			local slideInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local slideTween = TweenService:Create(sheetContainer, slideInfo, {
				Position = getSnapPosition(targetFraction),
			})
			trackTween(slideTween)
			slideTween:Play()
		end,
		Dismiss = function(self: Types.MangoBottomSheet)
			doDismiss()
		end,
		SnapTo = function(self: Types.MangoBottomSheet, snapIndex: number)
			if isDestroyed or isDismissing or not isShowing then return end
			local clampedIndex = math.clamp(snapIndex, 1, #snapPositions)
			currentSnapIndex = clampedIndex
			local targetFraction = snapPositions[clampedIndex]

			cancelAllTweens()
			local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			local snapTween = TweenService:Create(sheetContainer, tweenInfo, {
				Position = getSnapPosition(targetFraction),
			})
			trackTween(snapTween)
			snapTween:Play()

			local overlayTween = TweenService:Create(overlay, tweenInfo, {
				BackgroundTransparency = getOverlayTransparencyForFraction(targetFraction),
			})
			trackTween(overlayTween)
			overlayTween:Play()

			if config.OnSnapChanged then
				config.OnSnapChanged(clampedIndex)
			end
		end,
		Destroy = function(self: Types.MangoBottomSheet)
			if isDestroyed then
				return
			end
			isDestroyed = true

			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
			sheetContainer:Destroy()
			overlay:Destroy()
			if screenGui then
				screenGui:Destroy()
			end
		end,
	}

	return self
end

return module

end

_modules["MangoBlurProxy"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local RunService = game:GetService("RunService")

local module = {}

function module.new(config: Types.MangoBlurProxyConfig): Types.MangoBlurProxy
	local theme = config.Theme
	local downscale = resolve(config.DownscaleFactor, nil, 4) :: number
	local updateInterval = resolve(config.UpdateInterval, nil, 0.1) :: number
	local tintColor = resolve(nil, theme and theme.BlurTintColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local tintTransparency = resolve(nil, theme and theme.BlurTintTransparency, 0.70) :: number

	local enabled = resolve(config.Enabled, nil, true) :: boolean
	local isDestroyed = false
	local lastUpdate = 0
	local renderConn: RBXScriptConnection? = nil

	-- Container matches target size
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("BlurProxy")
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.ZIndex = 0

	-- ViewportFrame at low resolution
	local viewport = Instance.new("ViewportFrame")
	viewport.Name = "BlurViewport"
	viewport.Size = UDim2.new(1, 0, 1, 0)
	viewport.BackgroundTransparency = 1
	viewport.BorderSizePixel = 0
	viewport.ZIndex = 0
	viewport.Ambient = Color3.fromRGB(200, 200, 200)
	viewport.LightColor = Color3.fromRGB(255, 255, 255)
	viewport.Parent = container

	-- WorldModel inside viewport
	local worldModel = Instance.new("WorldModel")
	worldModel.Parent = viewport

	-- ViewportFrame camera
	local camera = Instance.new("Camera")
	camera.Parent = viewport
	viewport.CurrentCamera = camera

	-- Tint overlay
	local tintOverlay = Instance.new("Frame")
	tintOverlay.Name = "BlurTint"
	tintOverlay.Size = UDim2.new(1, 0, 1, 0)
	tintOverlay.BackgroundColor3 = tintColor
	tintOverlay.BackgroundTransparency = tintTransparency
	tintOverlay.BorderSizePixel = 0
	tintOverlay.ZIndex = 1
	tintOverlay.Parent = container

	local function updateCamera()
		local workspaceCamera = workspace.CurrentCamera
		if workspaceCamera then
			camera.CFrame = workspaceCamera.CFrame
			camera.FieldOfView = workspaceCamera.FieldOfView
		end
	end

	local function startUpdating()
		if renderConn then return end
		renderConn = RunService.RenderStepped:Connect(function()
			if isDestroyed or not enabled then return end
			local now = tick()
			if now - lastUpdate >= updateInterval then
				lastUpdate = now
				updateCamera()
			end
		end)
	end

	local function stopUpdating()
		if renderConn then
			renderConn:Disconnect()
			renderConn = nil
		end
	end

	-- Parent
	local parentTarget = config.Parent or config.TargetGui
	container.Parent = parentTarget

	if enabled then
		container.Visible = true
		startUpdating()
	else
		container.Visible = false
	end

	local self: Types.MangoBlurProxy = {
		Container = container,
		SetEnabled = function(self: Types.MangoBlurProxy, value: boolean)
			enabled = value
			container.Visible = value
			if value then
				startUpdating()
			else
				stopUpdating()
			end
		end,
		IsEnabled = function(self: Types.MangoBlurProxy): boolean
			return enabled
		end,
		Destroy = function(self: Types.MangoBlurProxy)
			isDestroyed = true
			stopUpdating()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoForm"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoTextField = _require("MangoTextField")
local MangoCheckbox = _require("MangoCheckbox")
local MangoDropdown = _require("MangoDropdown")
local MangoSlider = _require("MangoSlider")
local MangoButton = _require("MangoButton")
local MangoProtection = _require("MangoProtection")

local module = {}

type FieldEntry = {
	name: string,
	fieldType: string,
	component: any,
	errorLabel: TextLabel,
}

function module.new(config: Types.MangoFormConfig): Types.MangoForm
	local theme = config.Theme
	local submitText = resolve(config.SubmitText, nil, "Submit") :: string
	local primaryTextColor = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local errorColor = resolve(nil, theme and theme.FormErrorColor, Color3.fromRGB(255, 59, 48)) :: Color3

	local fields: {FieldEntry} = {}
	local components: {any} = {}
	local isDestroyed = false

	-- Container
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Form")
	container.Size = config.Size or UDim2.new(0, 300, 0, 0)
	container.AutomaticSize = Enum.AutomaticSize.Y
	container.Position = config.Position
	container.AnchorPoint = config.AnchorPoint or Vector2.new(0, 0)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	local layout = Instance.new("UIListLayout")
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.Padding = UDim.new(0, 12)
	layout.Parent = container

	local padding = Instance.new("UIPadding")
	padding.PaddingTop = UDim.new(0, 12)
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.Parent = container

	-- Build fields
	for i, fieldConfig in config.Fields do
		local fieldContainer = Instance.new("Frame")
		fieldContainer.Name = "Field_" .. fieldConfig.Name
		fieldContainer.Size = UDim2.new(1, 0, 0, 0)
		fieldContainer.AutomaticSize = Enum.AutomaticSize.Y
		fieldContainer.BackgroundTransparency = 1
		fieldContainer.BorderSizePixel = 0
		fieldContainer.LayoutOrder = i
		fieldContainer.Parent = container

		local fieldLayout = Instance.new("UIListLayout")
		fieldLayout.SortOrder = Enum.SortOrder.LayoutOrder
		fieldLayout.FillDirection = Enum.FillDirection.Vertical
		fieldLayout.Padding = UDim.new(0, 4)
		fieldLayout.Parent = fieldContainer

		-- Label
		if fieldConfig.Label then
			local label = Instance.new("TextLabel")
			label.Name = "FieldLabel"
			label.Size = UDim2.new(1, 0, 0, 18)
			label.BackgroundTransparency = 1
			label.BorderSizePixel = 0
			label.Font = Enum.Font.GothamMedium
			label.TextSize = 13
			label.TextColor3 = primaryTextColor
			label.TextXAlignment = Enum.TextXAlignment.Left
			label.LayoutOrder = 1
			if fieldConfig.Required then
				label.Text = fieldConfig.Label .. " <font color=\"rgb(255,59,48)\">*</font>"
				label.RichText = true
			else
				label.Text = fieldConfig.Label
			end
			label.Parent = fieldContainer
		end

		-- Component wrapper (for consistent sizing)
		local componentWrapper = Instance.new("Frame")
		componentWrapper.Name = "ComponentWrapper"
		componentWrapper.Size = UDim2.new(1, 0, 0, 36)
		componentWrapper.BackgroundTransparency = 1
		componentWrapper.BorderSizePixel = 0
		componentWrapper.LayoutOrder = 2
		componentWrapper.Parent = fieldContainer

		local component: any = nil
		local fieldType = fieldConfig.Type

		if fieldType == "text" then
			component = MangoTextField.new({
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 0, 36),
				Placeholder = fieldConfig.Placeholder,
				InitialText = fieldConfig.InitialValue :: string?,
				Theme = theme,
				Parent = componentWrapper,
			})
		elseif fieldType == "checkbox" then
			componentWrapper.Size = UDim2.new(1, 0, 0, 24)
			component = MangoCheckbox.new({
				Position = UDim2.new(0, 0, 0, 0),
				Label = nil,
				InitialState = fieldConfig.InitialValue :: boolean?,
				Theme = theme,
				Parent = componentWrapper,
			})
		elseif fieldType == "dropdown" then
			component = MangoDropdown.new({
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 0, 36),
				Items = fieldConfig.Items or {},
				InitialIndex = fieldConfig.InitialValue :: number?,
				Theme = theme,
				Parent = componentWrapper,
			})
		elseif fieldType == "slider" then
			component = MangoSlider.new({
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 0, 36),
				Min = fieldConfig.Min,
				Max = fieldConfig.Max,
				InitialValue = fieldConfig.InitialValue :: number?,
				Theme = theme,
				Parent = componentWrapper,
			})
		end

		-- Error label
		local errorLabel = Instance.new("TextLabel")
		errorLabel.Name = "ErrorLabel"
		errorLabel.Size = UDim2.new(1, 0, 0, 14)
		errorLabel.BackgroundTransparency = 1
		errorLabel.BorderSizePixel = 0
		errorLabel.Font = Enum.Font.Gotham
		errorLabel.TextSize = 11
		errorLabel.TextColor3 = errorColor
		errorLabel.TextXAlignment = Enum.TextXAlignment.Left
		errorLabel.Text = ""
		errorLabel.Visible = false
		errorLabel.LayoutOrder = 3
		errorLabel.Parent = fieldContainer

		if component then
			table.insert(components, component)
			table.insert(fields, {
				name = fieldConfig.Name,
				fieldType = fieldType,
				component = component,
				errorLabel = errorLabel,
			})
		end
	end

	-- GetValues
	local function getValues(): {[string]: any}
		local values: {[string]: any} = {}
		for _, field in fields do
			if field.fieldType == "text" then
				values[field.name] = field.component:GetText()
			elseif field.fieldType == "checkbox" then
				values[field.name] = field.component:GetState()
			elseif field.fieldType == "dropdown" then
				values[field.name] = field.component:GetSelectedIndex()
			elseif field.fieldType == "slider" then
				values[field.name] = field.component:GetValue()
			end
		end
		return values
	end

	-- Validate
	local function validate(): boolean
		local allValid = true
		for i, field in fields do
			local fieldConfig = config.Fields[i]
			local valid = true
			local errorMsg = ""

			-- Required check
			if fieldConfig.Required then
				if field.fieldType == "text" then
					local text = field.component:GetText()
					if text == "" then
						valid = false
						errorMsg = "This field is required"
					end
				elseif field.fieldType == "checkbox" then
					if not field.component:GetState() then
						valid = false
						errorMsg = "This field is required"
					end
				end
			end

			-- Custom validation
			if valid and fieldConfig.Validate then
				local value: any
				if field.fieldType == "text" then
					value = field.component:GetText()
				elseif field.fieldType == "checkbox" then
					value = field.component:GetState()
				elseif field.fieldType == "dropdown" then
					value = field.component:GetSelectedIndex()
				elseif field.fieldType == "slider" then
					value = field.component:GetValue()
				end

				local ok, msg = fieldConfig.Validate(value)
				if not ok then
					valid = false
					errorMsg = msg or "Invalid value"
				end
			end

			field.errorLabel.Visible = not valid
			field.errorLabel.Text = errorMsg
			if not valid then
				allValid = false
			end
		end
		return allValid
	end

	-- Submit button
	local submitWrapper = Instance.new("Frame")
	submitWrapper.Name = "SubmitWrapper"
	submitWrapper.Size = UDim2.new(1, 0, 0, 40)
	submitWrapper.BackgroundTransparency = 1
	submitWrapper.BorderSizePixel = 0
	submitWrapper.LayoutOrder = #config.Fields + 1
	submitWrapper.Parent = container

	local submitButton = MangoButton.new({
		Text = submitText,
		Theme = theme,
		Position = UDim2.new(0.5, 0, 0, 0),
		AnchorPoint = Vector2.new(0.5, 0),
		Parent = submitWrapper,
		OnActivated = function()
			if isDestroyed then return end
			if validate() then
				if config.OnSubmit then
					config.OnSubmit(getValues())
				end
			end
		end,
	})
	table.insert(components, submitButton)

	-- Parent
	if config.Parent then
		container.Parent = config.Parent
	end

	local self: Types.MangoForm = {
		Container = container,
		GetValues = function(self: Types.MangoForm): {[string]: any}
			return getValues()
		end,
		Validate = function(self: Types.MangoForm): boolean
			return validate()
		end,
		SetFieldValue = function(self: Types.MangoForm, name: string, value: any)
			for _, field in fields do
				if field.name == name then
					if field.fieldType == "text" then
						field.component:SetText(value :: string)
					elseif field.fieldType == "checkbox" then
						field.component:SetState(value :: boolean)
					elseif field.fieldType == "dropdown" then
						field.component:SetSelectedIndex(value :: number)
					elseif field.fieldType == "slider" then
						field.component:SetValue(value :: number)
					end
					return
				end
			end
		end,
		Destroy = function(self: Types.MangoForm)
			isDestroyed = true
			for _, comp in components do
				comp:Destroy()
			end
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoFocusManager"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local UserInputService = game:GetService("UserInputService")

local module = {}

function module.new(config: Types.MangoFocusManagerConfig): Types.MangoFocusManager
    local inputs: {GuiObject} = {}
    for _, input in config.Inputs do
        table.insert(inputs, input)
    end

    local enabled = resolve(config.Enabled, nil, true) :: boolean
    local currentIndex = 0
    local connections: {RBXScriptConnection} = {}
    local focusRing: UIStroke? = nil
    local isDestroyed = false

    local function findTextBox(gui: GuiObject): TextBox?
        if gui:IsA("TextBox") then
            return gui :: TextBox
        end
        local found = gui:FindFirstChildWhichIsA("TextBox", true)
        if found then
            return found :: TextBox
        end
        return nil
    end

    local function clearFocusRing()
        if focusRing then
            focusRing:Destroy()
            focusRing = nil
        end
    end

    local function applyFocusRing(target: GuiObject)
        clearFocusRing()
        local ring = Instance.new("UIStroke")
        ring.Name = "FocusRing"
        ring.Color = Color3.fromRGB(0, 122, 255)
        ring.Thickness = 2
        ring.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        ring.Parent = target
        focusRing = ring
    end

    local function focusAtIndex(index: number)
        if index < 1 or index > #inputs then return end
        currentIndex = index
        local target = inputs[index]
        local textBox = findTextBox(target)
        if textBox then
            textBox:CaptureFocus()
        end
        applyFocusRing(target)
    end

    -- Keyboard listener
    local inputConn = UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
        if not enabled or isDestroyed or gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.Tab then
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift) then
                -- Shift+Tab = previous
                local newIndex = currentIndex - 1
                if newIndex < 1 then newIndex = #inputs end
                focusAtIndex(newIndex)
            else
                -- Tab = next
                local newIndex = currentIndex + 1
                if newIndex > #inputs then newIndex = 1 end
                focusAtIndex(newIndex)
            end
        elseif input.KeyCode == Enum.KeyCode.Return then
            if config.SubmitCallback then
                config.SubmitCallback()
            end
        elseif input.KeyCode == Enum.KeyCode.Escape then
            clearFocusRing()
            currentIndex = 0
            if config.DismissCallback then
                config.DismissCallback()
            end
        end
    end)
    table.insert(connections, inputConn)

    local self: Types.MangoFocusManager = {
        Register = function(self: Types.MangoFocusManager, input: GuiObject)
            table.insert(inputs, input)
        end,
        Unregister = function(self: Types.MangoFocusManager, input: GuiObject)
            for i, v in inputs do
                if v == input then
                    table.remove(inputs, i)
                    if currentIndex >= i then
                        currentIndex = math.max(0, currentIndex - 1)
                    end
                    break
                end
            end
        end,
        FocusNext = function(self: Types.MangoFocusManager)
            local newIndex = currentIndex + 1
            if newIndex > #inputs then newIndex = 1 end
            focusAtIndex(newIndex)
        end,
        FocusPrevious = function(self: Types.MangoFocusManager)
            local newIndex = currentIndex - 1
            if newIndex < 1 then newIndex = #inputs end
            focusAtIndex(newIndex)
        end,
        FocusIndex = function(self: Types.MangoFocusManager, index: number)
            focusAtIndex(index)
        end,
        SetEnabled = function(self: Types.MangoFocusManager, value: boolean)
            enabled = value
            if not value then
                clearFocusRing()
                currentIndex = 0
            end
        end,
        Destroy = function(self: Types.MangoFocusManager)
            isDestroyed = true
            clearFocusRing()
            for _, conn in connections do
                conn:Disconnect()
            end
            table.clear(connections)
            table.clear(inputs)
        end,
    }

    return self
end

return module

end

_modules["MangoIntro"] = function()


local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

local Types = _require("Types")
local Themes = _require("Themes")
local resolve = Themes.resolve
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoProtection = _require("MangoProtection")

local module = {}

local isPlaying = false
local isDestroyed = false
local introGui: ScreenGui? = nil
local introSound: Sound? = nil

function module.skip()
	isDestroyed = true
	if introSound then
		introSound:Destroy()
		introSound = nil
	end
	if introGui then
		introGui:Destroy()
		introGui = nil
	end
	isPlaying = false
end

function module.play(config: Types.MangoIntroConfig?)
	if isPlaying then
		return
	end
	isPlaying = true
	isDestroyed = false

	local cfg = config or {} :: Types.MangoIntroConfig
	local theme = cfg.Theme or Themes.Mango
	local onComplete = cfg.OnComplete
	local titleText = resolve(cfg.Title, nil, "Mango") :: string
	local subtitleText = cfg.Subtitle
	local parentInstance = cfg.Parent

	local gui: ScreenGui
	if parentInstance then
		gui = Instance.new("ScreenGui")
		gui.Name = MangoProtection.randomName("Intro")
		gui.DisplayOrder = 200
		gui.ResetOnSpawn = false
		gui.IgnoreGuiInset = true
		gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		gui.Parent = parentInstance
	else
		gui = MangoProtection.createScreenGui({
			DisplayOrder = 200,
		})
	end
	introGui = gui

	-- Background overlay
	local overlay = Instance.new("Frame")
	overlay.Name = MangoProtection.randomName("Overlay")
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	overlay.BackgroundTransparency = 1
	overlay.BorderSizePixel = 0
	overlay.ZIndex = 0
	overlay.Parent = gui

	-- Center container
	local centerContainer = Instance.new("Frame")
	centerContainer.Name = MangoProtection.randomName("Container")
	centerContainer.Size = UDim2.new(0, 220, 0, 90)
	centerContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	centerContainer.AnchorPoint = Vector2.new(0.5, 0.5)
	centerContainer.BackgroundTransparency = 1
	centerContainer.BorderSizePixel = 0
	centerContainer.ZIndex = 1
	centerContainer.Parent = gui

	-- Glass frame
	local introGlass = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 20),
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 4,
		Parent = centerContainer,
	})

	-- 3D Text Layer 1: Back shadow (depth shadow, ZIndex=7)
	local backShadowText = Instance.new("TextLabel")
	backShadowText.Name = MangoProtection.randomName("BackShadow")
	backShadowText.Text = titleText
	backShadowText.Font = Enum.Font.GothamBold
	backShadowText.TextSize = 35
	backShadowText.TextColor3 = Color3.fromRGB(120, 70, 20)
	backShadowText.TextTransparency = 0.65
	backShadowText.TextStrokeTransparency = 1
	backShadowText.BackgroundTransparency = 1
	backShadowText.Size = UDim2.new(1, 0, 1, 0)
	backShadowText.Position = UDim2.new(0, 2, 0, 2)
	backShadowText.TextXAlignment = Enum.TextXAlignment.Center
	backShadowText.TextYAlignment = Enum.TextYAlignment.Center
	backShadowText.BorderSizePixel = 0
	backShadowText.ZIndex = 7
	backShadowText.Parent = introGlass.GlassSurface

	local backShadowScale = Instance.new("UIScale")
	backShadowScale.Scale = 0.01
	backShadowScale.Parent = backShadowText

	-- 3D Text Layer 2: Glass edge (refraction edge, ZIndex=8)
	local glassEdgeText = Instance.new("TextLabel")
	glassEdgeText.Name = MangoProtection.randomName("GlassEdge")
	glassEdgeText.Text = titleText
	glassEdgeText.Font = Enum.Font.GothamBold
	glassEdgeText.TextSize = 33
	glassEdgeText.TextColor3 = Color3.fromRGB(255, 230, 170)
	glassEdgeText.TextTransparency = 0.50
	glassEdgeText.TextStrokeTransparency = 1
	glassEdgeText.BackgroundTransparency = 1
	glassEdgeText.Size = UDim2.new(1, 0, 1, 0)
	glassEdgeText.Position = UDim2.new(0, 1, 0, 1)
	glassEdgeText.TextXAlignment = Enum.TextXAlignment.Center
	glassEdgeText.TextYAlignment = Enum.TextYAlignment.Center
	glassEdgeText.BorderSizePixel = 0
	glassEdgeText.ZIndex = 8
	glassEdgeText.Parent = introGlass.GlassSurface

	local glassEdgeGrad = Instance.new("UIGradient")
	glassEdgeGrad.Rotation = 90
	glassEdgeGrad.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 240, 200)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 160, 80)),
	})
	glassEdgeGrad.Parent = glassEdgeText

	local glassEdgeScale = Instance.new("UIScale")
	glassEdgeScale.Scale = 0.01
	glassEdgeScale.Parent = glassEdgeText

	-- Glow layer (soft amber halo, ZIndex=9)
	local glowText = Instance.new("TextLabel")
	glowText.Name = MangoProtection.randomName("GlowText")
	glowText.Text = titleText
	glowText.Font = Enum.Font.GothamBold
	glowText.TextSize = 34
	glowText.TextColor3 = Color3.fromRGB(255, 200, 80)
	glowText.TextTransparency = 0.55
	glowText.TextStrokeTransparency = 1
	glowText.TextStrokeColor3 = Color3.fromRGB(255, 160, 40)
	glowText.BackgroundTransparency = 1
	glowText.Size = UDim2.new(1, 0, 1, 0)
	glowText.TextXAlignment = Enum.TextXAlignment.Center
	glowText.TextYAlignment = Enum.TextYAlignment.Center
	glowText.BorderSizePixel = 0
	glowText.ZIndex = 9
	glowText.Parent = introGlass.GlassSurface

	local glowScale = Instance.new("UIScale")
	glowScale.Scale = 0.01
	glowScale.Parent = glowText

	-- Main text (warm amber, ZIndex=10)
	local logoText = Instance.new("TextLabel")
	logoText.Name = MangoProtection.randomName("LogoText")
	logoText.Text = titleText
	logoText.Font = Enum.Font.GothamBold
	logoText.TextSize = 32
	logoText.TextColor3 = Color3.fromRGB(255, 200, 100)
	logoText.TextStrokeColor3 = Color3.fromRGB(255, 150, 30)
	logoText.TextStrokeTransparency = 0.7
	logoText.BackgroundTransparency = 1
	logoText.Size = UDim2.new(1, 0, 1, 0)
	logoText.TextXAlignment = Enum.TextXAlignment.Center
	logoText.TextYAlignment = Enum.TextYAlignment.Center
	logoText.BorderSizePixel = 0
	logoText.ZIndex = 10
	logoText.Parent = introGlass.GlassSurface

	local logoTextScale = Instance.new("UIScale")
	logoTextScale.Scale = 0.01
	logoTextScale.Parent = logoText

	-- Subtitle (optional, below title)
	local subtitleLabel: TextLabel? = nil
	if subtitleText and subtitleText ~= "" then
		subtitleLabel = Instance.new("TextLabel")
		subtitleLabel.Name = "SubtitleLabel"
		subtitleLabel.Text = subtitleText
		subtitleLabel.Font = Enum.Font.GothamMedium
		subtitleLabel.TextSize = 14
		subtitleLabel.TextColor3 = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(120, 80, 40)) :: Color3
		subtitleLabel.TextTransparency = 1
		subtitleLabel.BackgroundTransparency = 1
		subtitleLabel.Size = UDim2.new(1, 0, 0, 20)
		subtitleLabel.Position = UDim2.new(0, 0, 0.65, 0)
		subtitleLabel.TextXAlignment = Enum.TextXAlignment.Center
		subtitleLabel.TextYAlignment = Enum.TextYAlignment.Center
		subtitleLabel.BorderSizePixel = 0
		subtitleLabel.ZIndex = 10
		subtitleLabel.Parent = introGlass.GlassSurface
	end

	-- UIScale for container scale animation
	local logoScale = Instance.new("UIScale")
	logoScale.Scale = 0.01
	logoScale.Parent = centerContainer

	-- SpotlightFrame1 (rotating beam)
	local spotlightFrame1 = Instance.new("Frame")
	spotlightFrame1.Name = "SpotlightFrame1"
	spotlightFrame1.Size = UDim2.new(1, 0, 1, 0)
	spotlightFrame1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	spotlightFrame1.BackgroundTransparency = 0.70
	spotlightFrame1.BorderSizePixel = 0
	spotlightFrame1.ZIndex = 5
	spotlightFrame1.Parent = centerContainer
	local sf1c = Instance.new("UICorner")
	sf1c.CornerRadius = UDim.new(0, 20)
	sf1c.Parent = spotlightFrame1

	local spotlightGradient = Instance.new("UIGradient")
	spotlightGradient.Name = "SpotlightGradient"
	spotlightGradient.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
	spotlightGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 1),
		NumberSequenceKeypoint.new(0.35, 1),
		NumberSequenceKeypoint.new(0.45, 0.3),
		NumberSequenceKeypoint.new(0.55, 0.3),
		NumberSequenceKeypoint.new(0.65, 1),
		NumberSequenceKeypoint.new(1, 1),
	})
	spotlightGradient.Rotation = 0
	spotlightGradient.Parent = spotlightFrame1

	-- SpotlightFrame2 (diffusion crossfade)
	local spotlightFrame2 = Instance.new("Frame")
	spotlightFrame2.Name = "SpotlightFrame2"
	spotlightFrame2.Size = UDim2.new(1, 0, 1, 0)
	spotlightFrame2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	spotlightFrame2.BackgroundTransparency = 1
	spotlightFrame2.BorderSizePixel = 0
	spotlightFrame2.ZIndex = 5
	spotlightFrame2.Parent = centerContainer
	local sf2c = Instance.new("UICorner")
	sf2c.CornerRadius = UDim.new(0, 20)
	sf2c.Parent = spotlightFrame2

	local softGlowGradient = Instance.new("UIGradient")
	softGlowGradient.Name = "SoftGlowGradient"
	softGlowGradient.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
	softGlowGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(1, 0.3),
	})
	softGlowGradient.Parent = spotlightFrame2

	-- Shimmer sweep frame
	local shimmerFrame = Instance.new("Frame")
	shimmerFrame.Name = "ShimmerFrame"
	shimmerFrame.Size = UDim2.new(1, 0, 1, 0)
	shimmerFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	shimmerFrame.BackgroundTransparency = 0.85
	shimmerFrame.BorderSizePixel = 0
	shimmerFrame.ZIndex = 6
	shimmerFrame.Parent = introGlass.GlassSurface
	local shimmerCorner = Instance.new("UICorner")
	shimmerCorner.CornerRadius = UDim.new(0, 20)
	shimmerCorner.Parent = shimmerFrame
	local shimmerGradient = Instance.new("UIGradient")
	shimmerGradient.Name = "ShimmerGradient"
	shimmerGradient.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
	shimmerGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 1),
		NumberSequenceKeypoint.new(0.45, 1),
		NumberSequenceKeypoint.new(0.48, 0.2),
		NumberSequenceKeypoint.new(0.52, 0.2),
		NumberSequenceKeypoint.new(0.55, 1),
		NumberSequenceKeypoint.new(1, 1),
	})
	shimmerGradient.Offset = Vector2.new(-0.5, 0)
	shimmerGradient.Parent = shimmerFrame

	-- Play sound
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://129319699633218"
	sound.Volume = 0.8
	sound.Parent = SoundService
	sound:Play()
	introSound = sound

	-- 0.0s: Overlay fades to 0.55
	TweenService:Create(overlay, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
		BackgroundTransparency = 0.55,
	}):Play()

	-- 0.0s: Container scale 0.01 -> 1.0
	TweenService:Create(logoScale, TweenInfo.new(0.55, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Scale = 1 }):Play()

	-- Staggered 3D text scale bounce
	TweenService:Create(backShadowScale, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Scale = 1 }):Play()
	TweenService:Create(glassEdgeScale, TweenInfo.new(0.55, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Scale = 1 }):Play()
	TweenService:Create(glowScale, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Scale = 1 }):Play()

	local mainOvershootTw = TweenService:Create(logoTextScale, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Scale = 1.02 })
	mainOvershootTw:Play()
	mainOvershootTw.Completed:Connect(function()
		if isDestroyed then return end
		TweenService:Create(logoTextScale, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Scale = 1.0 }):Play()
	end)

	-- Rotation wobble
	local rotateToInfo = TweenInfo.new(0.35, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
	local rotateTo = TweenService:Create(centerContainer, rotateToInfo, { Rotation = 2 })
	rotateTo:Play()
	rotateTo.Completed:Connect(function()
		if isDestroyed then return end
		TweenService:Create(centerContainer, rotateToInfo, { Rotation = 0 }):Play()
	end)

	-- 0.1s: Spotlight rotation
	task.delay(0.1, function()
		if isDestroyed then return end
		local spotRotInfo = TweenInfo.new(2.0, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
		TweenService:Create(spotlightGradient, spotRotInfo, { Rotation = 360 }):Play()

		local specGrad = introGlass.SpecularGradient
		if specGrad then
			TweenService:Create(specGrad, spotRotInfo, { Rotation = 360 }):Play()
		end
	end)

	-- 0.3s: Glow pulse
	task.delay(0.3, function()
		if isDestroyed then return end
		local glowPulseInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 1, true)
		TweenService:Create(glowText, glowPulseInfo, { TextTransparency = 0.30 }):Play()
	end)

	-- Subtitle fade-in
	if subtitleLabel then
		task.delay(0.3, function()
			if isDestroyed then return end
			TweenService:Create(subtitleLabel :: TextLabel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				TextTransparency = 0.3,
			}):Play()
		end)
	end

	-- 0.5s: Shimmer sweep
	task.delay(0.5, function()
		if isDestroyed then return end
		local shimmerSweepInfo = TweenInfo.new(1.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
		TweenService:Create(shimmerGradient, shimmerSweepInfo, { Offset = Vector2.new(0.5, 0) }):Play()
		task.delay(1.2, function()
			if isDestroyed then return end
			TweenService:Create(shimmerFrame, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { BackgroundTransparency = 1 }):Play()
		end)
	end)

	-- 1.2s: Cross-fade spotlight
	task.delay(1.2, function()
		if isDestroyed then return end
		local fadeOutInfo = TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		TweenService:Create(spotlightFrame1, fadeOutInfo, { BackgroundTransparency = 1 }):Play()
		TweenService:Create(spotlightFrame2, fadeOutInfo, { BackgroundTransparency = 0.85 }):Play()
	end)

	-- 2.0s: Fade out everything
	task.delay(2.0, function()
		if isDestroyed then return end
		local fadeOutInfo = TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		TweenService:Create(introGlass.GlassSurface, fadeOutInfo, { BackgroundTransparency = 1 }):Play()
		TweenService:Create(logoText, fadeOutInfo, { TextTransparency = 1 }):Play()
		TweenService:Create(glowText, fadeOutInfo, { TextTransparency = 1 }):Play()
		TweenService:Create(backShadowText, fadeOutInfo, { TextTransparency = 1 }):Play()
		TweenService:Create(glassEdgeText, fadeOutInfo, { TextTransparency = 1 }):Play()
		TweenService:Create(overlay, fadeOutInfo, { BackgroundTransparency = 1 }):Play()
		TweenService:Create(spotlightFrame2, fadeOutInfo, { BackgroundTransparency = 1 }):Play()
		if subtitleLabel then
			TweenService:Create(subtitleLabel :: TextLabel, fadeOutInfo, { TextTransparency = 1 }):Play()
		end
	end)

	-- 2.5s: Cleanup + callback
	task.delay(2.5, function()
		if isDestroyed then return end
		isDestroyed = true
		if introSound then
			introSound:Destroy()
			introSound = nil
		end
		if gui then
			gui:Destroy()
		end
		introGui = nil
		isPlaying = false
		if onComplete then
			onComplete()
		end
	end)
end

return module

end

_modules["MangoSaveManager"] = function()


local Types = _require("Types")

local HttpService = game:GetService("HttpService")

local module = {}

-- Check if executor file system functions are available
local function hasFileSystem(): boolean
	local success, _ = pcall(function()
		return type(writefile) == "function"
			and type(readfile) == "function"
			and type(isfolder) == "function"
			and type(makefolder) == "function"
			and type(isfile) == "function"
			and type(delfile) == "function"
	end)
	return success
end

local filesystemAvailable: boolean = hasFileSystem()

function module.new(config: Types.MangoSaveManagerConfig): Types.MangoSaveManager
	local folderName: string = config.FolderName
	local fileName: string = config.FileName or "config"
	local filePath: string = folderName .. "/" .. fileName .. ".json"

	local self = {} :: Types.MangoSaveManager

	function self.Save(_self: Types.MangoSaveManager, data: {[string]: any}): boolean
		if not filesystemAvailable then
			return false
		end

		local success = pcall(function()
			-- Create folder if it doesn't exist
			if not isfolder(folderName) then
				makefolder(folderName)
			end

			local encoded = HttpService:JSONEncode(data)
			writefile(filePath, encoded)
		end)

		return success
	end

	function self.Load(_self: Types.MangoSaveManager): {[string]: any}?
		if not filesystemAvailable then
			return nil
		end

		local success, result = pcall(function(): {[string]: any}?
			if not isfile(filePath) then
				return nil
			end

			local contents = readfile(filePath)
			local decoded = HttpService:JSONDecode(contents)
			return decoded :: {[string]: any}
		end)

		if success then
			return result
		end

		return nil
	end

	function self.Delete(_self: Types.MangoSaveManager): boolean
		if not filesystemAvailable then
			return false
		end

		local success = pcall(function()
			if isfile(filePath) then
				delfile(filePath)
			end
		end)

		return success
	end

	return self
end

return module

end

_modules["MangoColorPicker"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local module = {}

function module.new(config: Types.MangoColorPickerConfig): Types.MangoColorPicker
	local theme = config.Theme

	-- Resolve all config values with nil-safe helper
	local size = resolve(config.Size, nil, UDim2.new(0, 260, 0, 200)) :: UDim2
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local initialColor = resolve(config.InitialColor, nil, Color3.fromRGB(255, 0, 0)) :: Color3
	local cursorColor = resolve(nil, theme and theme.ColorPickerCursorColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local secondaryTextColor = resolve(nil, theme and theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3

	-- HSV state (0-1 each)
	local h: number, s: number, v: number = Color3.toHSV(initialColor)
	local isDraggingSB = false
	local isDraggingHue = false
	local connections: {RBXScriptConnection} = {}
	local activeTweens: {Tween} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	local function currentColor(): Color3
		return Color3.fromHSV(h, s, v)
	end

	local function toHex(color: Color3): string
		local r = math.floor(color.R * 255 + 0.5)
		local g = math.floor(color.G * 255 + 0.5)
		local b = math.floor(color.B * 255 + 0.5)
		return string.format("#%02X%02X%02X", r, g, b)
	end

	-- ============================================================
	-- Instance Hierarchy
	-- ============================================================

	-- Container (transparent wrapper)
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("ColorPicker")
	container.Size = size
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	-- Glass background via MangoGlassFrame
	local glass = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 12),
		LightweightMode = true,
		ShadowLayerCount = 2,
		Theme = theme,
		Parent = container,
	})

	-- UIPadding inside GlassSurface
	local padding = Instance.new("UIPadding")
	padding.PaddingTop = UDim.new(0, 10)
	padding.PaddingBottom = UDim.new(0, 10)
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)
	padding.Parent = glass.GlassSurface

	-- ============================================================
	-- Saturation-Brightness Box
	-- ============================================================

	local satBrightBox = Instance.new("Frame")
	satBrightBox.Name = "SatBrightBox"
	satBrightBox.Size = UDim2.new(1, 0, 0, 140)
	satBrightBox.Position = UDim2.new(0, 0, 0, 0)
	satBrightBox.BackgroundTransparency = 1
	satBrightBox.ClipsDescendants = true
	satBrightBox.BorderSizePixel = 0
	satBrightBox.ZIndex = 2
	satBrightBox.Parent = glass.GlassSurface

	local sbCorner = Instance.new("UICorner")
	sbCorner.CornerRadius = UDim.new(0, 6)
	sbCorner.Parent = satBrightBox

	-- HueBase: solid hue color background
	local hueBase = Instance.new("Frame")
	hueBase.Name = "HueBase"
	hueBase.Size = UDim2.new(1, 0, 1, 0)
	hueBase.BackgroundColor3 = Color3.fromHSV(h, 1, 1)
	hueBase.BackgroundTransparency = 0
	hueBase.BorderSizePixel = 0
	hueBase.ZIndex = 2
	hueBase.Parent = satBrightBox

	-- SatOverlay: white gradient left-to-right (white -> transparent)
	local satOverlay = Instance.new("Frame")
	satOverlay.Name = "SatOverlay"
	satOverlay.Size = UDim2.new(1, 0, 1, 0)
	satOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	satOverlay.BackgroundTransparency = 0
	satOverlay.BorderSizePixel = 0
	satOverlay.ZIndex = 3
	satOverlay.Parent = satBrightBox

	local satGradient = Instance.new("UIGradient")
	satGradient.Name = "SatGradient"
	satGradient.Rotation = 0
	satGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(1, 1),
	})
	satGradient.Parent = satOverlay

	-- BrightOverlay: black gradient top-to-bottom (transparent -> black)
	local brightOverlay = Instance.new("Frame")
	brightOverlay.Name = "BrightOverlay"
	brightOverlay.Size = UDim2.new(1, 0, 1, 0)
	brightOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	brightOverlay.BackgroundTransparency = 0
	brightOverlay.BorderSizePixel = 0
	brightOverlay.ZIndex = 4
	brightOverlay.Parent = satBrightBox

	local brightGradient = Instance.new("UIGradient")
	brightGradient.Name = "BrightGradient"
	brightGradient.Rotation = 90
	brightGradient.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 1),
		NumberSequenceKeypoint.new(1, 0),
	})
	brightGradient.Parent = brightOverlay

	-- SB Cursor (12x12 circle with white stroke)
	local sbCursor = Instance.new("Frame")
	sbCursor.Name = "Cursor"
	sbCursor.Size = UDim2.new(0, 12, 0, 12)
	sbCursor.AnchorPoint = Vector2.new(0.5, 0.5)
	sbCursor.Position = UDim2.new(s, 0, 1 - v, 0)
	sbCursor.BackgroundColor3 = currentColor()
	sbCursor.BackgroundTransparency = 0
	sbCursor.BorderSizePixel = 0
	sbCursor.ZIndex = 15
	sbCursor.Parent = satBrightBox

	local sbCursorCorner = Instance.new("UICorner")
	sbCursorCorner.CornerRadius = UDim.new(0, 999)
	sbCursorCorner.Parent = sbCursor

	local sbCursorStroke = Instance.new("UIStroke")
	sbCursorStroke.Color = cursorColor
	sbCursorStroke.Thickness = 2
	sbCursorStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	sbCursorStroke.Parent = sbCursor

	-- SB HitArea
	local sbHitArea = Instance.new("TextButton")
	sbHitArea.Name = "SBHitArea"
	sbHitArea.Size = UDim2.new(1, 0, 1, 0)
	sbHitArea.BackgroundTransparency = 1
	sbHitArea.Text = ""
	sbHitArea.BorderSizePixel = 0
	sbHitArea.ZIndex = 100
	sbHitArea.AutoButtonColor = false
	sbHitArea.Parent = satBrightBox

	-- ============================================================
	-- Hue Bar
	-- ============================================================

	local hueBar = Instance.new("Frame")
	hueBar.Name = "HueBar"
	hueBar.Size = UDim2.new(1, 0, 0, 16)
	hueBar.Position = UDim2.new(0, 0, 0, 146)
	hueBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	hueBar.BackgroundTransparency = 0
	hueBar.BorderSizePixel = 0
	hueBar.ZIndex = 2
	hueBar.Parent = glass.GlassSurface

	local hueBarCorner = Instance.new("UICorner")
	hueBarCorner.CornerRadius = UDim.new(0, 8)
	hueBarCorner.Parent = hueBar

	-- Rainbow gradient (7-point HSV spectrum)
	local rainbowGradient = Instance.new("UIGradient")
	rainbowGradient.Name = "RainbowGradient"
	rainbowGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0.000, Color3.fromHSV(0 / 6, 1, 1)),
		ColorSequenceKeypoint.new(0.167, Color3.fromHSV(1 / 6, 1, 1)),
		ColorSequenceKeypoint.new(0.333, Color3.fromHSV(2 / 6, 1, 1)),
		ColorSequenceKeypoint.new(0.500, Color3.fromHSV(3 / 6, 1, 1)),
		ColorSequenceKeypoint.new(0.667, Color3.fromHSV(4 / 6, 1, 1)),
		ColorSequenceKeypoint.new(0.833, Color3.fromHSV(5 / 6, 1, 1)),
		ColorSequenceKeypoint.new(1.000, Color3.fromHSV(6 / 6, 1, 1)),
	})
	rainbowGradient.Parent = hueBar

	-- Hue slider handle (12x16 rounded white pill)
	local hueSlider = Instance.new("Frame")
	hueSlider.Name = "HueSlider"
	hueSlider.Size = UDim2.new(0, 12, 0, 16)
	hueSlider.AnchorPoint = Vector2.new(0.5, 0.5)
	hueSlider.Position = UDim2.new(h, 0, 0.5, 0)
	hueSlider.BackgroundColor3 = cursorColor
	hueSlider.BackgroundTransparency = 0
	hueSlider.BorderSizePixel = 0
	hueSlider.ZIndex = 15
	hueSlider.Parent = hueBar

	local hueSliderCorner = Instance.new("UICorner")
	hueSliderCorner.CornerRadius = UDim.new(0, 6)
	hueSliderCorner.Parent = hueSlider

	local hueSliderStroke = Instance.new("UIStroke")
	hueSliderStroke.Color = Color3.fromRGB(200, 200, 205)
	hueSliderStroke.Thickness = 0.5
	hueSliderStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	hueSliderStroke.Transparency = 0.4
	hueSliderStroke.Parent = hueSlider

	-- Hue HitArea
	local hueHitArea = Instance.new("TextButton")
	hueHitArea.Name = "HueHitArea"
	hueHitArea.Size = UDim2.new(1, 0, 1, 0)
	hueHitArea.BackgroundTransparency = 1
	hueHitArea.Text = ""
	hueHitArea.BorderSizePixel = 0
	hueHitArea.ZIndex = 100
	hueHitArea.AutoButtonColor = false
	hueHitArea.Parent = hueBar

	-- ============================================================
	-- Preview Row
	-- ============================================================

	local previewRow = Instance.new("Frame")
	previewRow.Name = "PreviewRow"
	previewRow.Size = UDim2.new(1, 0, 0, 24)
	previewRow.Position = UDim2.new(0, 0, 0, 168)
	previewRow.BackgroundTransparency = 1
	previewRow.BorderSizePixel = 0
	previewRow.ZIndex = 2
	previewRow.Parent = glass.GlassSurface

	local previewLayout = Instance.new("UIListLayout")
	previewLayout.FillDirection = Enum.FillDirection.Horizontal
	previewLayout.SortOrder = Enum.SortOrder.LayoutOrder
	previewLayout.Padding = UDim.new(0, 8)
	previewLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	previewLayout.Parent = previewRow

	-- Color swatch circle
	local colorPreview = Instance.new("Frame")
	colorPreview.Name = "ColorPreview"
	colorPreview.Size = UDim2.new(0, 24, 0, 24)
	colorPreview.BackgroundColor3 = currentColor()
	colorPreview.BackgroundTransparency = 0
	colorPreview.BorderSizePixel = 0
	colorPreview.ZIndex = 2
	colorPreview.LayoutOrder = 1
	colorPreview.Parent = previewRow

	local previewCorner = Instance.new("UICorner")
	previewCorner.CornerRadius = UDim.new(0, 999)
	previewCorner.Parent = colorPreview

	local previewStroke = Instance.new("UIStroke")
	previewStroke.Color = Color3.fromRGB(200, 200, 205)
	previewStroke.Thickness = 0.5
	previewStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	previewStroke.Transparency = 0.4
	previewStroke.Parent = colorPreview

	-- Hex label
	local hexLabel = Instance.new("TextLabel")
	hexLabel.Name = "HexLabel"
	hexLabel.Size = UDim2.new(0, 80, 0, 24)
	hexLabel.BackgroundTransparency = 1
	hexLabel.BorderSizePixel = 0
	hexLabel.Font = Enum.Font.GothamMedium
	hexLabel.TextSize = 12
	hexLabel.TextColor3 = secondaryTextColor
	hexLabel.TextXAlignment = Enum.TextXAlignment.Left
	hexLabel.Text = toHex(currentColor())
	hexLabel.ZIndex = 2
	hexLabel.LayoutOrder = 2
	hexLabel.Parent = previewRow

	-- ============================================================
	-- Update Visuals
	-- ============================================================

	local function updateVisuals()
		local color = currentColor()
		-- SB box hue base
		hueBase.BackgroundColor3 = Color3.fromHSV(h, 1, 1)
		-- SB cursor position and fill
		sbCursor.Position = UDim2.new(s, 0, 1 - v, 0)
		sbCursor.BackgroundColor3 = color
		-- Hue slider position
		hueSlider.Position = UDim2.new(h, 0, 0.5, 0)
		-- Preview swatch
		colorPreview.BackgroundColor3 = color
		-- Hex text
		hexLabel.Text = toHex(color)
	end

	-- ============================================================
	-- Drag Logic
	-- ============================================================

	-- SB box drag start
	local sbInputBeganConn = sbHitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			isDraggingSB = true
			local boxPos = satBrightBox.AbsolutePosition
			local boxSize = satBrightBox.AbsoluteSize
			s = math.clamp((input.Position.X - boxPos.X) / boxSize.X, 0, 1)
			v = 1 - math.clamp((input.Position.Y - boxPos.Y) / boxSize.Y, 0, 1)
			updateVisuals()
			if config.OnChanged then
				config.OnChanged(currentColor())
			end
		end
	end)
	table.insert(connections, sbInputBeganConn)

	-- Hue bar drag start
	local hueInputBeganConn = hueHitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			isDraggingHue = true
			local barPos = hueBar.AbsolutePosition
			local barWidth = hueBar.AbsoluteSize.X
			h = math.clamp((input.Position.X - barPos.X) / barWidth, 0, 1)
			updateVisuals()
			if config.OnChanged then
				config.OnChanged(currentColor())
			end
		end
	end)
	table.insert(connections, hueInputBeganConn)

	-- Global drag tracking via UserInputService.InputChanged
	local inputChangedConn = UserInputService.InputChanged:Connect(function(input: InputObject)
		if not isDraggingSB and not isDraggingHue then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch then
			if isDraggingSB then
				local boxPos = satBrightBox.AbsolutePosition
				local boxSize = satBrightBox.AbsoluteSize
				s = math.clamp((input.Position.X - boxPos.X) / boxSize.X, 0, 1)
				v = 1 - math.clamp((input.Position.Y - boxPos.Y) / boxSize.Y, 0, 1)
			elseif isDraggingHue then
				local barPos = hueBar.AbsolutePosition
				local barWidth = hueBar.AbsoluteSize.X
				h = math.clamp((input.Position.X - barPos.X) / barWidth, 0, 1)
			end
			updateVisuals()
			if config.OnChanged then
				config.OnChanged(currentColor())
			end
		end
	end)
	table.insert(connections, inputChangedConn)

	-- End drag on UserInputService.InputEnded
	local inputEndedConn = UserInputService.InputEnded:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			isDraggingSB = false
			isDraggingHue = false
		end
	end)
	table.insert(connections, inputEndedConn)

	-- ============================================================
	-- Parent Assignment
	-- ============================================================

	if config.Parent then
		container.Parent = config.Parent
	end

	-- ============================================================
	-- Return Table
	-- ============================================================

	local self: Types.MangoColorPicker = {
		Container = container,
		GetColor = function(self: Types.MangoColorPicker): Color3
			return currentColor()
		end,
		SetColor = function(self: Types.MangoColorPicker, color: Color3)
			h, s, v = Color3.toHSV(color)
			updateVisuals()
		end,
		Destroy = function(self: Types.MangoColorPicker)
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			cancelAllTweens()
			glass:Destroy()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoKeybind"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoHaptics = _require("MangoHaptics")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local module = {}

local function abbreviateKey(keyName: string): string
	local abbrevMap: {[string]: string} = {
		LeftShift = "LShift", RightShift = "RShift",
		LeftControl = "LCtrl", RightControl = "RCtrl",
		LeftAlt = "LAlt", RightAlt = "RAlt",
		Backspace = "BkSp", Return = "Enter",
		Space = "Space", Tab = "Tab", Escape = "Esc",
	}
	return abbrevMap[keyName] or keyName
end

function module.new(config: Types.MangoKeybindConfig): Types.MangoKeybind
	local theme = config.Theme

	-- Resolve config values
	local position = resolve(config.Position, nil, UDim2.new(0, 0, 0, 0)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 0)) :: Vector2
	local labelText = config.Label
	local defaultKey = resolve(config.DefaultKey, nil, "None") :: string

	-- Theme values
	local primaryText = resolve(nil, theme and theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local pillTransparency = resolve(nil, theme and theme.KeybindPillTransparency, 0.70) :: number
	local listeningColor = resolve(nil, theme and theme.KeybindListeningColor, Color3.fromRGB(0, 122, 255)) :: Color3

	-- State
	local currentKey: string = defaultKey
	local isListening: boolean = false
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Container (horizontal layout, auto-sized)
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Keybind")
	container.Size = UDim2.new(0, 0, 0, 28)
	container.AutomaticSize = Enum.AutomaticSize.X
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	local layout = Instance.new("UIListLayout")
	layout.FillDirection = Enum.FillDirection.Horizontal
	layout.VerticalAlignment = Enum.VerticalAlignment.Center
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 8)
	layout.Parent = container

	-- LabelText (optional)
	if labelText and labelText ~= "" then
		local label = Instance.new("TextLabel")
		label.Name = "LabelText"
		label.Size = UDim2.new(0, 0, 1, 0)
		label.AutomaticSize = Enum.AutomaticSize.X
		label.BackgroundTransparency = 1
		label.BorderSizePixel = 0
		label.Font = Enum.Font.GothamMedium
		label.TextSize = 14
		label.Text = labelText
		label.TextColor3 = primaryText
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.LayoutOrder = 1
		label.Parent = container
	end

	-- KeyButton (MangoGlassFrame, LightweightMode, pill)
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(0, 80, 0, 28),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 999),
		BackgroundTransparency = pillTransparency,
		Theme = theme,
		ShadowEnabled = resolve(config.ShadowEnabled, nil, true) :: boolean,
		ShadowLayerCount = 2,
		ShadowSpread = 4,
		ShadowOffsetY = 1,
		LightweightMode = true,
	})
	glassFrame.Container.LayoutOrder = 2
	glassFrame.Container.Parent = container

	-- UIScale on Container for hover animation
	local uiScale = Instance.new("UIScale")
	uiScale.Scale = 1
	uiScale.Parent = glassFrame.Container

	-- KeyLabel inside GlassSurface
	local keyLabel = Instance.new("TextLabel")
	keyLabel.Name = "KeyLabel"
	keyLabel.Size = UDim2.new(1, 0, 1, 0)
	keyLabel.BackgroundTransparency = 1
	keyLabel.BorderSizePixel = 0
	keyLabel.Font = Enum.Font.GothamMedium
	keyLabel.TextSize = 13
	keyLabel.Text = abbreviateKey(currentKey)
	keyLabel.TextColor3 = primaryText
	keyLabel.TextXAlignment = Enum.TextXAlignment.Center
	keyLabel.TextYAlignment = Enum.TextYAlignment.Center
	keyLabel.ZIndex = 10
	keyLabel.Parent = glassFrame.GlassSurface

	-- HitArea
	local hitArea = Instance.new("TextButton")
	hitArea.Name = "HitArea"
	hitArea.Size = UDim2.new(1, 0, 1, 0)
	hitArea.BackgroundTransparency = 1
	hitArea.Text = ""
	hitArea.BorderSizePixel = 0
	hitArea.ZIndex = 100
	hitArea.AutoButtonColor = false
	hitArea.Parent = glassFrame.GlassSurface

	-- Store original glass transparency for restore
	local originalBgTransparency = glassFrame.GlassSurface.BackgroundTransparency

	-- Forward declare for mutual reference
	local exitListening: () -> ()

	local function enterListening()
		if isListening then
			return
		end
		isListening = true
		cancelAllTweens()
		MangoHaptics.light()

		-- Visual: show "..." and thicken glass
		keyLabel.Text = "..."
		keyLabel.TextColor3 = listeningColor

		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local opacityTween = TweenService:Create(glassFrame.GlassSurface, tweenInfo, {
			BackgroundTransparency = math.clamp(originalBgTransparency - 0.08, 0, 1),
		})
		trackTween(opacityTween)
		opacityTween:Play()

		-- Listen for keyboard input
		local keyConn: RBXScriptConnection
		keyConn = UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
			if not isListening then
				return
			end
			if input.UserInputType == Enum.UserInputType.Keyboard then
				if input.KeyCode == Enum.KeyCode.Escape then
					-- Cancel: restore previous key
					exitListening()
				else
					-- Capture the new key
					currentKey = input.KeyCode.Name
					exitListening()
					if config.OnKeyChanged then
						config.OnKeyChanged(currentKey)
					end
				end
			end
		end)
		table.insert(connections, keyConn)

		-- Listen for mouse/touch click outside to cancel
		local outsideConn: RBXScriptConnection
		outsideConn = UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
			if not isListening then
				return
			end
			if input.UserInputType == Enum.UserInputType.MouseButton1
				or input.UserInputType == Enum.UserInputType.Touch then
				-- Check if click is outside the key button
				local mousePos = input.Position
				local absPos = glassFrame.Container.AbsolutePosition
				local absSize = glassFrame.Container.AbsoluteSize
				if mousePos.X < absPos.X or mousePos.X > absPos.X + absSize.X
					or mousePos.Y < absPos.Y or mousePos.Y > absPos.Y + absSize.Y then
					exitListening()
				end
			end
		end)
		table.insert(connections, outsideConn)
	end

	exitListening = function()
		if not isListening then
			return
		end
		isListening = false
		cancelAllTweens()

		-- Restore visual
		keyLabel.Text = abbreviateKey(currentKey)
		keyLabel.TextColor3 = primaryText

		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local opacityTween = TweenService:Create(glassFrame.GlassSurface, tweenInfo, {
			BackgroundTransparency = originalBgTransparency,
		})
		trackTween(opacityTween)
		opacityTween:Play()

		-- Disconnect the listening connections (last 2 added)
		-- Remove from end to avoid index shift
		if #connections >= 1 then
			connections[#connections]:Disconnect()
			table.remove(connections, #connections)
		end
		if #connections >= 1 then
			connections[#connections]:Disconnect()
			table.remove(connections, #connections)
		end
	end

	-- Click handler: enter listening mode
	local clickConn = hitArea.MouseButton1Click:Connect(function()
		if isListening then
			return
		end
		enterListening()
	end)
	table.insert(connections, clickConn)

	-- Hover animation: UIScale 1.02 on hover (0.2s Quad Out), 1.0 on leave
	local isHovering = false

	local hoverEnterConn = hitArea.MouseEnter:Connect(function()
		if isListening then
			return
		end
		isHovering = true
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local scaleTween = TweenService:Create(uiScale, tweenInfo, { Scale = 1.02 })
		trackTween(scaleTween)
		scaleTween:Play()
	end)
	table.insert(connections, hoverEnterConn)

	local hoverLeaveConn = hitArea.MouseLeave:Connect(function()
		isHovering = false
		if isListening then
			return
		end
		cancelAllTweens()
		local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local scaleTween = TweenService:Create(uiScale, tweenInfo, { Scale = 1.0 })
		trackTween(scaleTween)
		scaleTween:Play()
	end)
	table.insert(connections, hoverLeaveConn)

	-- Parent assignment
	if config.Parent then
		container.Parent = config.Parent
	end

	-- Return table
	local self: Types.MangoKeybind = {
		Container = container,
		GetKey = function(self: Types.MangoKeybind): string
			return currentKey
		end,
		SetKey = function(self: Types.MangoKeybind, keyName: string)
			if isListening then
				exitListening()
			end
			currentKey = keyName
			keyLabel.Text = abbreviateKey(currentKey)
		end,
		Destroy = function(self: Types.MangoKeybind)
			isListening = false
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			glassFrame:Destroy()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoCarousel"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local resolve = Themes.resolve
local MangoProtection = _require("MangoProtection")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local module = {}

-- Default accent colors for tabs (cycles if more tabs than colors)
local DEFAULT_COLORS: {Color3} = {
	Color3.fromRGB(90, 135, 230),  -- soft blue
	Color3.fromRGB(175, 100, 220), -- soft purple
	Color3.fromRGB(230, 140, 70),  -- warm orange
	Color3.fromRGB(80, 185, 140),  -- soft green
}

local function lightenColor(c: Color3, amount: number): Color3
	return Color3.new(math.min(c.R + amount, 1), math.min(c.G + amount, 1), math.min(c.B + amount, 1))
end

local function darkenColor(c: Color3, amount: number): Color3
	return Color3.new(math.max(c.R - amount, 0), math.max(c.G - amount, 0), math.max(c.B - amount, 0))
end

function module.new(config: Types.MangoCarouselConfig): Types.MangoCarousel
	local theme = config.Theme
	local tabs = config.Tabs
	local tabCount = #tabs

	-- Resolve config values
	local ICON_SIZE = resolve(config.IconSize, nil, 44) :: number
	local ICON_GAP = 10
	local ICON_STEP = ICON_SIZE + ICON_GAP
	local DOCK_WIDTH = ICON_SIZE + 20
	local VIEWPORT_HEIGHT = 3 * ICON_STEP + ICON_SIZE

	local initialIndex = resolve(config.InitialIndex, nil, 1) :: number
	local position = resolve(config.Position, nil, UDim2.new(0, 8, 1, -62)) :: UDim2
	local anchorPoint = resolve(config.AnchorPoint, nil, Vector2.new(0, 1)) :: Vector2
	local dockSize = resolve(config.Size, nil, UDim2.new(0, DOCK_WIDTH, 0, VIEWPORT_HEIGHT)) :: UDim2

	-- Theme values
	local strokeColor = resolve(nil, theme and theme.StrokeColor, Color3.fromRGB(255, 255, 255)) :: Color3
	local fresnelStart = resolve(nil, theme and theme.FresnelStartTransparency, 0.35) :: number
	local fresnelMid = resolve(nil, theme and theme.FresnelMidTransparency, 0.65) :: number
	local fresnelMidPoint = resolve(nil, theme and theme.FresnelMidPoint, 0.40) :: number
	local fresnelEnd = resolve(nil, theme and theme.FresnelEndTransparency, 0.95) :: number

	-- State
	local currentIndex: number = math.clamp(initialIndex, 1, tabCount)
	local scrollGen: number = 0
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}
	local isDestroyed = false
	local isTweening = false

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Get accent color for a tab index
	local function getTabColor(index: number): Color3
		local tabConfig = tabs[index]
		if tabConfig.Color then
			return tabConfig.Color
		end
		return DEFAULT_COLORS[((index - 1) % #DEFAULT_COLORS) + 1]
	end

	-- Compute the Y offset for the track to center a given tab index
	local function getIconCenterOffset(tabIdx: number): number
		local centerY = VIEWPORT_HEIGHT / 2
		local iconCenterY = (tabIdx - 1) * ICON_STEP + ICON_SIZE / 2
		return centerY - iconCenterY
	end

	-- ============================================================
	-- Instance Hierarchy
	-- ============================================================

	-- Container (transparent outer wrapper)
	local container = Instance.new("Frame")
	container.Name = MangoProtection.randomName("Carousel")
	container.Size = dockSize
	container.Position = position
	container.AnchorPoint = anchorPoint
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0

	-- DockGlass (MangoGlassFrame backdrop, pill shape)
	local dockGlass = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, math.floor(DOCK_WIDTH / 2)),
		BackgroundTransparency = 0.75,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 3,
		ShadowSpread = 6,
		ShadowOffsetY = 2,
		LightweightMode = true,
		Parent = container,
	})

	-- DockHitArea (full-size transparent button for scroll/touch capture across entire dock)
	local dockHitArea = Instance.new("TextButton")
	dockHitArea.Name = "DockHitArea"
	dockHitArea.Size = UDim2.new(1, 0, 1, 0)
	dockHitArea.BackgroundTransparency = 1
	dockHitArea.Text = ""
	dockHitArea.BorderSizePixel = 0
	dockHitArea.ZIndex = 1
	dockHitArea.AutoButtonColor = false
	dockHitArea.Parent = dockGlass.GlassSurface

	-- ClipFrame (clips the scrolling track, inside GlassSurface)
	local edgePad = 14
	local clipFrame = Instance.new("Frame")
	clipFrame.Name = "ClipFrame"
	clipFrame.Size = UDim2.new(1, 0, 1, -edgePad * 2)
	clipFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	clipFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	clipFrame.BackgroundTransparency = 1
	clipFrame.BorderSizePixel = 0
	clipFrame.ClipsDescendants = true
	clipFrame.Parent = dockGlass.GlassSurface

	-- TrackFrame (holds all icons, moves vertically via tween)
	local trackFrame = Instance.new("Frame")
	trackFrame.Name = "TrackFrame"
	trackFrame.Size = UDim2.new(1, 0, 0, tabCount * ICON_STEP)
	trackFrame.Position = UDim2.new(0, 0, 0, getIconCenterOffset(currentIndex))
	trackFrame.BackgroundTransparency = 1
	trackFrame.BorderSizePixel = 0
	trackFrame.Parent = clipFrame

	-- Icon data arrays
	local iconFrames: {Frame} = {}
	local iconScales: {UIScale} = {}
	local iconDotScales: {UIScale} = {}
	local iconHoverStates: {boolean} = {}

	-- Build icon instances (no event wiring yet — forward-declared functions needed)
	for i = 1, tabCount do
		local tabConfig = tabs[i]
		local accent = getTabColor(i)
		local isSelected = i == currentIndex

		-- Icon_N frame
		local iconFrame = Instance.new("Frame")
		iconFrame.Name = "Icon_" .. i
		iconFrame.Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
		iconFrame.AnchorPoint = Vector2.new(0.5, 0)
		iconFrame.Position = UDim2.new(0.5, 0, 0, (i - 1) * ICON_STEP)
		iconFrame.BackgroundTransparency = 1
		iconFrame.BorderSizePixel = 0
		iconFrame.Parent = trackFrame

		-- UIScale for paraboloid focus + hover
		local iconScale = Instance.new("UIScale")
		iconScale.Scale = 1
		iconScale.Parent = iconFrame

		-- IconShadow (accent-tinted drop shadow)
		local iconShadow = Instance.new("Frame")
		iconShadow.Name = "IconShadow"
		iconShadow.Size = UDim2.new(0, ICON_SIZE + 6, 0, ICON_SIZE + 6)
		iconShadow.AnchorPoint = Vector2.new(0.5, 0.5)
		iconShadow.Position = UDim2.new(0.5, 0, 0.5, 2)
		iconShadow.BackgroundColor3 = accent
		iconShadow.BackgroundTransparency = 0.84
		iconShadow.BorderSizePixel = 0
		iconShadow.ZIndex = 0
		iconShadow.Parent = iconFrame

		local shadowCorner = Instance.new("UICorner")
		shadowCorner.CornerRadius = UDim.new(0, 14)
		shadowCorner.Parent = iconShadow

		-- IconBg (squircle, gradient fill)
		local iconBg = Instance.new("Frame")
		iconBg.Name = "IconBg"
		iconBg.Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
		iconBg.AnchorPoint = Vector2.new(0.5, 0.5)
		iconBg.Position = UDim2.new(0.5, 0, 0.5, 0)
		iconBg.BackgroundColor3 = accent
		iconBg.BackgroundTransparency = 0.40
		iconBg.BorderSizePixel = 0
		iconBg.ZIndex = 1
		iconBg.Parent = iconFrame

		local bgCorner = Instance.new("UICorner")
		bgCorner.CornerRadius = UDim.new(0, 12)
		bgCorner.Parent = iconBg

		-- Gradient fill (lighten top, darken bottom)
		local bgGradient = Instance.new("UIGradient")
		bgGradient.Name = "IconBgGradient"
		bgGradient.Rotation = 135
		bgGradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, lightenColor(accent, 0.15)),
			ColorSequenceKeypoint.new(1, darkenColor(accent, 0.08)),
		})
		bgGradient.Parent = iconBg

		-- IconHighlight (white inner glow, 35% height)
		local iconHighlight = Instance.new("Frame")
		iconHighlight.Name = "IconHighlight"
		iconHighlight.Size = UDim2.new(1, 0, 0.35, 0)
		iconHighlight.Position = UDim2.new(0, 0, 0, 0)
		iconHighlight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		iconHighlight.BackgroundTransparency = 0.78
		iconHighlight.BorderSizePixel = 0
		iconHighlight.ZIndex = 2
		iconHighlight.Parent = iconBg

		local highlightCorner = Instance.new("UICorner")
		highlightCorner.CornerRadius = UDim.new(0, 12)
		highlightCorner.Parent = iconHighlight

		local highlightGradient = Instance.new("UIGradient")
		highlightGradient.Name = "HighlightGradient"
		highlightGradient.Rotation = 90
		highlightGradient.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0),
			NumberSequenceKeypoint.new(1, 1),
		})
		highlightGradient.Parent = iconHighlight

		-- Inner edge stroke (glass-like inner shadow via Border mode inside iconBg)
		local innerEdgeFrame = Instance.new("Frame")
		innerEdgeFrame.Name = "InnerEdgeFrame"
		innerEdgeFrame.Size = UDim2.new(1, 0, 1, 0)
		innerEdgeFrame.BackgroundTransparency = 1
		innerEdgeFrame.BorderSizePixel = 0
		innerEdgeFrame.ZIndex = 2
		innerEdgeFrame.Parent = iconBg

		local innerEdgeCorner = Instance.new("UICorner")
		innerEdgeCorner.CornerRadius = UDim.new(0, 12)
		innerEdgeCorner.Parent = innerEdgeFrame

		local innerEdgeStroke = Instance.new("UIStroke")
		innerEdgeStroke.Name = "InnerEdgeStroke"
		innerEdgeStroke.Color = Color3.fromRGB(255, 255, 255)
		innerEdgeStroke.Thickness = 1
		innerEdgeStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		innerEdgeStroke.Parent = innerEdgeFrame

		local innerEdgeGradient = Instance.new("UIGradient")
		innerEdgeGradient.Name = "InnerEdgeGradient"
		innerEdgeGradient.Rotation = 90
		innerEdgeGradient.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.55),
			NumberSequenceKeypoint.new(0.5, 0.82),
			NumberSequenceKeypoint.new(1, 0.95),
		})
		innerEdgeGradient.Parent = innerEdgeStroke

		-- Specular stroke on icon (fresnel rim)
		local specFrame = Instance.new("Frame")
		specFrame.Name = "SpecularFrame"
		specFrame.Size = UDim2.new(1, 0, 1, 0)
		specFrame.BackgroundTransparency = 1
		specFrame.BorderSizePixel = 0
		specFrame.ZIndex = 3
		specFrame.Parent = iconBg

		local specCorner = Instance.new("UICorner")
		specCorner.CornerRadius = UDim.new(0, 12)
		specCorner.Parent = specFrame

		local specStroke = Instance.new("UIStroke")
		specStroke.Name = "SpecularStroke"
		specStroke.Color = strokeColor
		specStroke.Thickness = 1
		specStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		specStroke.Parent = specFrame

		local specGradient = Instance.new("UIGradient")
		specGradient.Name = "SpecularGradient"
		specGradient.Rotation = 90
		specGradient.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, fresnelStart + 0.10),
			NumberSequenceKeypoint.new(fresnelMidPoint, fresnelMid + 0.05),
			NumberSequenceKeypoint.new(1, fresnelEnd),
		})
		specGradient.Parent = specStroke

		-- IconLabel (emoji or text)
		local iconLabel = Instance.new("TextLabel")
		iconLabel.Name = "IconLabel"
		iconLabel.Size = UDim2.new(1, 0, 1, 0)
		iconLabel.BackgroundTransparency = 1
		iconLabel.BorderSizePixel = 0
		iconLabel.Font = Enum.Font.GothamBold
		iconLabel.TextSize = 16
		-- Truncate label to first 2 chars when used as icon fallback (prevents text overflow in small icon)
		local iconText = tabConfig.Icon
		if not iconText or iconText == "" then
			local lbl = tabConfig.Label or ""
			iconText = string.sub(lbl, 1, 2)
		end
		iconLabel.Text = iconText
		iconLabel.TextScaled = true
		iconLabel.TextTruncate = Enum.TextTruncate.AtEnd
		iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		iconLabel.TextStrokeTransparency = 0.80
		iconLabel.TextXAlignment = Enum.TextXAlignment.Center
		iconLabel.TextYAlignment = Enum.TextYAlignment.Center
		iconLabel.ZIndex = 5
		iconLabel.Parent = iconFrame

		-- ActiveDot (6x6 circle below icon, accent-colored)
		local activeDot = Instance.new("Frame")
		activeDot.Name = "ActiveDot"
		activeDot.Size = UDim2.new(0, 6, 0, 6)
		activeDot.AnchorPoint = Vector2.new(0.5, 0)
		activeDot.Position = UDim2.new(0.5, 0, 1, 3)
		activeDot.BackgroundColor3 = accent
		activeDot.BackgroundTransparency = 0
		activeDot.BorderSizePixel = 0
		activeDot.ZIndex = 5
		activeDot.Parent = iconFrame

		local dotCorner = Instance.new("UICorner")
		dotCorner.CornerRadius = UDim.new(0, 999)
		dotCorner.Parent = activeDot

		local dotScale = Instance.new("UIScale")
		dotScale.Scale = if isSelected then 1 else 0
		dotScale.Parent = activeDot

		-- HitArea (TextButton for reliable input)
		local hitArea = Instance.new("TextButton")
		hitArea.Name = "HitArea"
		hitArea.Size = UDim2.new(1, 0, 1, 0)
		hitArea.BackgroundTransparency = 1
		hitArea.Text = ""
		hitArea.BorderSizePixel = 0
		hitArea.ZIndex = 100
		hitArea.AutoButtonColor = false
		hitArea.Parent = iconFrame

		-- Store references
		table.insert(iconFrames, iconFrame)
		table.insert(iconScales, iconScale)
		table.insert(iconDotScales, dotScale)
		table.insert(iconHoverStates, false)
	end

	-- ============================================================
	-- Active Dot Animation
	-- ============================================================

	local function updateDots(selectedIndex: number)
		local dotInInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local dotOutInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		for i = 1, tabCount do
			local targetScale = if i == selectedIndex then 1 else 0
			local info = if i == selectedIndex then dotInInfo else dotOutInfo
			trackTween(TweenService:Create(iconDotScales[i], info, {
				Scale = targetScale,
			})):Play()
		end
	end

	-- ============================================================
	-- Paraboloid Focus
	-- ============================================================

	local function applyParaboloidFocus()
		if isDestroyed then return end
		local trackY = trackFrame.Position.Y.Offset
		local centerViewY = VIEWPORT_HEIGHT / 2

		local focusInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		for i = 1, tabCount do
			if not iconHoverStates[i] then
				local iconCenterY = trackY + (i - 1) * ICON_STEP + ICON_SIZE / 2
				local distance = math.abs(iconCenterY - centerViewY)
				local t = distance / ICON_STEP
				local focusScale = math.max(0.50, 1.0 - t * t)
				trackTween(TweenService:Create(iconScales[i], focusInfo, {
					Scale = focusScale,
				})):Play()
			end
		end
	end

	-- ============================================================
	-- Scroll Logic (Infinite Loop Wrapping)
	-- ============================================================

	local function scrollToIndex(newIndex: number)
		if isDestroyed then return end
		cancelAllTweens()
		scrollGen += 1
		local gen = scrollGen

		-- Wrap index with modular arithmetic
		newIndex = ((newIndex - 1) % tabCount) + 1
		local oldIndex = currentIndex
		currentIndex = newIndex

		-- Compute shortest wrap distance for variable duration
		local rawDelta = math.abs(newIndex - oldIndex)
		local scrollDelta = math.min(rawDelta, tabCount - rawDelta)
		local duration = 0.22 + scrollDelta * 0.03

		local targetY = getIconCenterOffset(newIndex)

		local scrollInfo = TweenInfo.new(duration, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local scrollTween = TweenService:Create(trackFrame, scrollInfo, {
			Position = UDim2.new(0, 0, 0, targetY),
		})
		trackTween(scrollTween)
		isTweening = true
		scrollTween:Play()

		scrollTween.Completed:Once(function()
			if isDestroyed then return end
			if gen == scrollGen then
				isTweening = false
			end
		end)

		updateDots(newIndex)

		if config.OnChanged then
			config.OnChanged(newIndex)
		end
	end

	-- ============================================================
	-- Wire Event Handlers (after all functions are defined)
	-- ============================================================

	for i = 1, tabCount do
		local iconFrame = iconFrames[i]
		local iconScale = iconScales[i]
		local hitArea = iconFrame:FindFirstChild("HitArea") :: TextButton

		-- Click handler
		local clickConn = hitArea.MouseButton1Click:Connect(function()
			if isDestroyed then return end
			if currentIndex ~= i then
				scrollToIndex(i)
			end
		end)
		table.insert(connections, clickConn)

		-- Hover feedback (1.04x, 0.2s Back Out)
		local hoverConn = hitArea.MouseEnter:Connect(function()
			if isDestroyed then return end
			iconHoverStates[i] = true
			local hoverInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			trackTween(TweenService:Create(iconScale, hoverInfo, { Scale = 1.04 })):Play()
		end)
		table.insert(connections, hoverConn)

		local leaveConn = hitArea.MouseLeave:Connect(function()
			if isDestroyed then return end
			iconHoverStates[i] = false
			applyParaboloidFocus()
		end)
		table.insert(connections, leaveConn)

		-- Press feedback (0.92x, 0.1s Quad Out)
		local pressConn = hitArea.MouseButton1Down:Connect(function()
			if isDestroyed then return end
			local pressInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			trackTween(TweenService:Create(iconScale, pressInfo, { Scale = 0.92 })):Play()
		end)
		table.insert(connections, pressConn)

		local releaseConn = hitArea.MouseButton1Up:Connect(function()
			if isDestroyed then return end
			if iconHoverStates[i] then
				local hoverInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
				trackTween(TweenService:Create(iconScale, hoverInfo, { Scale = 1.04 })):Play()
			else
				applyParaboloidFocus()
			end
		end)
		table.insert(connections, releaseConn)
	end

	-- ============================================================
	-- Mouse Wheel Input (on dock hit area for full bounding box coverage)
	-- ============================================================

	local scrollConn = dockHitArea.InputChanged:Connect(function(input: InputObject)
		if isDestroyed then return end
		if input.UserInputType ~= Enum.UserInputType.MouseWheel then return end

		-- Scroll direction: negative Z = scroll down = next tab
		local direction = if input.Position.Z < 0 then 1 else -1
		scrollToIndex(currentIndex + direction)
	end)
	table.insert(connections, scrollConn)

	-- ============================================================
	-- Touch Swipe Support (on dock hit area for full bounding box coverage)
	-- ============================================================

	local touchStartY: number? = nil

	local touchBeganConn = dockHitArea.InputBegan:Connect(function(input: InputObject)
		if isDestroyed then return end
		if input.UserInputType ~= Enum.UserInputType.Touch then return end
		touchStartY = input.Position.Y
	end)
	table.insert(connections, touchBeganConn)

	local touchEndedConn = dockHitArea.InputEnded:Connect(function(input: InputObject)
		if isDestroyed then return end
		if input.UserInputType ~= Enum.UserInputType.Touch then return end
		if touchStartY == nil then return end

		local deltaY = input.Position.Y - (touchStartY :: number)
		touchStartY = nil

		-- Y delta > 20px threshold for swipe detection
		if math.abs(deltaY) > 20 then
			local direction = if deltaY < 0 then 1 else -1
			scrollToIndex(currentIndex + direction)
		end
	end)
	table.insert(connections, touchEndedConn)

	-- ============================================================
	-- Per-Frame Focus Update (RenderStepped)
	-- ============================================================

	local renderConn = RunService.RenderStepped:Connect(function()
		if isDestroyed then return end
		if isTweening then
			applyParaboloidFocus()
		end
	end)
	table.insert(connections, renderConn)

	-- Apply initial state
	applyParaboloidFocus()
	updateDots(currentIndex)

	-- ============================================================
	-- Parent Assignment
	-- ============================================================

	if config.Parent then
		container.Parent = config.Parent
	end

	-- ============================================================
	-- Return Table
	-- ============================================================

	local self: Types.MangoCarousel = {
		Container = container,
		SetIndex = function(self: Types.MangoCarousel, index: number)
			scrollToIndex(index)
		end,
		GetIndex = function(self: Types.MangoCarousel): number
			return currentIndex
		end,
		Destroy = function(self: Types.MangoCarousel)
			isDestroyed = true
			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)
			dockGlass:Destroy()
			container:Destroy()
		end,
	}

	return self
end

return module

end

_modules["MangoWindow"] = function()


local Types = _require("Types")
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local MangoToggle = _require("MangoToggle")
local MangoSlider = _require("MangoSlider")
local MangoButton = _require("MangoButton")
local MangoCheckbox = _require("MangoCheckbox")
local MangoProgressBar = _require("MangoProgressBar")
local MangoDropdown = _require("MangoDropdown")
local MangoTextField = _require("MangoTextField")
local MangoStepper = _require("MangoStepper")
local MangoSegmentedControl = _require("MangoSegmentedControl")
local MangoNotificationStack = _require("MangoNotificationStack")
local MangoDialog = _require("MangoDialog")
local MangoColorPicker = _require("MangoColorPicker")
local MangoKeybind = _require("MangoKeybind")
local MangoSaveManager = _require("MangoSaveManager")
local MangoIntro = _require("MangoIntro")
local MangoCarousel = _require("MangoCarousel")
local MangoProtection = _require("MangoProtection")
local resolve = Themes.resolve

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local module = {}

-- Helper: create a MangoWindowElement wrapper
local function createWindowElement(config: {
	getValue: () -> any,
	setValue: (any) -> (),
	rowFrame: Frame,
	destroyInner: () -> (),
}): Types.MangoWindowElement
	local isLocked = false
	local lockOverlay: Frame? = nil
	local currentValue = config.getValue()

	local self: Types.MangoWindowElement = {
		CurrentValue = currentValue,
		Set = function(self: Types.MangoWindowElement, value: any)
			config.setValue(value)
			self.CurrentValue = config.getValue()
		end,
		Visible = function(self: Types.MangoWindowElement, visible: boolean)
			config.rowFrame.Visible = visible
		end,
		Lock = function(self: Types.MangoWindowElement, reason: string?)
			if isLocked then return end
			isLocked = true
			local overlay = Instance.new("Frame")
			overlay.Name = "LockOverlay"
			overlay.Size = UDim2.new(1, 0, 1, 0)
			overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
			overlay.BackgroundTransparency = 0.85
			overlay.BorderSizePixel = 0
			overlay.ZIndex = 200
			overlay.Parent = config.rowFrame
			lockOverlay = overlay

			if reason then
				local label = Instance.new("TextLabel")
				label.Size = UDim2.new(1, 0, 1, 0)
				label.BackgroundTransparency = 1
				label.Font = Enum.Font.GothamMedium
				label.TextSize = 12
				label.Text = reason
				label.TextColor3 = Color3.fromRGB(200, 200, 200)
				label.ZIndex = 201
				label.Parent = overlay
			end
		end,
		Unlock = function(self: Types.MangoWindowElement)
			if not isLocked then return end
			isLocked = false
			if lockOverlay then
				lockOverlay:Destroy()
				lockOverlay = nil
			end
		end,
		Destroy = function(self: Types.MangoWindowElement)
			config.destroyInner()
			config.rowFrame:Destroy()
		end,
	}
	return self
end

function module.new(config: Types.MangoWindowConfig): Types.MangoWindow
	local theme = config.Theme or Themes.Light
	local windowName = config.Name or "MangoUI"
	local windowSize = resolve(config.Size, nil, UDim2.new(0, 500, 0, 600)) :: UDim2
	local windowPos = resolve(config.Position, nil, UDim2.new(0.5, 0, 0.5, 0)) :: UDim2
	local toggleKeyName = config.ToggleKey
	local showButtonText = config.ShowButton or windowName
	local configSaving = config.ConfigurationSaving
	local loadingEnabled = resolve(config.LoadingEnabled, nil, true) :: boolean

	-- Theme values
	local primaryText = resolve(nil, theme.PrimaryTextColor, Color3.fromRGB(0, 0, 0)) :: Color3
	local secondaryText = resolve(nil, theme.SecondaryTextColor, Color3.fromRGB(60, 60, 70)) :: Color3
	local bgColor = resolve(nil, theme.BackgroundColor3, Color3.fromRGB(255, 255, 255)) :: Color3
	local accentColor = resolve(nil, theme.AccentColor, Color3.fromRGB(0, 122, 255)) :: Color3
	local windowBgTransp = resolve(nil, theme.WindowBackgroundTransparency, 0.12) :: number

	-- State
	local isVisible = true
	local isDestroyed = false
	local isDragging = false
	local dragOffset = Vector2.zero
	local activeTweens: {Tween} = {}
	local connections: {RBXScriptConnection} = {}
	local tabData: {{name: string, icon: string?, frame: ScrollingFrame, elements: {Types.MangoWindowElement}}} = {}
	local currentTabIndex = 1
	local flags: {[string]: any} = {}
	local flagElements: {[string]: Types.MangoWindowElement} = {}
	local flagDependents: {[string]: {Types.MangoWindowElement}} = {}
	local saveDebounceThread: thread? = nil
	local saveManager: Types.MangoSaveManager? = nil
	local innerDestroyables: {any} = {}
	local pendingDelays: {thread} = {}
	local carouselDock: Types.MangoCarousel? = nil
	local DOCK_GAP = 12

	local function cancelAllTweens()
		for _, tween in activeTweens do
			tween:Cancel()
		end
		table.clear(activeTweens)
	end

	local function trackTween(tween: Tween): Tween
		table.insert(activeTweens, tween)
		return tween
	end

	-- Play intro if enabled
	if loadingEnabled then
		MangoIntro.play({
			Theme = theme,
			Title = config.LoadingTitle,
			Subtitle = config.LoadingSubtitle,
		})
	end

	-- Setup save manager
	if configSaving and configSaving.Enabled then
		local folderName = configSaving.FolderName or windowName
		local fileName = configSaving.FileName or "config"
		saveManager = MangoSaveManager.new({
			FolderName = folderName,
			FileName = fileName,
		})
	end

	-- Create ScreenGui
	local screenGui = MangoProtection.createScreenGui({
		DisplayOrder = 100,
	})

	-- Window container (animation target)
	local windowContainer = Instance.new("Frame")
	windowContainer.Name = MangoProtection.randomName("Container")
	windowContainer.Size = windowSize
	windowContainer.Position = windowPos
	windowContainer.AnchorPoint = Vector2.new(0.5, 0.5)
	windowContainer.BackgroundTransparency = 1
	windowContainer.BorderSizePixel = 0
	windowContainer.Parent = screenGui

	local windowUIScale = Instance.new("UIScale")
	windowUIScale.Scale = 1
	windowUIScale.Parent = windowContainer

	-- Glass frame
	local glassFrame = MangoGlassFrame.new({
		Size = UDim2.new(1, 0, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		CornerRadius = UDim.new(0, 16),
		BackgroundTransparency = windowBgTransp,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 4,
		ShadowSpread = 16,
		ShadowOffsetY = 4,
		Parent = windowContainer,
	})
	table.insert(innerDestroyables, glassFrame)

	-- Window content frame
	local windowContent = Instance.new("Frame")
	windowContent.Name = "WindowContent"
	windowContent.Size = UDim2.new(1, 0, 1, 0)
	windowContent.BackgroundTransparency = 1
	windowContent.BorderSizePixel = 0
	windowContent.ZIndex = 10
	windowContent.Parent = glassFrame.GlassSurface

	local contentPadding = Instance.new("UIPadding")
	contentPadding.PaddingTop = UDim.new(0, 14)
	contentPadding.PaddingBottom = UDim.new(0, 14)
	contentPadding.PaddingLeft = UDim.new(0, 14)
	contentPadding.PaddingRight = UDim.new(0, 14)
	contentPadding.Parent = windowContent

	-- Title bar (32px)
	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, 32)
	titleBar.Position = UDim2.new(0, 0, 0, 0)
	titleBar.BackgroundTransparency = 1
	titleBar.BorderSizePixel = 0
	titleBar.ZIndex = 10
	titleBar.Parent = windowContent

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, -40, 1, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 17
	titleLabel.TextColor3 = primaryText
	titleLabel.Text = windowName
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextYAlignment = Enum.TextYAlignment.Center
	titleLabel.BorderSizePixel = 0
	titleLabel.ZIndex = 10
	titleLabel.Parent = titleBar

	-- Close button (24x24 glass circle)
	local closeFrame = Instance.new("Frame")
	closeFrame.Name = "CloseButton"
	closeFrame.Size = UDim2.new(0, 24, 0, 24)
	closeFrame.Position = UDim2.new(1, -8, 0.5, 0)
	closeFrame.AnchorPoint = Vector2.new(1, 0.5)
	closeFrame.BackgroundColor3 = bgColor
	closeFrame.BackgroundTransparency = 0.75
	closeFrame.BorderSizePixel = 0
	closeFrame.ZIndex = 15
	closeFrame.Parent = titleBar

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 999)
	closeCorner.Parent = closeFrame

	local closeStroke = Instance.new("UIStroke")
	closeStroke.Thickness = 0.75
	closeStroke.Color = Color3.fromRGB(200, 200, 205)
	closeStroke.Transparency = 0.5
	closeStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	closeStroke.Parent = closeFrame

	local closeLabel = Instance.new("TextLabel")
	closeLabel.Size = UDim2.new(1, 0, 1, 0)
	closeLabel.BackgroundTransparency = 1
	closeLabel.Font = Enum.Font.GothamBold
	closeLabel.TextSize = 13
	closeLabel.Text = "X"
	closeLabel.TextColor3 = secondaryText
	closeLabel.ZIndex = 15
	closeLabel.Parent = closeFrame

	local closeHitArea = Instance.new("TextButton")
	closeHitArea.Name = "CloseHitArea"
	closeHitArea.Size = UDim2.new(1, 8, 1, 8)
	closeHitArea.AnchorPoint = Vector2.new(0.5, 0.5)
	closeHitArea.Position = UDim2.new(0.5, 0, 0.5, 0)
	closeHitArea.BackgroundTransparency = 1
	closeHitArea.Text = ""
	closeHitArea.BorderSizePixel = 0
	closeHitArea.ZIndex = 100
	closeHitArea.AutoButtonColor = false
	closeHitArea.Parent = closeFrame

	-- Drag hit area (title bar area)
	local dragHitArea = Instance.new("TextButton")
	dragHitArea.Name = "DragHitArea"
	dragHitArea.Size = UDim2.new(1, -32, 1, 0)
	dragHitArea.BackgroundTransparency = 1
	dragHitArea.Text = ""
	dragHitArea.BorderSizePixel = 0
	dragHitArea.ZIndex = 5
	dragHitArea.AutoButtonColor = false
	dragHitArea.Parent = titleBar

	-- Tab selector area (placeholder, filled when tabs > 1)
	local tabSelectorFrame = Instance.new("Frame")
	tabSelectorFrame.Name = "TabSelectorFrame"
	tabSelectorFrame.Size = UDim2.new(1, 0, 0, 0)
	tabSelectorFrame.Position = UDim2.new(0, 0, 0, 36)
	tabSelectorFrame.BackgroundTransparency = 1
	tabSelectorFrame.BorderSizePixel = 0
	tabSelectorFrame.ZIndex = 10
	tabSelectorFrame.Parent = windowContent

	local segmentedControl: Types.MangoSegmentedControl? = nil

	-- Content area (below title bar + tab selector)
	local contentArea = Instance.new("Frame")
	contentArea.Name = "ContentArea"
	contentArea.Size = UDim2.new(1, 0, 1, -36)
	contentArea.Position = UDim2.new(0, 0, 0, 36)
	contentArea.BackgroundTransparency = 1
	contentArea.BorderSizePixel = 0
	contentArea.ZIndex = 10
	contentArea.ClipsDescendants = true
	contentArea.Parent = windowContent

	local contentPadding = Instance.new("UIPadding")
	contentPadding.PaddingTop = UDim.new(0, 8)
	contentPadding.PaddingBottom = UDim.new(0, 8)
	contentPadding.Parent = contentArea

	-- Reopener pill (hidden initially)
	local reopenerGlass = MangoGlassFrame.new({
		Size = UDim2.new(0, 140, 0, 30),
		Position = UDim2.new(0.5, 0, 0, -40),
		AnchorPoint = Vector2.new(0.5, 0),
		CornerRadius = UDim.new(0, 999),
		BackgroundTransparency = 0.70,
		Theme = theme,
		ShadowEnabled = true,
		ShadowLayerCount = 1,
		ShadowSpread = 4,
		ShadowOffsetY = 1,
		LightweightMode = true,
		Parent = screenGui,
	})
	table.insert(innerDestroyables, reopenerGlass)

	local reopenerLabel = Instance.new("TextLabel")
	reopenerLabel.Name = "ReopenerLabel"
	reopenerLabel.Size = UDim2.new(1, 0, 1, 0)
	reopenerLabel.BackgroundTransparency = 1
	reopenerLabel.Font = Enum.Font.GothamMedium
	reopenerLabel.TextSize = 13
	reopenerLabel.TextColor3 = primaryText
	reopenerLabel.Text = showButtonText .. " v"
	reopenerLabel.ZIndex = 10
	reopenerLabel.Parent = reopenerGlass.GlassSurface

	local reopenerHitArea = Instance.new("TextButton")
	reopenerHitArea.Name = "HitArea"
	reopenerHitArea.Size = UDim2.new(1, 0, 1, 0)
	reopenerHitArea.BackgroundTransparency = 1
	reopenerHitArea.Text = ""
	reopenerHitArea.BorderSizePixel = 0
	reopenerHitArea.ZIndex = 100
	reopenerHitArea.AutoButtonColor = false
	reopenerHitArea.Parent = reopenerGlass.GlassSurface

	-- Notification stack
	local notifStack = MangoNotificationStack.new({
		MaxVisible = 3,
		Theme = theme,
		Parent = screenGui,
	})
	table.insert(innerDestroyables, notifStack)

	-- === Carousel dock position ===
	local function updateDockPosition()
		if not carouselDock then return end
		local absPos = windowContainer.AbsolutePosition
		local absSize = windowContainer.AbsoluteSize
		carouselDock.Container.Position = UDim2.new(0, absPos.X - DOCK_GAP, 0, absPos.Y + absSize.Y)
	end

	-- === Drag system (uses input.Position screen coords consistently, supports mouse + touch) ===
	local dragStartConn = dragHitArea.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			isDragging = true
			local containerPos = windowContainer.AbsolutePosition
			dragOffset = Vector2.new(input.Position.X - containerPos.X, input.Position.Y - containerPos.Y)
		end
	end)
	table.insert(connections, dragStartConn)

	local dragMoveConn = UserInputService.InputChanged:Connect(function(input: InputObject)
		if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			local mousePos = Vector2.new(input.Position.X, input.Position.Y)
			windowContainer.Position = UDim2.new(0, mousePos.X - dragOffset.X + windowContainer.AbsoluteSize.X * 0.5, 0, mousePos.Y - dragOffset.Y + windowContainer.AbsoluteSize.Y * 0.5)
			updateDockPosition()
		end
	end)
	table.insert(connections, dragMoveConn)

	local dragEndConn = UserInputService.InputEnded:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			isDragging = false
		end
	end)
	table.insert(connections, dragEndConn)

	-- === Close button hover ===
	local closeHoverTween: Tween? = nil
	local closeHoverConn = closeHitArea.MouseEnter:Connect(function()
		if closeHoverTween then closeHoverTween:Cancel() end
		closeHoverTween = TweenService:Create(closeFrame, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			BackgroundTransparency = 0.50,
		})
		trackTween(closeHoverTween)
		closeHoverTween:Play()
	end)
	table.insert(connections, closeHoverConn)

	local closeLeaveConn = closeHitArea.MouseLeave:Connect(function()
		if closeHoverTween then closeHoverTween:Cancel() end
		closeHoverTween = TweenService:Create(closeFrame, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			BackgroundTransparency = 0.75,
		})
		trackTween(closeHoverTween)
		closeHoverTween:Play()
	end)
	table.insert(connections, closeLeaveConn)

	-- === Flag dependency system ===
	local function evaluateDependencies(changedFlag: string)
		local dependents = flagDependents[changedFlag]
		if not dependents then return end
		local flagValue = flags[changedFlag]
		local isTruthy = flagValue and flagValue ~= false and flagValue ~= 0 and flagValue ~= ""
		for _, element in dependents do
			element:Visible(isTruthy)
		end
	end

	-- === Auto-save (debounced) ===
	local function triggerAutoSave()
		if not saveManager or not configSaving or not configSaving.Enabled then return end
		if saveDebounceThread then
			task.cancel(saveDebounceThread)
		end
		saveDebounceThread = task.delay(1, function()
			if isDestroyed then return end
			saveManager:Save(flags)
			saveDebounceThread = nil
		end)
	end

	local function registerFlag(flagName: string, element: Types.MangoWindowElement, initialValue: any)
		flags[flagName] = initialValue
		flagElements[flagName] = element
		element.CurrentValue = initialValue
	end

	local function updateFlag(flagName: string, value: any)
		flags[flagName] = value
		local el = flagElements[flagName]
		if el then
			el.CurrentValue = value
		end
		evaluateDependencies(flagName)
		triggerAutoSave()
	end

	local function registerDependency(element: Types.MangoWindowElement, visibleFlag: string)
		if not flagDependents[visibleFlag] then
			flagDependents[visibleFlag] = {}
		end
		table.insert(flagDependents[visibleFlag], element)
		-- Evaluate immediately
		local flagValue = flags[visibleFlag]
		local isTruthy = flagValue and flagValue ~= false and flagValue ~= 0 and flagValue ~= ""
		element:Visible(isTruthy)
	end

	-- === Tab switching ===
	local function switchToTab(index: number)
		if index == currentTabIndex then return end
		-- Hide current
		if tabData[currentTabIndex] then
			tabData[currentTabIndex].frame.Visible = false
		end
		currentTabIndex = index
		-- Sync carousel dock
		if carouselDock and carouselDock:GetIndex() ~= index then
			carouselDock:SetIndex(index)
		end
		-- Show new with spring animation
		local newTab = tabData[index]
		if newTab then
			local tabScale = newTab.frame:FindFirstChildOfClass("UIScale")
			if tabScale then
				tabScale.Scale = 0.98
			end
			newTab.frame.Visible = true
			if tabScale then
				local tabSwitchTween = TweenService:Create(tabScale, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {
					Scale = 1,
				})
				trackTween(tabSwitchTween)
				tabSwitchTween:Play()
			end
		end
	end

	-- === Show / Hide animations ===
	local function showWindow()
		if isVisible then return end
		isVisible = true
		windowContainer.Visible = true
		for _, delayThread in pendingDelays do
			task.cancel(delayThread)
		end
		table.clear(pendingDelays)
		cancelAllTweens()

		-- Hide reopener
		local reopenerTween = TweenService:Create(reopenerGlass.Container, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Position = UDim2.new(0.5, 0, 0, -40),
		})
		trackTween(reopenerTween)
		reopenerTween:Play()

		-- Materialize in
		windowUIScale.Scale = 0.95
		glassFrame.GlassSurface.BackgroundTransparency = 1

		local scaleTween = TweenService:Create(windowUIScale, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Scale = 1,
		})
		trackTween(scaleTween)
		scaleTween:Play()

		local delayThread1 = task.delay(0.03, function()
			if isDestroyed then return end
			local surfaceTween = TweenService:Create(glassFrame.GlassSurface, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundTransparency = windowBgTransp,
			})
			trackTween(surfaceTween)
			surfaceTween:Play()
		end)
		table.insert(pendingDelays, delayThread1)

		local delayThread2 = task.delay(0.08, function()
			if isDestroyed then return end
			for _, shadow in glassFrame.ShadowLayers do
				shadow.Visible = true
			end
		end)
		table.insert(pendingDelays, delayThread2)

		-- Show carousel dock with entrance animation
		if carouselDock then
			carouselDock.Container.Visible = true
			local delayThread3 = task.delay(0.1, function()
				if isDestroyed or not carouselDock then return end
				updateDockPosition()
				local pos = carouselDock.Container.Position
				carouselDock.Container.Position = UDim2.new(pos.X.Scale, pos.X.Offset, pos.Y.Scale, pos.Y.Offset + 30)
				local dockTween = TweenService:Create(carouselDock.Container, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
					Position = pos,
				})
				trackTween(dockTween)
				dockTween:Play()
			end)
			table.insert(pendingDelays, delayThread3)
		end
	end

	local function hideWindow()
		if not isVisible then return end
		isVisible = false
		cancelAllTweens()

		-- Hide carousel dock
		if carouselDock then
			carouselDock.Container.Visible = false
		end

		-- Shadows fade first
		for _, shadow in glassFrame.ShadowLayers do
			shadow.Visible = false
		end

		-- Surface dissolves
		local hideDelay1 = task.delay(0.04, function()
			if isDestroyed then return end
			TweenService:Create(glassFrame.GlassSurface, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundTransparency = 1,
			}):Play()
		end)
		table.insert(pendingDelays, hideDelay1)

		-- Scale out
		local scaleTween = TweenService:Create(windowUIScale, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Scale = 0.95,
		})
		trackTween(scaleTween)
		scaleTween:Play()
		scaleTween.Completed:Once(function()
			if isDestroyed then return end
			windowContainer.Visible = false
		end)

		-- Show reopener
		local hideDelay2 = task.delay(0.1, function()
			if isDestroyed then return end
			local reopenerTween = TweenService:Create(reopenerGlass.Container, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
				Position = UDim2.new(0.5, 0, 0, 8),
			})
			trackTween(reopenerTween)
			reopenerTween:Play()
		end)
		table.insert(pendingDelays, hideDelay2)
	end

	-- Close button click
	local closeClickConn = closeHitArea.MouseButton1Click:Connect(function()
		hideWindow()
	end)
	table.insert(connections, closeClickConn)

	-- Reopener click
	local reopenerClickConn = reopenerHitArea.MouseButton1Click:Connect(function()
		showWindow()
	end)
	table.insert(connections, reopenerClickConn)

	-- Toggle keybind
	if toggleKeyName then
		local keyCode = (Enum.KeyCode :: any)[toggleKeyName]
		if keyCode then
			local toggleConn = UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
				if gameProcessed then return end
				if input.KeyCode == keyCode then
					if isVisible then
						hideWindow()
					else
						showWindow()
					end
				end
			end)
			table.insert(connections, toggleConn)
		end
	end

	-- === Helper: create element row ===
	local function createRow(parentFrame: ScrollingFrame, height: number, name: string?): Frame
		local row = Instance.new("Frame")
		row.Name = name or "Row"
		row.Size = UDim2.new(1, 0, 0, height)
		row.BackgroundTransparency = 1
		row.BorderSizePixel = 0
		row.ZIndex = 10
		row.Parent = parentFrame
		return row
	end

	-- Update tab navigation when tabs change (carousel dock for multi-tab)
	local function rebuildTabSelector()
		if segmentedControl then
			segmentedControl:Destroy()
			segmentedControl = nil
		end
		if carouselDock then
			carouselDock:Destroy()
			carouselDock = nil
		end

		if #tabData <= 1 then
			tabSelectorFrame.Size = UDim2.new(1, 0, 0, 0)
			contentArea.Size = UDim2.new(1, 0, 1, -36)
			contentArea.Position = UDim2.new(0, 0, 0, 36)
			return
		end

		-- Build carousel tab configs from tabData
		local carouselTabs: {Types.MangoCarouselTabConfig} = {}
		for _, t in tabData do
			-- Auto-generate icon from first letter of name when no icon provided
			local tabIcon = t.icon
			if not tabIcon or tabIcon == "" then
				tabIcon = string.sub(t.name, 1, 1):upper()
			end
			table.insert(carouselTabs, {
				Icon = tabIcon,
				Label = t.name,
			})
		end

		carouselDock = MangoCarousel.new({
			Tabs = carouselTabs,
			Theme = theme,
			InitialIndex = currentTabIndex,
			OnChanged = function(index: number)
				switchToTab(index)
			end,
			Parent = screenGui,
		})
		carouselDock.Container.AnchorPoint = Vector2.new(1, 1)
		carouselDock.Container.ZIndex = 5
		carouselDock.Container.Visible = false

		-- No segmented control inside window — carousel handles tab switching
		tabSelectorFrame.Size = UDim2.new(1, 0, 0, 0)
		contentArea.Size = UDim2.new(1, 0, 1, -36)
		contentArea.Position = UDim2.new(0, 0, 0, 36)

		-- Position carousel next to window and show
		task.defer(function()
			if isDestroyed or not carouselDock then return end
			updateDockPosition()
			if isVisible then
				carouselDock.Container.Visible = true
			end
		end)
	end

	-- === Window return table ===
	local self: Types.MangoWindow

	-- Tab constructor
	local function createTab(name: string, icon: string?): Types.MangoWindowTab
		-- ScrollingFrame for tab content
		local tabFrame = Instance.new("ScrollingFrame")
		tabFrame.Name = "Tab_" .. name
		tabFrame.Size = UDim2.new(1, 0, 1, 0)
		tabFrame.BackgroundTransparency = 1
		tabFrame.BorderSizePixel = 0
		tabFrame.ScrollBarThickness = 4
		tabFrame.ScrollingDirection = Enum.ScrollingDirection.Y
		tabFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
		tabFrame.ZIndex = 10
		tabFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
		tabFrame.Visible = #tabData == 0 -- First tab is visible
		tabFrame.Parent = contentArea

		local tabUIScale = Instance.new("UIScale")
		tabUIScale.Scale = 1
		tabUIScale.Parent = tabFrame

		local tabLayout = Instance.new("UIListLayout")
		tabLayout.FillDirection = Enum.FillDirection.Vertical
		tabLayout.Padding = UDim.new(0, 10)
		tabLayout.SortOrder = Enum.SortOrder.LayoutOrder
		tabLayout.Parent = tabFrame

		local tabPadding = Instance.new("UIPadding")
		tabPadding.PaddingTop = UDim.new(0, 6)
		tabPadding.PaddingBottom = UDim.new(0, 6)
		tabPadding.Parent = tabFrame

		local elements: {Types.MangoWindowElement} = {}
		local entry = {name = name, icon = icon, frame = tabFrame, elements = elements}
		table.insert(tabData, entry)

		rebuildTabSelector()

		-- Element layout order counter
		local layoutOrder = 0
		local function nextOrder(): number
			layoutOrder += 1
			return layoutOrder
		end

		-- Tab methods
		local tab: Types.MangoWindowTab = {
			Button = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowButtonConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 42)
				row.LayoutOrder = nextOrder()

				local btn = MangoButton.new({
					Position = UDim2.new(0, 4, 0, 0),
					Size = UDim2.new(1, -8, 0, 36),
					Text = cfg.Name,
					Theme = theme,
					ShadowEnabled = false,
					OnActivated = cfg.Callback,
					Parent = row,
				})
				table.insert(innerDestroyables, btn)

				local element = createWindowElement({
					getValue = function() return nil end,
					setValue = function(_val: any)
						if cfg.Callback then cfg.Callback() end
					end,
					rowFrame = row,
					destroyInner = function() btn:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, true) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Toggle = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowToggleConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 38)
				row.LayoutOrder = nextOrder()

				local nameLabel = Instance.new("TextLabel")
				nameLabel.Size = UDim2.new(1, -60, 1, 0)
				nameLabel.BackgroundTransparency = 1
				nameLabel.Font = Enum.Font.GothamMedium
				nameLabel.TextSize = 14
				nameLabel.TextColor3 = primaryText
				nameLabel.Text = cfg.Name
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				nameLabel.ZIndex = 10
				nameLabel.Parent = row

				local defaultVal = resolve(cfg.Default, nil, false) :: boolean
				local toggle = MangoToggle.new({
					Position = UDim2.new(1, -55, 0.5, 0),
					AnchorPoint = Vector2.new(0, 0.5),
					Theme = theme,
					ShadowEnabled = false,
					InitialState = defaultVal,
					OnToggled = function(state: boolean)
						if cfg.Flag then updateFlag(cfg.Flag, state) end
						if cfg.Callback then cfg.Callback(state) end
					end,
					Parent = row,
				})
				table.insert(innerDestroyables, toggle)

				local element = createWindowElement({
					getValue = function() return toggle:GetState() end,
					setValue = function(val: any) toggle:SetState(val :: boolean) end,
					rowFrame = row,
					destroyInner = function() toggle:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultVal) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Slider = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowSliderConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 56)
				row.LayoutOrder = nextOrder()

				local range = cfg.Range or {0, 100}
				local minVal = range[1] or 0
				local maxVal = range[2] or 100
				local defaultVal = resolve(cfg.Default, nil, minVal) :: number
				local suffix = cfg.Suffix or ""

				local valueLabel = Instance.new("TextLabel")
				valueLabel.Size = UDim2.new(1, 0, 0, 18)
				valueLabel.BackgroundTransparency = 1
				valueLabel.Font = Enum.Font.GothamMedium
				valueLabel.TextSize = 13
				valueLabel.TextColor3 = primaryText
				valueLabel.Text = cfg.Name .. ": " .. tostring(defaultVal) .. suffix
				valueLabel.TextXAlignment = Enum.TextXAlignment.Left
				valueLabel.ZIndex = 10
				valueLabel.Parent = row

				local slider = MangoSlider.new({
					Position = UDim2.new(0, 8, 0, 22),
					Size = UDim2.new(1, -16, 0, 32),
					Theme = theme,
					ShadowEnabled = false,
					InitialValue = defaultVal,
					Min = minVal,
					Max = maxVal,
					Step = cfg.Increment,
					OnChanged = function(value: number)
						valueLabel.Text = cfg.Name .. ": " .. tostring(value) .. suffix
						if cfg.Flag then updateFlag(cfg.Flag, value) end
						if cfg.Callback then cfg.Callback(value) end
					end,
					Parent = row,
				})
				table.insert(innerDestroyables, slider)

				local element = createWindowElement({
					getValue = function() return slider:GetValue() end,
					setValue = function(val: any)
						slider:SetValue(val :: number)
						valueLabel.Text = cfg.Name .. ": " .. tostring(val) .. suffix
					end,
					rowFrame = row,
					destroyInner = function() slider:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultVal) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Dropdown = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowDropdownConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 42)
				row.LayoutOrder = nextOrder()

				local options = cfg.Options or {}
				local isMulti = cfg.MultiSelect == true

				-- Find initial index from Default
				local initIndex = 1
				local initItems: {string}? = nil
				if type(cfg.Default) == "string" then
					for i, opt in options do
						if opt == cfg.Default then
							initIndex = i
							break
						end
					end
				elseif type(cfg.Default) == "table" then
					initItems = cfg.Default :: {string}
				end

				local nameLabel = Instance.new("TextLabel")
				nameLabel.Size = UDim2.new(0.4, 0, 1, 0)
				nameLabel.BackgroundTransparency = 1
				nameLabel.Font = Enum.Font.GothamMedium
				nameLabel.TextSize = 14
				nameLabel.TextColor3 = primaryText
				nameLabel.Text = cfg.Name
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				nameLabel.ZIndex = 10
				nameLabel.Parent = row

				local dropdown = MangoDropdown.new({
					Position = UDim2.new(0.42, 2, 0, 2),
					Size = UDim2.new(0.56, -4, 0, 36),
					ShadowEnabled = false,
					Items = options,
					InitialIndex = initIndex,
					MultiSelect = isMulti,
					InitialItems = initItems,
					Theme = theme,
					OnChanged = function(index: number)
						if not isMulti then
							local val = options[index]
							if cfg.Flag then updateFlag(cfg.Flag, val) end
							if cfg.Callback then cfg.Callback(val) end
						end
					end,
					OnMultiChanged = if isMulti then function(selected: {string})
						if cfg.Flag then updateFlag(cfg.Flag, selected) end
						if cfg.Callback then cfg.Callback(selected) end
					end else nil,
					Parent = row,
				})
				table.insert(innerDestroyables, dropdown)

				local defaultValue: any = if isMulti then (initItems or {}) else (options[initIndex] or "")
				local element = createWindowElement({
					getValue = function()
						if isMulti then
							return dropdown:GetSelectedItems()
						end
						local idx = dropdown:GetSelectedIndex()
						return options[idx] or ""
					end,
					setValue = function(val: any)
						if type(val) == "string" then
							for i, opt in options do
								if opt == val then
									dropdown:SetSelectedIndex(i)
									break
								end
							end
						end
					end,
					rowFrame = row,
					destroyInner = function() dropdown:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultValue) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Input = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowInputConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 56)
				row.LayoutOrder = nextOrder()

				local nameLabel = Instance.new("TextLabel")
				nameLabel.Size = UDim2.new(1, 0, 0, 18)
				nameLabel.BackgroundTransparency = 1
				nameLabel.Font = Enum.Font.GothamMedium
				nameLabel.TextSize = 13
				nameLabel.TextColor3 = primaryText
				nameLabel.Text = cfg.Name
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				nameLabel.ZIndex = 10
				nameLabel.Parent = row

				local defaultText = resolve(cfg.Default, nil, "") :: string
				local textField = MangoTextField.new({
					Position = UDim2.new(0, 4, 0, 20),
					Size = UDim2.new(1, -8, 0, 36),
					Placeholder = cfg.Placeholder,
					InitialText = defaultText,
					Masked = cfg.Masked,
					ShadowEnabled = false,
					Theme = theme,
					OnFocusLost = function(text: string, _enterPressed: boolean)
						if cfg.Flag then updateFlag(cfg.Flag, text) end
						if cfg.Callback then cfg.Callback(text) end
					end,
					Parent = row,
				})
				table.insert(innerDestroyables, textField)

				local element = createWindowElement({
					getValue = function() return textField:GetText() end,
					setValue = function(val: any) textField:SetText(val :: string) end,
					rowFrame = row,
					destroyInner = function() textField:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultText) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Checkbox = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowCheckboxConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 36)
				row.LayoutOrder = nextOrder()

				local defaultVal = resolve(cfg.Default, nil, false) :: boolean
				local checkbox = MangoCheckbox.new({
					Position = UDim2.new(0, 0, 0, 0),
					Label = cfg.Name,
					InitialState = defaultVal,
					Theme = theme,
					OnToggled = function(state: boolean)
						if cfg.Flag then updateFlag(cfg.Flag, state) end
						if cfg.Callback then cfg.Callback(state) end
					end,
					Parent = row,
				})
				table.insert(innerDestroyables, checkbox)

				local element = createWindowElement({
					getValue = function() return checkbox:GetState() end,
					setValue = function(val: any) checkbox:SetState(val :: boolean) end,
					rowFrame = row,
					destroyInner = function() checkbox:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultVal) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Stepper = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowStepperConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 42)
				row.LayoutOrder = nextOrder()

				local range = cfg.Range or {0, 100}
				local defaultVal = resolve(cfg.Default, nil, range[1] or 0) :: number

				local nameLabel = Instance.new("TextLabel")
				nameLabel.Size = UDim2.new(0.5, 0, 1, 0)
				nameLabel.BackgroundTransparency = 1
				nameLabel.Font = Enum.Font.GothamMedium
				nameLabel.TextSize = 14
				nameLabel.TextColor3 = primaryText
				nameLabel.Text = cfg.Name
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				nameLabel.ZIndex = 10
				nameLabel.Parent = row

				local stepper = MangoStepper.new({
					Position = UDim2.new(1, -124, 0.5, 0),
					AnchorPoint = Vector2.new(0, 0.5),
					InitialValue = defaultVal,
					Min = range[1],
					Max = range[2],
					ShadowEnabled = false,
					Theme = theme,
					OnChanged = function(value: number)
						if cfg.Flag then updateFlag(cfg.Flag, value) end
						if cfg.Callback then cfg.Callback(value) end
					end,
					Parent = row,
				})
				table.insert(innerDestroyables, stepper)

				local element = createWindowElement({
					getValue = function() return stepper:GetValue() end,
					setValue = function(val: any) stepper:SetValue(val :: number) end,
					rowFrame = row,
					destroyInner = function() stepper:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultVal) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Progress = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowProgressConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 42)
				row.LayoutOrder = nextOrder()

				local defaultVal = resolve(cfg.Default, nil, 0) :: number

				local nameLabel = Instance.new("TextLabel")
				nameLabel.Size = UDim2.new(1, 0, 0, 18)
				nameLabel.BackgroundTransparency = 1
				nameLabel.Font = Enum.Font.GothamMedium
				nameLabel.TextSize = 13
				nameLabel.TextColor3 = primaryText
				nameLabel.Text = cfg.Name
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				nameLabel.ZIndex = 10
				nameLabel.Parent = row

				local progressBar = MangoProgressBar.new({
					Position = UDim2.new(0, 4, 0, 20),
					Size = UDim2.new(1, -8, 0, 20),
					InitialValue = defaultVal,
					ShadowEnabled = false,
					Theme = theme,
					Parent = row,
				})
				table.insert(innerDestroyables, progressBar)

				local element = createWindowElement({
					getValue = function() return progressBar:GetValue() end,
					setValue = function(val: any) progressBar:SetValue(val :: number) end,
					rowFrame = row,
					destroyInner = function() progressBar:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultVal) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			ColorPicker = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowColorPickerConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 40)
				row.LayoutOrder = nextOrder()

				local defaultColor = resolve(cfg.Default, nil, Color3.fromRGB(255, 0, 0)) :: Color3

				local nameLabel = Instance.new("TextLabel")
				nameLabel.Size = UDim2.new(1, -36, 1, 0)
				nameLabel.BackgroundTransparency = 1
				nameLabel.Font = Enum.Font.GothamMedium
				nameLabel.TextSize = 14
				nameLabel.TextColor3 = primaryText
				nameLabel.Text = cfg.Name
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				nameLabel.ZIndex = 10
				nameLabel.Parent = row

				-- Color preview circle
				local preview = Instance.new("Frame")
				preview.Name = "ColorPreview"
				preview.Size = UDim2.new(0, 24, 0, 24)
				preview.Position = UDim2.new(1, -4, 0.5, 0)
				preview.AnchorPoint = Vector2.new(1, 0.5)
				preview.BackgroundColor3 = defaultColor
				preview.BorderSizePixel = 0
				preview.ZIndex = 10
				preview.Parent = row

				local previewCorner = Instance.new("UICorner")
				previewCorner.CornerRadius = UDim.new(0, 999)
				previewCorner.Parent = preview

				local previewStroke = Instance.new("UIStroke")
				previewStroke.Thickness = 1
				previewStroke.Color = Color3.fromRGB(200, 200, 205)
				previewStroke.Transparency = 0.5
				previewStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
				previewStroke.Parent = preview

				-- Popup color picker (created on click, destroyed on close)
				local pickerInstance: Types.MangoColorPicker? = nil
				local previewHitArea = Instance.new("TextButton")
				previewHitArea.Name = "PreviewHitArea"
				previewHitArea.Size = UDim2.new(0, 32, 0, 32)
				previewHitArea.AnchorPoint = Vector2.new(1, 0.5)
				previewHitArea.Position = UDim2.new(1, 4, 0.5, 0)
				previewHitArea.BackgroundTransparency = 1
				previewHitArea.Text = ""
				previewHitArea.ZIndex = 100
				previewHitArea.AutoButtonColor = false
				previewHitArea.Parent = row

				local previewConn = previewHitArea.MouseButton1Click:Connect(function()
					if pickerInstance then
						pickerInstance:Destroy()
						pickerInstance = nil
						return
					end

					local absPos = preview.AbsolutePosition
					pickerInstance = MangoColorPicker.new({
						Position = UDim2.new(0, absPos.X - 240, 0, absPos.Y + 30),
						InitialColor = preview.BackgroundColor3,
						Theme = theme,
						OnChanged = function(color: Color3)
							preview.BackgroundColor3 = color
							if cfg.Flag then updateFlag(cfg.Flag, color) end
							if cfg.Callback then cfg.Callback(color) end
						end,
						Parent = screenGui,
					})
					table.insert(innerDestroyables, pickerInstance)
				end)
				table.insert(connections, previewConn)

				local element = createWindowElement({
					getValue = function() return preview.BackgroundColor3 end,
					setValue = function(val: any)
						local c = val :: Color3
						preview.BackgroundColor3 = c
						if pickerInstance then
							pickerInstance:SetColor(c)
						end
					end,
					rowFrame = row,
					destroyInner = function()
						if pickerInstance then
							pickerInstance:Destroy()
							pickerInstance = nil
						end
					end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultColor) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Keybind = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowKeybindConfig): Types.MangoWindowElement
				local row = createRow(tabFrame, 42)
				row.LayoutOrder = nextOrder()

				local defaultKey = resolve(cfg.Default, nil, "None") :: string

				local nameLabel = Instance.new("TextLabel")
				nameLabel.Size = UDim2.new(1, -90, 1, 0)
				nameLabel.BackgroundTransparency = 1
				nameLabel.Font = Enum.Font.GothamMedium
				nameLabel.TextSize = 14
				nameLabel.TextColor3 = primaryText
				nameLabel.Text = cfg.Name
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				nameLabel.ZIndex = 10
				nameLabel.Parent = row

				local keybind = MangoKeybind.new({
					Position = UDim2.new(1, -84, 0.5, 0),
					AnchorPoint = Vector2.new(0, 0.5),
					DefaultKey = defaultKey,
					ShadowEnabled = false,
					Theme = theme,
					OnKeyChanged = function(keyName: string)
						if cfg.Flag then updateFlag(cfg.Flag, keyName) end
						if cfg.Callback then cfg.Callback(keyName) end
					end,
					Parent = row,
				})
				table.insert(innerDestroyables, keybind)

				local element = createWindowElement({
					getValue = function() return keybind:GetKey() end,
					setValue = function(val: any) keybind:SetKey(val :: string) end,
					rowFrame = row,
					destroyInner = function() keybind:Destroy() end,
				})
				if cfg.Flag then registerFlag(cfg.Flag, element, defaultKey) end
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Label = function(self: Types.MangoWindowTab, text: string): Types.MangoWindowElement
				local row = createRow(tabFrame, 20)
				row.LayoutOrder = nextOrder()

				local label = Instance.new("TextLabel")
				label.Size = UDim2.new(1, 0, 1, 0)
				label.BackgroundTransparency = 1
				label.Font = Enum.Font.Gotham
				label.TextSize = 13
				label.TextColor3 = secondaryText
				label.Text = text
				label.TextXAlignment = Enum.TextXAlignment.Left
				label.ZIndex = 10
				label.Parent = row

				local element = createWindowElement({
					getValue = function() return label.Text end,
					setValue = function(val: any) label.Text = val :: string end,
					rowFrame = row,
					destroyInner = function() end,
				})
				table.insert(elements, element)
				return element
			end,

			Paragraph = function(self: Types.MangoWindowTab, cfg: Types.MangoWindowParagraphConfig): Types.MangoWindowElement
				local row = Instance.new("Frame")
				row.Name = "Paragraph"
				row.Size = UDim2.new(1, 0, 0, 0)
				row.AutomaticSize = Enum.AutomaticSize.Y
				row.BackgroundTransparency = 1
				row.BorderSizePixel = 0
				row.ZIndex = 10
				row.LayoutOrder = nextOrder()
				row.Parent = tabFrame

				local paraLayout = Instance.new("UIListLayout")
				paraLayout.FillDirection = Enum.FillDirection.Vertical
				paraLayout.Padding = UDim.new(0, 2)
				paraLayout.SortOrder = Enum.SortOrder.LayoutOrder
				paraLayout.Parent = row

				local titleLbl = Instance.new("TextLabel")
				titleLbl.Size = UDim2.new(1, 0, 0, 0)
				titleLbl.AutomaticSize = Enum.AutomaticSize.Y
				titleLbl.BackgroundTransparency = 1
				titleLbl.Font = Enum.Font.GothamBold
				titleLbl.TextSize = 14
				titleLbl.TextColor3 = primaryText
				titleLbl.Text = cfg.Title
				titleLbl.TextXAlignment = Enum.TextXAlignment.Left
				titleLbl.TextWrapped = true
				titleLbl.ZIndex = 10
				titleLbl.LayoutOrder = 1
				titleLbl.Parent = row

				local contentLbl = Instance.new("TextLabel")
				contentLbl.Size = UDim2.new(1, 0, 0, 0)
				contentLbl.AutomaticSize = Enum.AutomaticSize.Y
				contentLbl.BackgroundTransparency = 1
				contentLbl.Font = Enum.Font.Gotham
				contentLbl.TextSize = 13
				contentLbl.TextColor3 = secondaryText
				contentLbl.Text = cfg.Content
				contentLbl.TextXAlignment = Enum.TextXAlignment.Left
				contentLbl.TextWrapped = true
				contentLbl.ZIndex = 10
				contentLbl.LayoutOrder = 2
				contentLbl.Parent = row

				local element = createWindowElement({
					getValue = function() return cfg.Content end,
					setValue = function(val: any) contentLbl.Text = val :: string end,
					rowFrame = row,
					destroyInner = function() end,
				})
				if type(cfg.Visible) == "string" then registerDependency(element, cfg.Visible :: string) end
				table.insert(elements, element)
				return element
			end,

			Section = function(self: Types.MangoWindowTab, title: string): Types.MangoWindowElement
				local row = createRow(tabFrame, 36)
				row.LayoutOrder = nextOrder()

				local sectionLabel = Instance.new("TextLabel")
				sectionLabel.Size = UDim2.new(1, 0, 0, 22)
				sectionLabel.BackgroundTransparency = 1
				sectionLabel.Font = Enum.Font.GothamBold
				sectionLabel.TextSize = 15
				sectionLabel.TextColor3 = primaryText
				sectionLabel.Text = title
				sectionLabel.TextXAlignment = Enum.TextXAlignment.Left
				sectionLabel.ZIndex = 10
				sectionLabel.Parent = row

				local sep = Instance.new("Frame")
				sep.Size = UDim2.new(1, 0, 0, 1)
				sep.Position = UDim2.new(0, 0, 1, -1)
				sep.BackgroundColor3 = bgColor
				sep.BackgroundTransparency = 0.80
				sep.BorderSizePixel = 0
				sep.ZIndex = 10
				sep.Parent = row

				local element = createWindowElement({
					getValue = function() return title end,
					setValue = function(val: any) sectionLabel.Text = val :: string end,
					rowFrame = row,
					destroyInner = function() end,
				})
				table.insert(elements, element)
				return element
			end,

			Separator = function(self: Types.MangoWindowTab): Types.MangoWindowElement
				local row = createRow(tabFrame, 9)
				row.LayoutOrder = nextOrder()

				local sep = Instance.new("Frame")
				sep.Size = UDim2.new(1, 0, 0, 1)
				sep.Position = UDim2.new(0, 0, 0.5, 0)
				sep.AnchorPoint = Vector2.new(0, 0.5)
				sep.BackgroundColor3 = bgColor
				sep.BackgroundTransparency = 0.80
				sep.BorderSizePixel = 0
				sep.ZIndex = 10
				sep.Parent = row

				local element = createWindowElement({
					getValue = function() return nil end,
					setValue = function(_val: any) end,
					rowFrame = row,
					destroyInner = function() end,
				})
				table.insert(elements, element)
				return element
			end,
		}

		return tab
	end

	self = {
		Flags = flags,
		Tab = function(self: Types.MangoWindow, name: string, icon: string?): Types.MangoWindowTab
			return createTab(name, icon)
		end,
		Notify = function(self: Types.MangoWindow, cfg: Types.MangoNotificationConfig)
			local notif = notifStack:Push(cfg)
			notif:Show()
		end,
		Dialog = function(self: Types.MangoWindow, cfg: Types.MangoDialogConfig)
			local dialog = MangoDialog.new({
				Title = cfg.Title,
				Message = cfg.Message,
				Buttons = cfg.Buttons,
				Theme = theme,
				OnDismissed = cfg.OnDismissed,
				Parent = screenGui,
			})
			table.insert(innerDestroyables, dialog)
			dialog:Show()
		end,
		Show = function(self: Types.MangoWindow)
			showWindow()
		end,
		Hide = function(self: Types.MangoWindow)
			hideWindow()
		end,
		IsVisible = function(self: Types.MangoWindow): boolean
			return isVisible
		end,
		SaveConfig = function(self: Types.MangoWindow)
			if saveManager then
				-- Serialize Color3 values to table format
				local serialized: {[string]: any} = {}
				for key, value in flags do
					if typeof(value) == "Color3" then
						local c = value :: Color3
						serialized[key] = {_type = "Color3", R = c.R, G = c.G, B = c.B}
					else
						serialized[key] = value
					end
				end
				saveManager:Save(serialized)
			end
		end,
		LoadConfig = function(self: Types.MangoWindow)
			if not saveManager then return end
			local data = saveManager:Load()
			if not data then return end
			for key, value in data do
				-- Deserialize Color3
				if type(value) == "table" and (value :: any)._type == "Color3" then
					value = Color3.new((value :: any).R, (value :: any).G, (value :: any).B)
				end
				flags[key] = value
				local element = flagElements[key]
				if element then
					element:Set(value)
				end
				evaluateDependencies(key)
			end
		end,
		Destroy = function(self: Types.MangoWindow)
			if isDestroyed then return end
			isDestroyed = true

			if saveDebounceThread then
				task.cancel(saveDebounceThread)
				saveDebounceThread = nil
			end

			for _, delayThread in pendingDelays do
				task.cancel(delayThread)
			end
			table.clear(pendingDelays)

			if closeHoverTween then
				closeHoverTween:Cancel()
				closeHoverTween = nil
			end

			cancelAllTweens()
			for _, conn in connections do
				conn:Disconnect()
			end
			table.clear(connections)

			for _, destroyable in innerDestroyables do
				if typeof(destroyable) == "table" and (destroyable :: any).Destroy then
					(destroyable :: any):Destroy()
				end
			end
			table.clear(innerDestroyables)

			if carouselDock then
				carouselDock:Destroy()
				carouselDock = nil
			end

			notifStack:Destroy()
			glassFrame:Destroy()
			reopenerGlass:Destroy()
			screenGui:Destroy()
		end,
	}

	-- Auto-load saved config
	if saveManager then
		task.defer(function()
			if isDestroyed then return end
			self:LoadConfig()
		end)
	end

	return self
end

return module

end

_modules["MangoBuilder"] = function()


local Types = _require("Types")

local module = {}

-- Component type to module name mapping
local COMPONENT_MAP: {[string]: string} = {
    button = "MangoButton",
    slider = "MangoSlider",
    toggle = "MangoToggle",
    checkbox = "MangoCheckbox",
    dialog = "MangoDialog",
    actionsheet = "MangoActionSheet",
    dropdown = "MangoDropdown",
    tabbar = "MangoTabBar",
    search = "MangoSearchBar",
    textfield = "MangoTextField",
    progress = "MangoProgressBar",
    glass = "MangoGlassFrame",
    notification = "MangoNotification",
    notifstack = "MangoNotificationStack",
    segmented = "MangoSegmentedControl",
    billboard = "MangoBillboardLabel",
    badge = "MangoBadge",
    skeleton = "MangoSkeleton",
    stepper = "MangoStepper",
    tooltip = "MangoTooltip",
    toast = "MangoToast",
    contextmenu = "MangoContextMenu",
    bottomsheet = "MangoBottomSheet",
    blur = "MangoBlurProxy",
    form = "MangoForm",
    focus = "MangoFocusManager",
    layout = "MangoLayout",
    shimmer = "MangoShimmer",
    window = "MangoWindow",
    carousel = "MangoCarousel",
    colorpicker = "MangoColorPicker",
    keybind = "MangoKeybind",
    savemanager = "MangoSaveManager",
}

function module.build(componentType: string): Types.MangoBuilder
    local moduleName = COMPONENT_MAP[componentType]
    if not moduleName then
        error("Unknown component type: " .. componentType)
    end

    local config: {[string]: any} = {}
    local componentModule: any = nil

    -- Lazy-load the component module
    local function getModule(): any
        if componentModule then return componentModule end
        componentModule = require(script.Parent:FindFirstChild(moduleName) :: ModuleScript)
        return componentModule
    end

    local self: Types.MangoBuilder
    self = {
        text = function(self: Types.MangoBuilder, text: string): Types.MangoBuilder
            config.Text = text
            return self
        end,
        theme = function(self: Types.MangoBuilder, theme: Types.ThemePreset): Types.MangoBuilder
            config.Theme = theme
            return self
        end,
        pos = function(self: Types.MangoBuilder, xScale: number, xOffset: number, yScale: number, yOffset: number): Types.MangoBuilder
            config.Position = UDim2.new(xScale, xOffset, yScale, yOffset)
            return self
        end,
        anchor = function(self: Types.MangoBuilder, x: number, y: number): Types.MangoBuilder
            config.AnchorPoint = Vector2.new(x, y)
            return self
        end,
        size = function(self: Types.MangoBuilder, xScale: number, xOffset: number, yScale: number, yOffset: number): Types.MangoBuilder
            config.Size = UDim2.new(xScale, xOffset, yScale, yOffset)
            return self
        end,
        parent = function(self: Types.MangoBuilder, parent: GuiObject): Types.MangoBuilder
            config.Parent = parent
            return self
        end,
        onClick = function(self: Types.MangoBuilder, callback: () -> ()): Types.MangoBuilder
            config.OnActivated = callback
            return self
        end,
        onChange = function(self: Types.MangoBuilder, callback: (value: any) -> ()): Types.MangoBuilder
            config.OnChanged = callback
            config.OnToggled = callback
            config.OnTextChanged = callback
            return self
        end,
        prop = function(self: Types.MangoBuilder, key: string, value: any): Types.MangoBuilder
            config[key] = value
            return self
        end,
        create = function(self: Types.MangoBuilder): any
            local mod = getModule()
            return mod.new(config)
        end,
    }

    return self
end

return module

end

-- Build library table
local Themes = _require("Themes")
local MangoGlassFrame = _require("MangoGlassFrame")
local RefractionProxy = _require("RefractionProxy")
local LiquidFusion = _require("LiquidFusion")
local MangoToggle = _require("MangoToggle")
local MangoSlider = _require("MangoSlider")
local MangoButton = _require("MangoButton")
local MangoBillboardLabel = _require("MangoBillboardLabel")
local MangoNotification = _require("MangoNotification")
local MangoNotificationStack = _require("MangoNotificationStack")
local MangoSegmentedControl = _require("MangoSegmentedControl")
local MangoDropdown = _require("MangoDropdown")
local MangoTabBar = _require("MangoTabBar")
local MangoSearchBar = _require("MangoSearchBar")
local MangoTextField = _require("MangoTextField")
local MangoCheckbox = _require("MangoCheckbox")
local MangoProgressBar = _require("MangoProgressBar")
local MangoDialog = _require("MangoDialog")
local MangoActionSheet = _require("MangoActionSheet")
local MangoEnvironmentLight = _require("MangoEnvironmentLight")
local MangoIntro = _require("MangoIntro")
local MangoShimmer = _require("MangoShimmer")
local MangoHaptics = _require("MangoHaptics")
local MangoLayout = _require("MangoLayout")
local MangoBadge = _require("MangoBadge")
local MangoSkeleton = _require("MangoSkeleton")
local MangoStepper = _require("MangoStepper")
local MangoTooltip = _require("MangoTooltip")
local MangoToast = _require("MangoToast")
local MangoContextMenu = _require("MangoContextMenu")
local MangoBottomSheet = _require("MangoBottomSheet")
local MangoBlurProxy = _require("MangoBlurProxy")
local MangoForm = _require("MangoForm")
local MangoFocusManager = _require("MangoFocusManager")
local MangoSaveManager = _require("MangoSaveManager")
local MangoColorPicker = _require("MangoColorPicker")
local MangoKeybind = _require("MangoKeybind")
local MangoCarousel = _require("MangoCarousel")
local MangoWindow = _require("MangoWindow")
local MangoBuilder = _require("MangoBuilder")
local MangoProtection = _require("MangoProtection")

local MangoLiquidUI = {
    -- Full module names (backward compat)
    MangoGlassFrame = MangoGlassFrame,
    RefractionProxy = RefractionProxy,
    LiquidFusion = LiquidFusion,
    MangoToggle = MangoToggle,
    MangoSlider = MangoSlider,
    MangoButton = MangoButton,
    MangoBillboardLabel = MangoBillboardLabel,
    MangoNotification = MangoNotification,
    MangoNotificationStack = MangoNotificationStack,
    MangoSegmentedControl = MangoSegmentedControl,
    MangoDropdown = MangoDropdown,
    MangoTabBar = MangoTabBar,
    MangoSearchBar = MangoSearchBar,
    MangoTextField = MangoTextField,
    MangoCheckbox = MangoCheckbox,
    MangoProgressBar = MangoProgressBar,
    MangoDialog = MangoDialog,
    MangoActionSheet = MangoActionSheet,
    MangoEnvironmentLight = MangoEnvironmentLight,
    MangoIntro = MangoIntro,
    Themes = Themes,
    resolve = Themes.resolve,

    -- New full module names
    MangoShimmer = MangoShimmer,
    MangoHaptics = MangoHaptics,
    MangoLayout = MangoLayout,
    MangoBadge = MangoBadge,
    MangoSkeleton = MangoSkeleton,
    MangoStepper = MangoStepper,
    MangoTooltip = MangoTooltip,
    MangoToast = MangoToast,
    MangoContextMenu = MangoContextMenu,
    MangoBottomSheet = MangoBottomSheet,
    MangoBlurProxy = MangoBlurProxy,
    MangoForm = MangoForm,
    MangoFocusManager = MangoFocusManager,
    MangoSaveManager = MangoSaveManager,
    MangoColorPicker = MangoColorPicker,
    MangoKeybind = MangoKeybind,
    MangoCarousel = MangoCarousel,
    MangoWindow = MangoWindow,
    MangoBuilder = MangoBuilder,
    MangoProtection = MangoProtection,

    -- Theme shortcuts
    Light = Themes.Light,
    Dark = Themes.Dark,
    Mango = Themes.Mango,
    Mint = Themes.Mint,

    -- Intro module shortcut
    intro = MangoIntro,

    -- Haptics module shortcut
    haptic = MangoHaptics,
}

-- Existing short-name constructors
function MangoLiquidUI.bttn(config) return MangoButton.new(config) end
function MangoLiquidUI.sldr(config) return MangoSlider.new(config) end
function MangoLiquidUI.tgl(config) return MangoToggle.new(config) end
function MangoLiquidUI.chk(config) return MangoCheckbox.new(config) end
function MangoLiquidUI.dlg(config) return MangoDialog.new(config) end
function MangoLiquidUI.act(config) return MangoActionSheet.new(config) end
function MangoLiquidUI.drp(config) return MangoDropdown.new(config) end
function MangoLiquidUI.tab(config) return MangoTabBar.new(config) end
function MangoLiquidUI.srch(config) return MangoSearchBar.new(config) end
function MangoLiquidUI.txt(config) return MangoTextField.new(config) end
function MangoLiquidUI.prog(config) return MangoProgressBar.new(config) end
function MangoLiquidUI.glass(config) return MangoGlassFrame.new(config) end
function MangoLiquidUI.notif(config) return MangoNotification.new(config) end
function MangoLiquidUI.nstack(config) return MangoNotificationStack.new(config) end
function MangoLiquidUI.seg(config) return MangoSegmentedControl.new(config) end
function MangoLiquidUI.bbl(config) return MangoBillboardLabel.new(config) end
function MangoLiquidUI.env(config) return MangoEnvironmentLight.new(config) end
function MangoLiquidUI.refr(config) return RefractionProxy.new(config) end
function MangoLiquidUI.fuse(config) return LiquidFusion.new(config) end

-- New short-name constructors
function MangoLiquidUI.shimr(config) return MangoShimmer.new(config) end
function MangoLiquidUI.layout(config) return MangoLayout.new(config) end
function MangoLiquidUI.bdg(config) return MangoBadge.new(config) end
function MangoLiquidUI.skel(config) return MangoSkeleton.new(config) end
function MangoLiquidUI.step(config) return MangoStepper.new(config) end
function MangoLiquidUI.tip(config) return MangoTooltip.new(config) end
function MangoLiquidUI.toast(config) return MangoToast.new(config) end
function MangoLiquidUI.tstack(config) return MangoToast.newStack(config) end
function MangoLiquidUI.ctx(config) return MangoContextMenu.new(config) end
function MangoLiquidUI.bsheet(config) return MangoBottomSheet.new(config) end
function MangoLiquidUI.blur(config) return MangoBlurProxy.new(config) end
function MangoLiquidUI.form(config) return MangoForm.new(config) end
function MangoLiquidUI.focus(config) return MangoFocusManager.new(config) end
function MangoLiquidUI.colr(config) return MangoColorPicker.new(config) end
function MangoLiquidUI.key(config) return MangoKeybind.new(config) end
function MangoLiquidUI.carousel(config) return MangoCarousel.new(config) end
function MangoLiquidUI.csel(config) return MangoCarousel.new(config) end
function MangoLiquidUI.window(config) return MangoWindow.new(config) end
function MangoLiquidUI.build(componentType) return MangoBuilder.build(componentType) end
function MangoLiquidUI.protect(config) MangoProtection.configure(config) end
function MangoLiquidUI.isProtected() return MangoProtection.isProtected() end
function MangoLiquidUI.protectionLevel() return MangoProtection.getProtectionLevel() end

-- ScreenGui helper
function MangoLiquidUI.gui(name)
    local gui = MangoProtection.createScreenGui({})
    if name and not MangoProtection.isProtected() then
        gui.Name = name
    end
    return gui
end

-- Theme transition helper
function MangoLiquidUI.transitionTheme(glassFrames, fadeDuration, rebuildCallback)
    local TweenService = game:GetService("TweenService")
    local fadeInfo = TweenInfo.new(fadeDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local pending = #glassFrames
    if pending == 0 then
        rebuildCallback()
        return
    end
    for _, glass in glassFrames do
        for _, shadow in glass.ShadowLayers do
            shadow.Visible = false
        end
        local tween = TweenService:Create(glass.GlassSurface, fadeInfo, { BackgroundTransparency = 1 })
        tween.Completed:Connect(function()
            pending -= 1
            if pending <= 0 then
                local newFrames = rebuildCallback()
                local fadeInInfo = TweenInfo.new(fadeDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
                for _, newGlass in newFrames do
                    local targetTransp = newGlass.GlassSurface.BackgroundTransparency
                    newGlass.GlassSurface.BackgroundTransparency = 1
                    TweenService:Create(newGlass.GlassSurface, fadeInInfo, { BackgroundTransparency = targetTransp }):Play()
                end
            end
        end)
        tween:Play()
    end
end

-- Auto-play intro on require
task.spawn(function()
    MangoIntro.play()
end)

return MangoLiquidUI
